#+TAGS: UNRESOLVED(u) QUESTIONS(q) EXTRA(e) REQUIRED(r) TOBEORG(t)
* Lab 1 javac, java, git
** Using Git
*** B. Local Repositories (Narrative Introduction)
   - ~git init~: Creates a box in which to permanently store panoramic pictures.
   - ~git add~: Takes a temporary photo of one thing that can be assembled into a panoramic photo later.
   - ~git commit~: Assembles all available temporary photos into a panoramic photo. Also destroys all temporary photos.
   - ~git log~: Lists all the panoramic photos we’ve ever taken.
   - ~git show~: Looks at what is in a particular panoramic photo.
   - ~git chechout~: Rearranges files back to how they looked in a given panoramic photo. Does not affect the panormiac photos in your box in any way.
*** C. Local Repositories (Technical Overview)
**** Initializing Local Repositories
     ~git init~: Git creates a .git subdirectory. Inside this directory it will store a bunch of metadata, as well as old the actual snapshots of the files. 
**** Tracked vs. Untracked Files
     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-08 15:59:57
     [[file:pictures/lab01/screenshot_2019-03-08_15-59-57.png]]
     TWo main categories: *untracked files* and *tracked files*.
     ~git status~: Determining the exact status(untracked, unmodified, modified staged) of each file in your repository.
**** Staging & Committing
     - ~git add FILE~: Stage a file.
     - ~git commit -m MESSAGE~: Commit snapshot as one block with a message.
     - ~git log~: See previous commits
**** Undoing Changes
     - ~git reset HEAD [file]~: Unstage a file that you haven’t yet committed, this will take the file’s status back to modified, leaving changes intact, equivalent of deleting one of the temporary images that you’re going to combine into a panorama.
     - ~git add [forgotten-file]~ + ~git commit --amend~: Amend latest commit (changing commit message or add forgotten files).
     - ~git checkout -- [file]~: Revert a file to its state at the time of the most recent commit.
     - ~git chechout commitnumber repository/file~: Revert a file to a specific commit.
*** D. Remote Repositories
    - ~git clone [remote-repo-URL]~: Makes a copy of the specified repository, but on your local computer. Also creates a working directory that has files arranged exactly like the most recent snapshot in the download repository. Also records the URL of the remote repository for subsequent network data transfers, and gives it the special remote-repo-name “origin”.
    - ~git remote add [remote-repo-name]~: Records a new location for network data transfers.
    - ~git remote -v~: Lists all locations for network data transfers.
    - ~git pull [remote-repo-name] master~: Get the most recent copy of the files as seen in remote-repo-name
    - ~git push [remote-repo-name] master~: Pushes the most recent copy of your files to the remote-repo-name.

** C. Git Exercise

   #+begin_src sh 
     touch lab1-checkoff
     cd lab1-checkoff/
     nano 61b.txt
     nano 61c.txt
     git add 61b.txt
     git commit -m "Add61b.txt"
     nano 61b.txt
     git add 61b.txt 61c.txt
     git commit -m "Update 61b.txt and add 61c.txt"
     nano 61b.txt
     git checkout -- 61b.txt
     git checkout 39e3c4ec06c95d57fda6e8d18e32cdcb05a9bb6e ./61b.txt
   #+end_src 

** F. Leap Year
*** Style
    #+begin_example
      Running style check on 2 files...
      LeapYear.java:37:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
      LeapYear.java:38:14: Conditional logic can be removed. [SimplifyBooleanReturn]
      LeapYear.java:40:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
      HelloNumbers.java:0: File does not end with a newline. [NewlineAtEndOfFile]
    #+end_example
     
    #+begin_src java :classname 
      // before
      if (year % 400 == 0) {
          return true;
      } else {
          return (year % 4 == 0 && year % 100 != 0);
      }
      // after
      if (year % 400 == 0) {
          return true;
      } else return (year % 4 == 0 && year % 100 != 0);

    #+end_src 
* Lab 2 Unit Testing with JUnit and IntLists 
** Application: IntLists
   #+begin_src java :classname 
     /**
      ,* Returns a list equal to L with all elements squared. Destructive.
      ,*/
     public static void dSquareList(IntList L) {

         while (L != null) {
             L.first = L.first * L.first;
             L = L.rest;
         }
     }

     /**
      ,* Returns a list equal to L with all elements squared. Non-destructive.
      ,*/
     public static IntList squareListIterative(IntList L) {
         if (L == null) {
             return null;
         }
         IntList res = new IntList(L.first * L.first, null);
         IntList ptr = res;
         L = L.rest;
         while (L != null) {
             ptr.rest = new IntList(L.first * L.first, null);
             L = L.rest;
             ptr = ptr.rest;
         }
         return res;
     }

     /**
      ,* Returns a list equal to L with all elements squared. Non-destructive.
      ,*/
     public static IntList squareListRecursive(IntList L) {
         if (L == null) {
             return null;
         }
         return new IntList(L.first * L.first, squareListRecursive(L.rest));
     }

     /** DO NOT MODIFY ANYTHING ABOVE THIS LINE! */


     /**
      ,* Returns a list consisting of the elements of A followed by the
      ,* *  elements of B.  May modify items of A. Don't use 'new'.
      ,*/

     public static IntList dcatenateIterative(IntList A, IntList B) {
         //TODO:  fill in method
         if (A == null){
             return B;
         }
         else {
             IntList C = A;
             while (C.rest != null){
                 C = C.rest;
             }
             C.rest = B;
             return A;
         }

     }

     public static IntList dcatenateRecursive(IntList A, IntList B) {
         //TODO:  fill in method
         if (A == null){
             return B;
         }
         else {
             IntList C = dcatenateIterative(A.rest, B);
             A.rest = C;
             return A;
         }
     }

     /**
      ,* Returns a list consisting of the elements of A followed by the
      ,* * elements of B.  May NOT modify items of A.  Use 'new'.
      ,*/
     public static IntList catenateIterative(IntList A, IntList B) {
         //TODO:  fill in method
          if (A == null){
             return B;
          }
          else {
              IntList C = new IntList(A.first, null);
              IntList D = C;
              while (A.rest != null) {
                  D.rest = new IntList(A.rest.first, null);
                  D = D.rest;
                  A = A.rest;
              }
              D.rest = B;
              return C;
          }
     }


     /**
      ,* Returns a list consisting of the elements of A followed by the
      ,* * elements of B.  May NOT modify items of A.  Use 'new'.
      ,*/
     public static IntList catenateRecursive(IntList A, IntList B) {
         //TODO:  fill in method
          if (A == null){
             return B;
          }
          else {
              IntList C = new IntList(A.first, catenateIterative(A.rest, B));
              return C;
          }
     }
   #+end_src 
   - Destructive: no ~new IntList~ 
     - Iterative: ~IntList B = A~ and ~while (B...) {}~
     - Recursive: ~IntList B = recursivefunc(A...)~ 
   - Non-destructive: use ~new IntList~ 
     - Iterative: ~IntList B = new IntList()~ and ~IntList C = B~
     - Recursive: ~IntList B = new IntList(recursivefunc(A...)...)~ 
* Lab 3 Unit Testing with JUnit, Debugging
** Writing a Reverse Method
   #+begin_src java :classname 
     public static IntList dreverse(IntList A) {
         IntList reverseList, B;
         for (reverseList = null; A != null; A = B) {
             B = A.rest;
             A.rest = reverseList;
             reverseList = A;
         }
         return  reverseList;
     }

     public static IntList reverse(IntList A) {
         IntList reverseList;
         for (reverseList = null; A != null; A = A.rest) {
             reverseList = new IntList(A.first, reverseList);
         }
         return reverseList;
         }
   #+end_src 
   #+begin_src java :classname 
     @Test
     public void testdReverse() {
         IntList A = IntList.of(1,2,3);
         IntList nullList = null;
         assertEquals(IntList.of(3,2,1), IntList.dreverse(A));
         IntList.dreverse(A);
         assertNotEquals(IntList.of(1, 2, 3), A);
         assertEquals(nullList, IntList.reverse(nullList));
     }

     @Test
     public void testReverse() {
         IntList A = IntList.of(1,2,3);
         IntList nullList = null;
         assertEquals(IntList.of(3,2,1), IntList.reverse(A));
         IntList.reverse(A);
         assertEquals(IntList.of(1, 2, 3), A);
         assertEquals(nullList, IntList.reverse(nullList));
     }
   #+end_src 
   - ~testdReverse~ for ~dreverse~ and ~testReverse~ for ~reverse~
   - ~assertEquals~ and ~assertNotEquals~
   - ~import static org.junit.Assert.*;~ and ~import org.junit.Test;~
*** Question:                                                     :QUESTIONS:
    1. ~dreverse~ 和 ~reverse~ 理解，特别是 ~dreverse~ 的思路？
    2. ~A~ 作为实参传递到函数后，为何 ~A = A.rest~ 不是 destructive 而 ~A.rest = ...~ 往往是 destructive ？传 ~A~ 并不是引用传递而仍然是值传递？所以返回后 ~A~ 中存储的地址不会变， ~A~ 指向的 reference type object 也不会变？ <<elink2>>
    3. Java 里实参到形参的引用传递（地址传递）和值传递？
** Flik int vs Integer as formal paras
   #+begin_src java :classname 
     public class Flik {
         public static boolean isSameNumber(int a, int b) {
             return a == b;
         }
     }
   #+end_src 
   - ~int~ is a *primitive* data type while ~Integer~ is a ~Wrapper~ class
* Lab 5 Huglife
** ~Plip~
*** Basic Plip functionality
    #+begin_src java :classname 
      public void move() {
          // TODO
          energy -= 0.15;
          if (energy <= 0) {
              energy = 0;
              return;
          }
      }


      /**
       ,* Plips gain 0.2 energy when staying due to photosynthesis.
       ,*/
      public void stay() {
          // TODO
          energy += 0.2;
          if (energy >= 2) {
              energy = 2;
              return;
          }
      }
    #+end_src 
    - ~if~ in the end 
*** chooseAction method
    #+begin_src java :classname 
      public Action chooseAction(Map<Direction, Occupant> neighbors) {
          // Rule 1
          Deque<Direction> emptyNeighbors = new ArrayDeque<>();
          boolean anyClorus = false;
          // TODO
          // (Google: Enhanced for-loop over keys of NEIGHBORS?)
          // for () {...}
          for (Map.Entry<Direction, Occupant> entry : neighbors.entrySet()) {
              if (entry.getValue().name().equals("empty")) {
                  emptyNeighbors.add(entry.getKey());
              }
              if (entry.getValue().equals("clorus")) {
                  anyClorus = true;
              }
          }

          if (emptyNeighbors.isEmpty()) {
              // TODO
              return new Action(Action.ActionType.STAY);
          }

          if (energy >= 1) {
              int indexToMove = StdRandom.uniform(0, emptyNeighbors.size());
              Direction dir = (Direction) emptyNeighbors.toArray()[indexToMove];
              return new Action(Action.ActionType.REPLICATE, dir);
          }

          if (anyClorus && StdRandom.uniform(2) == 0) {
              int indexToMove = StdRandom.uniform(0, emptyNeighbors.size());
              Direction dir = (Direction) emptyNeighbors.toArray()[indexToMove];
              return new Action(Action.ActionType.MOVE, dir);
          }

          return new Action(Action.ActionType.STAY);
      }
    #+end_src
    - Create an ~ArrayDeque~ object: ~Deque<Direction> emptyNeighbors = new ArrayDeque<>()~
    - Iterate on ~Map~: ~for (Map.Entry<Direction, Occupant> entry : neighbors.entrySet())~, ~entry.getValue()~ and ~entry.getKey()~
    - Return a random entry in ~ArrayDeque~: ~StdRandom.uniform(0, emptyNeighbors.size())~ and ~(Direction) emptyNeighbors.toArray()[indexToMove]~
    - Compare ~Object~ objects: ~obj1.equals(obj2)~
    - 50% possibility to move: ~if (anyClorus && StdRandom.uniform(2) == 0)~ 
** ~Clorus~
*** chooseAction method 
    #+begin_src java :classname 
      public Action chooseAction(Map<Direction, Occupant> neighbors) {
          Deque<Direction> emptyNeighbors = new ArrayDeque<>();
          Deque<Direction> plipNeighbors = new ArrayDeque<>();

          for (Map.Entry<Direction, Occupant> entry : neighbors.entrySet()) {

              if (entry.getValue().name().equals("empty")) {
                  emptyNeighbors.add(entry.getKey());
              }

              if (entry.getValue().name().equals("plip")) {
                  plipNeighbors.add(entry.getKey());
              }
          }

          if (emptyNeighbors.isEmpty()) {
              return new Action(Action.ActionType.STAY);
          }

          if (!plipNeighbors.isEmpty()) {
              int index = StdRandom.uniform(0, plipNeighbors.size());
              Direction dir = (Direction) plipNeighbors.toArray()[index];
              return new Action(Action.ActionType.ATTACK, dir);
          } else {
              int index = StdRandom.uniform(0, emptyNeighbors.size());
              Direction dir = (Direction) emptyNeighbors.toArray()[index];
              if (energy >= 1) {
                  return new Action(Action.ActionType.REPLICATE, dir);
              }
              return new Action(Action.ActionType.MOVE, dir);
          }
      }
    #+end_src 
    - Store ~Plip~ objects' directions: ~Deque<Direction> plipNeighbors = new ArrayDeque<>()~
* Lab 6 Disjoint Sets
** Weighted Quick Union with Path Compression 
*** union
    #+begin_src java :classname 
      public void union(int v1, int v2) {
          // TODO
          validate(v1);
          validate(v2);
          if (!connected(v1, v2)) {
              if (sizeOf(v1) <= sizeOf(v2)) {
                  vertice[find(v2)] += vertice[find(v1)];
                  vertice[find(v1)] = find(v2);
              } else {
                  vertice[find(v1)] += vertice[find(v2)];
                  vertice[find(v2)] = find(v1);
              }
          }
      }
    #+end_src 
    - ~validate~ --> ~connected~ --> connect
    - ~vertice[find(v2)] += vertice[find(v1)];~ and ~vertice[find(v1)] = find(v2);~ 
*** find and parent
    #+begin_src java :classname 
      public int find(int vertex) {
          // TODO
          return vertice[vertex] < 0 ? vertex : find(parent(vertex));
      }

      public int parent(int v1) {
          // TODO
          return vertice[v1] < 0 ? v1 : vertice[v1];
      }
    #+end_src 
    - ~expression1 ? expression2 : expression3~ 
*** conneted
    #+begin_src java :classname 
      public boolean connected(int v1, int v2) {
          // TODO
          int r1 = find(v1);
          int r2 = find(v2);
          int p1 = parent(v1);
          int p2 = parent(v2);
    
          while (p1 != r1) {
              vertice[v1] = r1;
              v1 = p1;
              p1 = parent(v1);
          }
          while (p2 != r2) {
              vertice[v2] = r2;
              v2 = p2;
              p2 = parent(v2);
          }
    
          return r1 == r2;
      }
    #+end_src 
    - ~vertice[v1] = r1;~, ~v1 = p1~ and ~p1 = parent(v1)~ 
** Tests
*** TestUnionFind
    #+begin_src java :classname 
      @Test
      public void testConstructor() {
          UnionFind actual = new UnionFind(5);
          int[] expect = new int[5];
          Arrays.fill(expect, -1);
          assertArrayEquals(expect, actual.getSet());
      }

      @Test
      public void testUnion() {
          UnionFind actual = new UnionFind(5);
          actual.union(1, 0);
          int[] expect1 = {-2, 0, -1, -1, -1};
          assertArrayEquals(expect1, actual.getSet());
          actual.union(3, 2);
          int[] expect2 = {-2, 0, -2, 2, -1};
          assertArrayEquals(expect2, actual.getSet());
          actual.union(4, 3);
          int[] expect3 = {-2, 0, -3, 2, 2};
          assertArrayEquals(expect3, actual.getSet());
          actual.union(0, 3);
          int[] expect4 = {2, 0, -5, 2, 2};
          assertArrayEquals(expect4, actual.getSet());
          actual.union(0, 0);
          actual.union(1, 1);
          assertArrayEquals(expect4, actual.getSet());
          actual.union(1, 3);
          int[] expect5 = {2, 0, -5, 2, 2};
          assertArrayEquals(expect5, actual.getSet());
      }

      @Test
      public void testUnionPC() {
          UnionFind actual = new UnionFind(5);
          actual.union(1, 0);
          actual.union(3, 2);
          actual.union(4, 3);
          actual.union(0, 3);
          actual.union(0, 0);
          actual.union(1, 1);
          actual.union(1, 3);
          int[] expect5 = {2, 2, -5, 2, 2};
          assertArrayEquals(expect5, actual.getSet());
      }
    #+end_src 
    - ~int[] expect = new int[5]~ and ~Arrays.fill(expect, -1)~, not ~int expect[]~ but ~int[] expect~ 
** Challenge Lab 6 Falling Bubbles                         :UNRESOLVED:EXTRA:
* Lab 7 TreeMap
** ~BSTMap~
*** ~class Node~
    #+begin_src java :classname 
      public class BSTMap<K extends Comparable<K>, V> implements Map61B<K, V> { <<elinktemp3>>

          private Node root;

          private class Node {
              private K key;
              private V val;
              private Node left, right;
              private int size;

              public Node(K key, V val, int size) {
                  this.key = key;
                  this.val = val;
                  this.size = size;
              }
          }
          ...
      }
    #+end_src 
    - ~public class BSTMap<K extends Comparable<K>, V> implements Map61B<K, V>~ 
    - ~private class Node~
*** ~clear~ 
    #+begin_src java :classname 
      public void clear() {
          root = null;
      }

      // not below
      public void clear() {
          clear(root);
      }

      public void clear(Node n) {
          n = null;
      }
    #+end_src 
    - ~n = root~ and ~n = nulll~ can not -> ~root = null~ 
*** ~get~
    #+begin_src java :classname 
      public int size() {
          return size(root);
      }

      public V get(Node n, K key) { <<elink6>>
          if (key == null) throw new IllegalArgumentException("calls get() with a null key");
          if (n == null) return null;
          int cmp = key.compareTo(n.key);
          if      (cmp < 0) return get(n.left, key);
          else if (cmp > 0) return get(n.right, key);
          else              return n.val;
      }
    #+end_src 
    - ~int cmp = key.compareTo(n.key)~
    - Recursive: ~null~ + ~get(n.left, key)~ and ~get(n.right, key)~ 
*** ~updateSize~
    #+begin_src java :classname 
      private int updateSize(Node n) {
          if (n == null) return 0;
          n.size = 1 + updateSize(n.left) + updateSize(n.right);
          return n.size;
      }
    #+end_src 
    - Recursive: ~n.size = 1 + updateSize(n.left) + updateSize(n.right)~ 
*** ~put~ <<elink4>>
    #+begin_src java :classname 
      public void put(K key, V value) {
          if (key == null) throw new IllegalArgumentException("calls put() with a null key");
          root = put(root, key, value);
      }

      public Node put(Node n, K key, V val) {
          if (n == null) return new Node(key, val, 1);
          int cmp = key.compareTo(n.key);
          if      (cmp < 0) n.left  = put(n.left,  key, val);
          else if (cmp > 0) n.right = put(n.right, key, val);
          else              n.val   = val;
          n.size = updateSize(n);
          return n;
      }
    #+end_src 
    - Recursive: ~new Node(key, val, 1)~ + ~n.left  = put(n.left,  key, val)~ and ~n.right = put(n.right, key, val)~ 
*** ~remove~ 
    - ~remove~
      #+begin_src java :classname 
        public V remove(K key) {
            return remove(key, root);
        }

        public V remove(K key, Node n) {
            if (key == null) throw new IllegalArgumentException("calls delete() with a null key");
            if (containsKey(key)) {
                V result = get(key);
                root = updateBST(key, n);
                updateSize(n);
                return result;
            }
            return null;
        }

        public Node updateBST(K key, Node n) { <<elink5>>
            int cmp = key.compareTo(n.key);
            if (cmp < 0)        n.left = updateBST(key, n.left);
            else if (cmp > 0)   n.right = updateBST(key, n.right);
            else {
                if      (size(n) == 1)      n = null;
                else if (n.left == null)    n = n.right;
                else if (n.right == null)   n = n.left;
                else {
                    Node max = maxNode(n.left);
                    n.left = updateBST(max.key, n.left);
                    n.key = max.key;
                    n.val = max.val;
                }
            }
            return n;
        }

        private Node maxNode(Node n) {
            // if (n == null || n.right == null) return n;
            if (n.right == null) return n;
            return maxNode(n.right);
        }
      #+end_src
      - ~Node updateBST~ to *update* the BST, and ~root = updateBST(key, n)~ to *redirect* ~root~ to the *updated* BST
      - Recursive: ~n.left = updateBST(key, n.left)~, ~n.right = updateBST(key, n.right)~
      - When ~size >= 3~ 
        #+begin_src java :classname 
          Node max = maxNode(n.left);
          n.left = updateBST(max.key, n.left);
          n.key = max.key;
          n.val = max.val;
        #+end_src 
    - ~removeV~
      #+begin_src java :classname 
        public V removeV(K key, Node n) {
            if (key == null) throw new IllegalArgumentException("calls delete() with a null key");
            if (containsKey(key)) {
                if (n.size == -1) return remove(key, n.right);
                int cmp = key.compareTo(n.key);
                if      (cmp > 0) return remove(key, n.right);
                else if (cmp < 0) return remove(key, n.left);
                else {
                    V result = n.val;

                    if (n == root) {
                        Node tempP = new Node(n.key, n.val, -1);
                        tempP.right = root;
                        root = tempP;
                        V tempV = remove(key, root);
                        root = root.right;
                    } else {

                        Node p = getParent(n, root);

                        if (size(n) == 1) {
                            if (p.left == n) p.left = null;
                            else             p.right = null;
                        } else if (n.left == null) {
                            if (p.left == n) p.left = n.right;
                            else             p.right = n.right;
                        } else if (n.right == null) {
                            if (p.left == n) p.left = n.left;
                            else             p.right = n.left;
                        } else if (n.left.right == null) {
                            n.left.right = n.right;
                            if (p.left == n) p.left = n.left;
                            else             p.right = n.left;
                        } else if (n.right.left == null) {
                            n.right.left = n.left;
                            if (p.left == n) p.left = n.right;
                            else             p.right = n.right;
                        } else {
                            Node max = maxNode(n.left);
                            Node maxP = getParent(max, root);
                            maxP.right = max.left;
                            max.left = maxP;
                            max.right = n.right;
                            if (p.left == n) p.left = max;
                            else             p.right = max;
                        }
                    }

                    updateSize(root);
                    return result;
                }
            }
            return null;
        }
      #+end_src 
      - When calling ~maxNode~, need ~if (n == null || n.right == null)~ not ~if (n.right == null || n == null)~ 
*** ~keySet~ <<1>>
    #+begin_src java :classname 
      public Set<K> keySet() {
          return keySet(root);
      }

      public Set<K> keySet(Node n) {
          if (n == null) return Collections.emptySet();
          Set<K> s = new HashSet<>();
          s.addAll(keySet(n.left));
          s.add(n.key);
          s.addAll(keySet(n.right));
          return s;
      }
    #+end_src 
    - ~Collections.emptySet()~ for empty set
    - ~s1.add(element)~ and ~s1.addAll(s2)~
    - ~s.addAll(keySet(n.left))~ --> ~s.add(n.key)~ --> ~s.addAll(keySet(n.right))~ to get *sorted* ~keySet~ 
*** ~iterator~ and ~printInOrder~
    #+begin_src java :classname 
      public Iterator<K> iterator() {
          return keySet(root).iterator();
      }
    #+end_src 
    #+begin_src java :classname 
      public void printInOrder() {
          for (K k : keySet(root)) {
              System.out.println(k);
          }
      }
    #+end_src 
    - ~Set~ *implements* ~Collections~, while ~Collection~ *implements* ~Iterable~ -> ~Set~ is *iterable*, ~Set.iterator~ to return ~Iterator~ [[2]]
    - ~for~ can be used on *iterables* [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<elink2>>][Iteration]]
*** Question:                                                     :QUESTIONS:
    - [ ] 这种把方法定义全部以树为单位 与 以节点为单位的区别与优劣？而对于 ~size~ 又不是以树为单位，而是以节点为单位？
    - [ ] ~keySet~ 的直接实现or用额外实例变量 ~list~ 存储实现，与 ~printInOrder~ 和 ~iterator~ 在这两种实现下的不同？ [[1]] 直接实现对吗？用额外的 ~list~ 是否不好实现，因为存储结构不方便遍历树？什么情况下不方便直接实现而需要采用一种合适的结构间接实现呢？以及是否间接实现就要详细写 ~Iterator~ ？间接结构怎么选择？
    - [ ] BST 有 ~replace(key, value)~ 操作吗？可以 ~remove~ + ~put~, 有直接点的办法吗？怎么调整 BST 的结构
** Tests
*** TestBSTMapExtra (~testkeySet~)
    #+begin_src java :classname 
      @Test 
      public void testkeySet() {
          BSTMap actual = new BSTMap();
          actual.put("d", 1);
          actual.put("b", 1);
          actual.put("a", 1);
          actual.put("c", 1);
          actual.put("e", 1);
          actual.put("f", 1);
          actual.put("g", 1);
          String[] c = {"a", "b", "c", "d", "e", "f", "g"};
          Set<String> expect = new HashSet<>(Arrays.asList(c));
          assertEquals(actual.keySet(), expect);
          Iterator<String> seer = actual.iterator();
          assertEquals(seer.next(), "a");
          assertEquals(seer.next(), "b");
          assertEquals(seer.next(), "c");
          assertEquals(seer.next(), "d");
          assertEquals(seer.next(), "e");
          assertEquals(seer.next(), "f");
          assertEquals(seer.next(), "g");
      }
    #+end_src 
    - Comparison among ~Arrays~, ~List~ and ~Set~ <<elink1>>
      - ~List~ and ~Set~ are *interfaces*, while ~Arrays~ is a *class*
        - Interface: Both ~List~ and ~Set~ *implement* ~Collection~, while ~Collection~ *implements* ~Iterable~
        - Class: ~Arrays~ *extends* ~Object~ 
      - Convertion
        - ~List~ <-> ~Arrays~
          - ~Arrays~ -> ~List~ <<2>>
            #+begin_src java :classname 
              String[] s = new String[]{"A", "B", "C", "D","E"};
              List<String> list = Arrays.asList(s);

              s[0] ="AA";
              System.out.println("list: " + list);

              list: [AA, B, C, D, E]
            #+end_src
            - ~Arrays.asList(array)~
            - Elements in ~list~ *equals* elements in ~s~: changes in ~s~ will affect ~list~ 
          - ~List~ -> ~Arrays~ <<3>>
            #+begin_src java :classname 
              String[] dest = list.toArray(new String[0]);//new String[0]是指定返回数组的类型
              System.out.println("dest: " + Arrays.toString(dest));

              dest: [AA, B, C, D, E]

              list.set(0, "Z");
              System.out.println("modified list: " + list);
              System.out.println("dest: " + Arrays.toString(dest));

              modified list: [Z, B, C, D, E]
              dest: [AA, B, C, D, E]
            #+end_src
            - ~list.toArray(Array type)~
            - Elements in ~dest~ *not equals* elements in ~list~: changes in ~list~ won't affect ~dest~ 
        - ~List~ <-> ~Set~ 
          - ~List~ -> ~Set~: ~Set<String> set = new HashSet<>(list);~ 
          - ~Set~ -> ~List~: ~List<String> list_1 = new ArrayList<>(set);~
          - Same as ~toArray()~, changes won't affect
          - Can also use ~addAll(Collection<? extends E> c)~ to convert
        - ~Arrays~ <-> ~Set~ 
          - ~Arrays~ -> ~Set~: ~set = new HashSet<>(Arrays.asList(s));~ 
          - ~Set~ -> ~Arrays~: ~dest = set.toArray(new String[0]);~  
      - ~Arrays.asList()~ and ~Collection.toArray()~
        - ~Arrays.asList~
          ~public static <T> List<T> asList(T... a)~: Returns a *fixed-size list* backed by the *specified array*.
          #+begin_src java :classname 
            public class Arrays {
                ...

                @SafeVarargs
                @SuppressWarnings("varargs")
                public static <T> List<T> asList(T... a) {
                    return new ArrayList<>(a);
                }
                ...
                 private static class ArrayList<E> extends AbstractList<E>
                    implements RandomAccess, java.io.Serializable
                {
                    private static final long serialVersionUID = -2764017481108945198L;
                    private final E[] a;

                    ArrayList(E[] array) {
                        a = Objects.requireNonNull(array);
                    }

                    ...
                }
            }
          #+end_src
          - ~ArrayList~ above is different from ~java.util.ArrayList~, it's a *nest class* of ~java.util.Arrays~ 
          - ~list~ [[2]] is an *instance* of ~java.util.Arrays$ArrayList~, not ~java.util.ArrayList~
          - Return of ~Arrays.asList~ is *fixed-size*, doesn't have ~resize~ as ~java.util.ArrayList~ 
        - ~Collection.toArray()~
          - ~Object[] toArray()~: Returns an *array* containing all of the elements in this *collection*
            #+begin_src java :classname 
              public abstract class AbstractCollection<E> implements Collection<E> {
                  ...

                  public Object[] toArray() {
                      // Estimate size of array; be prepared to see more or fewer elements
                      Object[] r = new Object[size()];
                      Iterator<E> it = iterator();
                      for (int i = 0; i < r.length; i++) {
                          if (! it.hasNext()) // fewer elements than expected
                              return Arrays.copyOf(r, i);
                          r[i] = it.next();
                      }
                      return it.hasNext() ? finishToArray(r, it) : r;
                  }
              }
            #+end_src
          - ~<T> T[] toArray(T[] a)~: Returns an *array* containing all of the elements in this *collection*; the *runtime type* of the returned array is that of the specified array.
            #+begin_src java :classname 
              public abstract class AbstractCollection<E> implements Collection<E> {
                  ...

                  @SuppressWarnings("unchecked")
                  public <T> T[] toArray(T[] a) {
                      // Estimate size of array; be prepared to see more or fewer elements
                      int size = size();
                      T[] r = a.length >= size ? a :
                                (T[])java.lang.reflect.Array
                                .newInstance(a.getClass().getComponentType(), size);
                      Iterator<E> it = iterator();

                      for (int i = 0; i < r.length; i++) {
                          if (! it.hasNext()) { // fewer elements than expected
                              if (a == r) {
                                  r[i] = null; // null-terminate
                              } else if (a.length < i) {
                                  return Arrays.copyOf(r, i);
                              } else {
                                  System.arraycopy(r, 0, a, 0, i);
                                  if (a.length > i) {
                                      a[i] = null;
                                  }
                              }
                              return a;
                          }
                          r[i] = (T)it.next();
                      }
                      // more elements than expected
                      return it.hasNext() ? finishToArray(r, it) : r;
                  }

                  ...
              }
            #+end_src
            - *Runtime type* of ~dest~ [[3]] is ~String[]~, decided by ~new String[0]~ 
**** Question:                                                   :QUESTIONS:
     1. 是否 ~List~ 和 ~Set~ 都没有固定长度而 ~Arrays~ 的长度是指定的？
     2. ~Arrays.asList~ 返回的 ~ArrayList~ 和 ~java.util.ArrayList~ 异同？除了固定长度还有啥？
     3. ~Collection.toArray~ 返回的 ~Arrays~ 和 ~java.util.Arryas~ 异同？
** Challenge BST Performance                               :UNRESOLVED:EXTRA:
* Lab 8 HashMap 
** ~MyHashMap~ 
*** ~class Entry<K, V>~ 
    #+begin_src java :classname 
      public class MyHashMap<K extends Comparable<K>, V> implements Map61B<K, V> {
          private int initialSize;
          private double loadFactor;
          private Entry<K, V>[] buckets;
          private int size;
          private Set<K> keys;

          private static class Entry<K, V> {
              K key;
              V val;
              Entry<K, V> next;

              Entry(K key, V val, Entry<K, V> next) {
                  this.key = key;
                  this.val = val;
                  this.next = next;
              }

              V get(K key) {
                  Entry<K, V> e = this;
                  while (e != null) {
                      if (e.key.equals(key)) return e.val;
                      e = e.next;
                  }
                  return null;
              }

              void update(K key, V val) {
                  Entry<K, V> e = this;
                  while (e != null) {
                      if (e.key.equals(key)) {
                          e.val = val;
                          break;
                      }
                      e = e.next;
                  }
              }

              void add(K key, V val) {
                  Entry<K, V> e = this;
                  while (true) {
                      if (e.next == null) {
                          e.next = new Entry<>(key, val, null);
                          break;
                      }
                      e = e.next;
                  }
              }

              V remove(K key) {
                  V r = this.get(key);
                  Entry<K, V> e = this;
                  while (true) {
                      if (e.next.key.equals(key)) {
                          e.next = e.next.next;
                          break;
                      }
                      e = e.next;
                  }
                  return r;
              }
          }
          ...
      }
    #+end_src 
    - ~private static class Entry<K, V>~ and ~private Entry<K, V>[] buckets~
    - ~Entry(K key, V val, Entry<K, V> next)~ 
    - ~Entrn<K, V> e = this~
    - ~get~ and ~update~: ~while ((e != Null))~, ~e.key.equals(key)~ and ~e = e.next~ 
    - ~add~ and ~remove~: ~while (true)~, ~(e.next == null)~ + ~e.next = new Entry<>(key, val, null)~, ~(e.next.key.equals(key))~ + ~e.next = e.next.next~ and ~e = e.next~ 
**** Question:                                                :SUM:QUESTIONS:
     - [ ] 关于泛型，什么时候最好在类型声明或者构造函数时加上泛型声明 ~<K, V>~
     - [ ] 关于 ~public~, ~private~ 和 ~protected~ 在嵌套类型及其成员变量和函数的声明：为什么 ~Entry~ 中成员变量和函数都不用声明？不管什么关键词都可以访问嵌套类中的任何成员？
     - [ ] 关于 ~buckets~ 底层结构 
       - [ ] 底层结构为什么不能用 ~Entry[] buckets = (Entry[]) new Object[N]~ 转换？ ~T[] t = (T[]) new Object[N]~ [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<elinktemp1>>][Object cast to Glorp]] 为什么可以？是 ~Glorp~ 只能是 initial types 吗？还是 built-in types 都可以？
       - [ ] 最理想的应该是 ~Map~, 自带的 ~HashMap~ 底层结构是 ~Map~ 吗？如果不能用 ~Map~, 那 ~LinkedList~, ~ArrayList~ 和 ~Set~ 该怎么选择？用这三者的话是否需要重写 ~equals()~ 和 ~hashcode~ ？具体在哪重写呢？必要结合源码讨论。
     - [ ] 关于 ~Comparable~ 与 ~Comparator~, ~Iterable~ 与 ~Iterator~ <<elink3>>
       - [ ] 都是 ~interface~ 的话，为什么 [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<elinktemp2>>][class implements Comparable]] 而 [[<<elinktemp3>>][<K extends Comparable<K>, V>]]？是不是 ~class implements interface~, ~interface extends interface~ 以及 ~K extends interface~
       - [ ] 关于 ~Comparable~, ~Comparator~, ~Iterable~ 和 ~Iterator~ 的比较 [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<elink1>>][比较1]] [[file:~/csnds/Dropbox/orglife/61b_rnl.org::<<ilink1>>][比较2]]
       - [ ] 关于 ~equals~ 和 ~hashCode~: ~Object~ 和 ~Comparator~ 里 ~equals()~ 的区别以及什么时候需要一起重写 ~hashCode()~ ？
*** ~MyHashMap~ 
    #+begin_src java :classname 
      public MyHashMap() {
          this(16, 0.75);
      }
      public MyHashMap(int initialSize) {
          this(initialSize, 0.75);
      }

      public MyHashMap(int initialSize, double loadFactor) {
          this.initialSize = initialSize;
          this.loadFactor = loadFactor;
          buckets = new Entry[initialSize];
          size = 0;
          keys = new HashSet<>();
      }
    #+end_src 
    - ~MyHashMap()~, ~MyHashMap(int initialSize)~ and ~MyHashMap(int initialSize, double loadFactor)~
    - ~buckets = new Entry[initialSize]~ and ~keys = new HashSet<>()~ 
*** ~clear~ 
    #+begin_src java :classname 
      @Override
      public void clear() {
          keys.removeAll(keys);
          size = 0;
          Arrays.fill(buckets, null);
      }
    #+end_src 
    - ~keys.removeAll(keys)~
    - ~Arrays.fill(buckets, null)~ 
*** ~put~ and ~resize~ 
    #+begin_src java :classname 
      @Override
      public void put(K key, V value) {
          if (key == null) throw new IllegalArgumentException();
          if ((float) size / initialSize > loadFactor) resize();
          int index = (key.hashCode() & 0x7FFFFFFF) % initialSize;
          if (containsKey(key)) {
              buckets[index].update(key, value);
          } else {
              if (buckets[index] == null) {
                  buckets[index] = new Entry<K, V>(key, value, null);
              } else {
                  buckets[index].add(key, value);
              }
              size += 1;
              keys.add(key);
          }
      }

      private void resize() {
          MyHashMap<K, V> m = new MyHashMap<>(2 * initialSize, loadFactor);
          for (int i = 0; i < buckets.length; i++) {
              Entry<K, V> e = buckets[i];
              while (e != null) {
                  m.put(e.key, e.val);
                  e = e.next;
              }
          }
          this.buckets = m.buckets; <<ilink1>>
          initialSize = 2 * initialSize;
      }
    #+end_src 
    - ~index = (key.hashCode() & 0x7FFFFFFF) % initialSize~
    - ~containsKey(key)~ + ~buckets[index].update(key, value)~, ~(buckets[index] == null)~ + ~buckets[index] = new Entry<K, V>(key, value, null)~ and ~buckets[index].add(key, value)~
    - ~Entry<K, V> e = buckets[i]~, ~m.put(e.key, e.val)~ and ~this.buckets = m.buckets~
**** Question:                                                    :QUESTIONS:
     - [ ] 做完
       - [ ] 针对 ~put~ 和 ~remove~ 怎么加一个哨兵节点来一般化？主要是哨兵节点的 ~<K, V>~ 怎么确定？
       - [ ] [[ilink1]] ~m.buckets~ 为什么能从 ~m~ 访问到？因为这是在成员函数里吗？
*** ~keySet~, ~containsKey~ and ~iterator~ 
    #+begin_src java :classname 
      public Set<K> keySet() {
          //        return keys;
          Set<K> k = new HashSet<>();
          for (int i = 0; i < buckets.length; i++) {
              Entry<K, V> e = buckets[i];
              while (e != null) {
                  k.add(e.key);
                  e = e.next;
              }
          }
          return k;
      }

      public boolean containsKey(K key) {
          //        return keys.contains(key);
          return keySet().contains(key);
      }

      @Override
      public Iterator<K> iterator() {
          return keys.iterator();
      }
    #+end_src 
    - ~Set<K> k = new HashSet<>()~, ~k.add(e.key)~ and ~keySet().contains(key)~ 
    - ~public Iterator<K> iterator()~ and ~keys.iterator()~ 
*** ~remove~                                                          :EXTRA:
    #+begin_src java :classname 
      @Override
      public V remove(K key) {
          if (key == null) throw new IllegalArgumentException();
          int index = (key.hashCode() & 0x7FFFFFFF) % initialSize;
          if (containsKey(key)) {
              V r;
              if (buckets[index].key.equals(key)) {
                  r = buckets[index].val;
                  buckets[index] = buckets[index].next;
              } else {
                  r = buckets[index].remove(key);
              }
              size -= 1;
              keys.remove(key);
              return r;
          }
          return null;
      }

      @Override
      public V remove(K key, V value) {
          if (get(key).equals(value)) return remove(key);
          return null;
      }
    #+end_src 
    - ~buckets[index].key.equals(key)~ + ~buckets[index] = buckets[index].next~ and ~r = buckets[index].remove(key)~ 

** SpeedTest
   For ~MyHashMap~ and ~java.util.HashMap~, both runtime ~ $N$
** Tests 
*** ~TestMyHashMap~                                                   :TOBEORG:
    #+begin_src java :classname 
      @Test
      public void sanityGenericsTest() {
          try {
              MyHashMap<String, String> a = new MyHashMap<String, String>();
              MyHashMap<String, Integer> b = new MyHashMap<String, Integer>();
              MyHashMap<Integer, String> c = new MyHashMap<Integer, String>();
              MyHashMap<Boolean, Integer> e = new MyHashMap<Boolean, Integer>();
          } catch (Exception e) {
              fail();
          }
      }

      //assumes put/size/containsKey/get work
      @Test
      public void sanityClearTest() {
          MyHashMap<String, Integer> b = new MyHashMap<String, Integer>();
          for (int i = 0; i < 455; i++) {
              b.put("hi" + i, 1);
              //make sure put is working via containsKey and get
              assertTrue(null != b.get("hi" + i)
                          && b.containsKey("hi" + i)); 
          }
          b.clear();
          assertEquals(0, b.size());
          for (int i = 0; i < 455; i++) {
              assertTrue(null == b.get("hi" + i) && !b.containsKey("hi" + i));
          }
      }

      // assumes put works
      @Test
      public void sanityContainsKeyTest() {
          MyHashMap<String, Integer> b = new MyHashMap<String, Integer>();
          assertFalse(b.containsKey("waterYouDoingHere"));
          b.put("waterYouDoingHere", 0);
          assertTrue(b.containsKey("waterYouDoingHere"));
      }

      // assumes put works
      @Test
      public void sanityGetTest() {
          MyHashMap<String, Integer> b = new MyHashMap<String, Integer>();
          assertEquals(null, b.get("starChild"));
          b.put("starChild", 5);
          assertNotEquals(null, b.get("starChild"));
          b.put("KISS", 5);
          assertNotEquals(null, b.get("KISS"));
          assertNotEquals(null, b.get("starChild"));
      }

      // assumes put works
      @Test
      public void sanitySizeTest() {
          MyHashMap<String, Integer> b = new MyHashMap<String, Integer>();
          assertEquals(0, b.size());
          b.put("hi", 1);
          assertEquals(1, b.size());
          for (int i = 0; i < 455; i++) {
              b.put("hi" + i, 1);
          }
          assertEquals(456, b.size());
      }

      //assumes get/containskey work
      @Test
      public void sanityPutTest() {
          MyHashMap<String, Integer> b = new MyHashMap<String, Integer>();
          b.put("hi", 1);
          assertTrue(b.containsKey("hi") && b.get("hi") != null);
      }

      /* 
      ,* Sanity test for keySet
      ,*/
      @Test
      public void sanityKeySetTest() {
          MyHashMap<String, Integer> b = new MyHashMap<String, Integer>();
          HashSet<String> values = new HashSet<String>();
          for (int i = 0; i < 455; i++) {
              b.put("hi" + i, 1);   
              values.add("hi" + i);
          }
          assertEquals(455, b.size()); //keys are there
          Set<String> keySet = b.keySet();
          assertTrue(values.containsAll(keySet));
          assertTrue(keySet.containsAll(values));
      }

      /*
       ,* Test for general functionality and that the properties of Maps hold.
       ,*/
      @Test
      public void functionalityTest() {
          MyHashMap<String, String> dictionary = new MyHashMap<>();
          assertEquals(0, dictionary.size());

          // can put objects in dictionary and get them
          dictionary.put("hello", "world");
          assertTrue(dictionary.containsKey("hello"));
          assertEquals("world", dictionary.get("hello"));
          assertEquals(1, dictionary.size());

          // putting with existing key updates the value
          dictionary.put("hello", "kevin");
          assertEquals(1, dictionary.size());
          assertEquals("kevin", dictionary.get("hello"));

          // putting key in multiple times does not affect behavior
          MyHashMap<String, Integer> studentIDs = new MyHashMap<String, Integer>();
          studentIDs.put("sarah", 12345);
          assertEquals(1, studentIDs.size());
          assertEquals(12345, studentIDs.get("sarah").intValue());
          studentIDs.put("alan", 345);
          assertEquals(2, studentIDs.size());
          assertEquals(12345, studentIDs.get("sarah").intValue());
          assertEquals(345, studentIDs.get("alan").intValue());
          studentIDs.put("alan", 345);
          assertEquals(2, studentIDs.size());
          assertEquals(12345, studentIDs.get("sarah").intValue());
          assertEquals(345, studentIDs.get("alan").intValue());
          studentIDs.put("alan", 345);
          assertEquals(2, studentIDs.size());
          assertEquals(12345, studentIDs.get("sarah").intValue());
          assertEquals(345, studentIDs.get("alan").intValue());
          assertTrue(studentIDs.containsKey("sarah"));
          assertTrue(studentIDs.containsKey("alan"));

          // handle values being the same
          assertEquals(345, studentIDs.get("alan").intValue());
          studentIDs.put("evil alan", 345);
          assertEquals(345, studentIDs.get("evil alan").intValue());
          assertEquals(studentIDs.get("evil alan"), studentIDs.get("alan"));
      }
    #+end_src 

*** ~TestMyHashMapExtra~                                              :TOBEORG:
    #+begin_src java :classname 
      @Test
      public void testRemove() {
          MyHashMap<String, String> q = new MyHashMap<String, String>();
          q.put("c", "a");
          q.put("b", "a");
          q.put("a", "a");
          q.put("d", "a");
          q.put("e", "a"); // a b c d e
          assertTrue(null != q.remove("c"));
          assertFalse(q.containsKey("c"));
          assertTrue(q.containsKey("a"));     
          assertTrue(q.containsKey("b"));
          assertTrue(q.containsKey("d"));
          assertTrue(q.containsKey("e"));
      }

      /* Remove Test 2 
       ,* test the 3 different cases of remove
       ,*/
      @Test
      public void testRemoveThreeCases() {
          MyHashMap<String, String> q = new MyHashMap<String, String>();
          q.put("c", "a");
          q.put("b", "a");
          q.put("a", "a");
          q.put("d", "a");
          q.put("e", "a");                         // a b c d e
          assertTrue(null != q.remove("e"));      // a b c d
          assertTrue(q.containsKey("a"));     
          assertTrue(q.containsKey("b"));
          assertTrue(q.containsKey("c"));
          assertTrue(q.containsKey("d"));
          assertTrue(null != q.remove("c"));      // a b d
          assertTrue(q.containsKey("a"));     
          assertTrue(q.containsKey("b"));
          assertTrue(q.containsKey("d"));
          q.put("f", "a");                         // a b d f
          assertTrue(null != q.remove("d"));      // a b f
          assertTrue(q.containsKey("a"));     
          assertTrue(q.containsKey("b"));
          assertTrue(q.containsKey("f"));
      }
    #+end_src 
** Challenge Heaps and Hashes                              :UNRESOLVED:EXTRA:
* Lab 9 Tries
** ~MyTrieSet~
*** ~class Node~  
    #+begin_src java :classname 
      public class MyTrieSet implements TrieSet61B{
          private Node root;

          private static class Node {
              private boolean isKey;
              //        private HashMap<Character, Node> map;
              private TreeMap<Character, Node> map;
              Node(boolean b) {
                  isKey = b;
                  //            map = new HashMap<>();
                  map = new TreeMap<>();
              }

              Set<Character> keySet() {
                  return map.keySet();
              }

              Node getNode(Character c) {
                  return map.get(c);
              }

              boolean containsKey(Character c) {
                  return map.containsKey(c);
              }

              void clear() {
                  map.clear();
              }

              void add(Character c, Node n) {
                  map.put(c, n);
              }
          }
          ...
      }
    #+end_src 
    - ~HashMap<Character, Node> map~ or ~HashMap<Character, Node> map~
    - ~map.keySet()~, ~map.get(c)~, ~map.containsKey(c)~, ~map.clear()~ and ~map.put(c, n)~
**** Question:                                                    :QUESTIONS:
     - [ ] 尝试用自己实现的 ~BSTMap~ 和 ~MyHashMap~ 当底层结构试试
*** ~contains~ 
    #+begin_src java :classname 
      @Override
      public boolean contains(String key) {
          if (key == null) return false;
          Node n = root;
          for (int i = 0, l = key.length(); i < l; i++) {
              char c = key.charAt(i);
              if (n.containsKey(c)) {
                  n = n.getNode(c);
                  continue;
              }
              return false;
          }
          return true;
      }
    #+end_src 
    - ~Node n = root~
    - ~for (int i = 0, l = key.length(); i < l; i++)~
    - ~key.charAt(i)~
    - ~n = n.getNode(c)~ and ~continue~ 
*** ~add~ 
    #+begin_src java :classname 
      @Override
      public void add(String key) {
          if (key == null || key.length() < 1) {
              return;
          }
          Node curr = root;
          for (int i = 0, n = key.length(); i < n; i++) {
              char c = key.charAt(i);
              if (!curr.containsKey(c)) {
                  curr.add(c, new Node(false));
              }
              curr = curr.getNode(c);
          }
          curr.isKey = true;
      }
    #+end_src 
    - ~curr.add(c, new Node(false))~
    - ~curr.isKey = true~ 
*** ~keysWithPrefix~ 
    #+begin_src java :classname 
      @Override
      public List<String> keysWithPrefix(String prefix) {
          List<String> keys = new LinkedList<>();
          if (!contains(prefix)) return null;
          Node n = root;
          for (int i = 0, l = prefix.length(); i < l; i++) {
              char c = prefix.charAt(i);
              n = n.getNode(c);
          }
          colHelp(prefix, keys, n);
          return keys;
      }

      private void colHelp(String s, List<String> x, Node n) {
          if (n.isKey) x.add(s);
          for (char c : n.keySet()) {
              colHelp(s + c, x, n.getNode(c));
          }
      }
    #+end_src 
    - ~colHelp(String s, List<String> x, Node n)~
      - ~char c : n.keySet()~
      - Recursive: ~colHelp(s + c, x, n.getNode(c))~ 
    - ~colHelp(prefix, keys, n)~ 
*** ~collect~ 
    #+begin_src java :classname 
      public List<String> collect() {
          List<String> s = new LinkedList<>();
          for (char c : root.keySet()) {
              colHelp(String.valueOf(c), s, root.getNode(c));
          }
          return s;
      }
    #+end_src 
    - ~char~ to ~String~: ~String.valueOf(c)~ 
*** ~longestPrefixOf~                                      :UNRESOLVED:EXTRA:
*** Question:                                                     :QUESTIONS:
    - [ ] 如果有删除操作 ~remove~, 该是什么逻辑以及实现？
** Tests
*** TestMyTrieSet                                                   :TOBEORG:
    #+begin_src java :classname 
      @Test
      public void sanityClearTest() {
          MyTrieSet t = new MyTrieSet();
          for (int i = 0; i < 455; i++) {
              t.add("hi" + i);
              //make sure put is working via contains
              assertTrue(t.contains("hi" + i));
          }
          t.clear();
          for (int i = 0; i < 455; i++) {
              assertFalse(t.contains("hi" + i));
          }
      }

      // assumes add works
      @Test
      public void sanityContainsTest() {
          MyTrieSet t = new MyTrieSet();
          assertFalse(t.contains("waterYouDoingHere"));
          t.add("waterYouDoingHere");
          assertTrue(t.contains("waterYouDoingHere"));
      }

      // assumes add works
      @Test
      public void sanityPrefixTest() {
          String[] saStrings = new String[]{"same", "sam", "sad", "sap"};
          String[] otherStrings = new String[]{"a", "awls", "hello"};

          MyTrieSet t = new MyTrieSet();
          for (String s: saStrings) {
              t.add(s);
          }
          for (String s: otherStrings) {
              t.add(s);
          }

          List<String> keys = t.keysWithPrefix("sa");
          for (String s: saStrings) {
              assertTrue(keys.contains(s));
          }
          for (String s: otherStrings) {
              assertFalse(keys.contains(s));
          }
      }
    #+end_src 

** Challenge Graphs                                        :UNRESOLVED:EXTRA:
