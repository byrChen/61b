#+TAGS: UNRESOLVED(u) QUESTIONS(q) TOBEORG(t)
* Lab 1 javac, java, git
** Using Git
*** B. Local Repositories (Narrative Introduction)
   - ~git init~: Creates a box in which to permanently store panoramic pictures.
   - ~git add~: Takes a temporary photo of one thing that can be assembled into a panoramic photo later.
   - ~git commit~: Assembles all available temporary photos into a panoramic photo. Also destroys all temporary photos.
   - ~git log~: Lists all the panoramic photos we’ve ever taken.
   - ~git show~: Looks at what is in a particular panoramic photo.
   - ~git chechout~: Rearranges files back to how they looked in a given panoramic photo. Does not affect the panormiac photos in your box in any way.
*** C. Local Repositories (Technical Overview)
**** Initializing Local Repositories
     ~git init~: Git creates a .git subdirectory. Inside this directory it will store a bunch of metadata, as well as old the actual snapshots of the files. 
**** Tracked vs. Untracked Files
     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-08 15:59:57
     [[file:pictures/lab01/screenshot_2019-03-08_15-59-57.png]]
     TWo main categories: *untracked files* and *tracked files*.
     ~git status~: Determining the exact status(untracked, unmodified, modified staged) of each file in your repository.
**** Staging & Committing
     - ~git add FILE~: Stage a file.
     - ~git commit -m MESSAGE~: Commit snapshot as one block with a message.
     - ~git log~: See previous commits
**** Undoing Changes
     - ~git reset HEAD [file]~: Unstage a file that you haven’t yet committed, this will take the file’s status back to modified, leaving changes intact, equivalent of deleting one of the temporary images that you’re going to combine into a panorama.
     - ~git add [forgotten-file]~ + ~git commit --amend~: Amend latest commit (changing commit message or add forgotten files).
     - ~git checkout -- [file]~: Revert a file to its state at the time of the most recent commit.
     - ~git chechout commitnumber repository/file~: Revert a file to a specific commit.
*** D. Remote Repositories
    - ~git clone [remote-repo-URL]~: Makes a copy of the specified repository, but on your local computer. Also creates a working directory that has files arranged exactly like the most recent snapshot in the download repository. Also records the URL of the remote repository for subsequent network data transfers, and gives it the special remote-repo-name “origin”.
    - ~git remote add [remote-repo-name]~: Records a new location for network data transfers.
    - ~git remote -v~: Lists all locations for network data transfers.
    - ~git pull [remote-repo-name] master~: Get the most recent copy of the files as seen in remote-repo-name
    - ~git push [remote-repo-name] master~: Pushes the most recent copy of your files to the remote-repo-name.

** C. Git Exercise

   #+begin_src sh 
     touch lab1-checkoff
     cd lab1-checkoff/
     nano 61b.txt
     nano 61c.txt
     git add 61b.txt
     git commit -m "Add61b.txt"
     nano 61b.txt
     git add 61b.txt 61c.txt
     git commit -m "Update 61b.txt and add 61c.txt"
     nano 61b.txt
     git checkout -- 61b.txt
     git checkout 39e3c4ec06c95d57fda6e8d18e32cdcb05a9bb6e ./61b.txt
   #+end_src 

** F. Leap Year
*** Style
    #+begin_example
      Running style check on 2 files...
      LeapYear.java:37:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
      LeapYear.java:38:14: Conditional logic can be removed. [SimplifyBooleanReturn]
      LeapYear.java:40:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
      HelloNumbers.java:0: File does not end with a newline. [NewlineAtEndOfFile]
    #+end_example
     
    #+begin_src java :classname 
      // before
      if (year % 400 == 0) {
          return true;
      } else {
          return (year % 4 == 0 && year % 100 != 0);
      }
      // after
      if (year % 400 == 0) {
          return true;
      } else return (year % 4 == 0 && year % 100 != 0);

    #+end_src 
* Lab 2 Unit Testing with JUnit and IntLists 
** Application: IntLists
   #+begin_src java :classname 
     /**
      ,* Returns a list equal to L with all elements squared. Destructive.
      ,*/
     public static void dSquareList(IntList L) {

         while (L != null) {
             L.first = L.first * L.first;
             L = L.rest;
         }
     }

     /**
      ,* Returns a list equal to L with all elements squared. Non-destructive.
      ,*/
     public static IntList squareListIterative(IntList L) {
         if (L == null) {
             return null;
         }
         IntList res = new IntList(L.first * L.first, null);
         IntList ptr = res;
         L = L.rest;
         while (L != null) {
             ptr.rest = new IntList(L.first * L.first, null);
             L = L.rest;
             ptr = ptr.rest;
         }
         return res;
     }

     /**
      ,* Returns a list equal to L with all elements squared. Non-destructive.
      ,*/
     public static IntList squareListRecursive(IntList L) {
         if (L == null) {
             return null;
         }
         return new IntList(L.first * L.first, squareListRecursive(L.rest));
     }

     /** DO NOT MODIFY ANYTHING ABOVE THIS LINE! */


     /**
      ,* Returns a list consisting of the elements of A followed by the
      ,* *  elements of B.  May modify items of A. Don't use 'new'.
      ,*/

     public static IntList dcatenateIterative(IntList A, IntList B) {
         //TODO:  fill in method
         if (A == null){
             return B;
         }
         else {
             IntList C = A;
             while (C.rest != null){
                 C = C.rest;
             }
             C.rest = B;
             return A;
         }

     }

     public static IntList dcatenateRecursive(IntList A, IntList B) {
         //TODO:  fill in method
         if (A == null){
             return B;
         }
         else {
             IntList C = dcatenateIterative(A.rest, B);
             A.rest = C;
             return A;
         }
     }

     /**
      ,* Returns a list consisting of the elements of A followed by the
      ,* * elements of B.  May NOT modify items of A.  Use 'new'.
      ,*/
     public static IntList catenateIterative(IntList A, IntList B) {
         //TODO:  fill in method
          if (A == null){
             return B;
          }
          else {
              IntList C = new IntList(A.first, null);
              IntList D = C;
              while (A.rest != null) {
                  D.rest = new IntList(A.rest.first, null);
                  D = D.rest;
                  A = A.rest;
              }
              D.rest = B;
              return C;
          }
     }


     /**
      ,* Returns a list consisting of the elements of A followed by the
      ,* * elements of B.  May NOT modify items of A.  Use 'new'.
      ,*/
     public static IntList catenateRecursive(IntList A, IntList B) {
         //TODO:  fill in method
          if (A == null){
             return B;
          }
          else {
              IntList C = new IntList(A.first, catenateIterative(A.rest, B));
              return C;
          }
     }
   #+end_src 
   - Destructive: no ~new IntList~ 
     - Iterative: ~IntList B = A~ and ~while (B...) {}~
     - Recursive: ~IntList B = recursivefunc(A...)~ 
   - Non-destructive: use ~new IntList~ 
     - Iterative: ~IntList B = new IntList()~ and ~IntList C = B~
     - Recursive: ~IntList B = new IntList(recursivefunc(A...)...)~ 
* Lab 3 Unit Testing with JUnit, Debugging
** Writing a Reverse Method
   #+begin_src java :classname 
     public static IntList dreverse(IntList A) {
         IntList reverseList, B;
         for (reverseList = null; A != null; A = B) {
             B = A.rest;
             A.rest = reverseList;
             reverseList = A;
         }
         return  reverseList;
     }

     public static IntList reverse(IntList A) {
         IntList reverseList;
         for (reverseList = null; A != null; A = A.rest) {
             reverseList = new IntList(A.first, reverseList);
         }
         return reverseList;
         }
   #+end_src 
   #+begin_src java :classname 
     @Test
     public void testdReverse() {
         IntList A = IntList.of(1,2,3);
         IntList nullList = null;
         assertEquals(IntList.of(3,2,1), IntList.dreverse(A));
         IntList.dreverse(A);
         assertNotEquals(IntList.of(1, 2, 3), A);
         assertEquals(nullList, IntList.reverse(nullList));
     }

     @Test
     public void testReverse() {
         IntList A = IntList.of(1,2,3);
         IntList nullList = null;
         assertEquals(IntList.of(3,2,1), IntList.reverse(A));
         IntList.reverse(A);
         assertEquals(IntList.of(1, 2, 3), A);
         assertEquals(nullList, IntList.reverse(nullList));
     }
   #+end_src 
   - ~testdReverse~ for ~dreverse~ and ~testReverse~ for ~reverse~
   - ~assertEquals~ and ~assertNotEquals~
   - ~import static org.junit.Assert.*;~ and ~import org.junit.Test;~
*** Question:                                                     :QUESTIONS:
    1. ~dreverse~ 和 ~reverse~ 理解，特别是 ~dreverse~ 的思路？
    2. ~A~ 作为实参传递到函数后，为何 ~A = A.rest~ 不是 destructive 而 ~A.rest = ...~ 往往是 destructive ？传 ~A~ 并不是引用传递而仍然是值传递？所以返回后 ~A~ 中存储的地址不会变， ~A~ 指向的 reference type object 也不会变？ 
    3. Java 里实参到形参的引用传递（地址传递）和值传递？
** Flik int vs Integer as formal paras
   #+begin_src java :classname 
     public class Flik {
         public static boolean isSameNumber(int a, int b) {
             return a == b;
         }
     }
   #+end_src 
   - ~int~ is a *primitive* data type while ~Integer~ is a ~Wrapper~ class
* Lab 5 Huglife
** Plip
*** Basic Plip functionality
    #+begin_src java :classname 
      public void move() {
          // TODO
          energy -= 0.15;
          if (energy <= 0) {
              energy = 0;
              return;
          }
      }


      /**
       ,* Plips gain 0.2 energy when staying due to photosynthesis.
       ,*/
      public void stay() {
          // TODO
          energy += 0.2;
          if (energy >= 2) {
              energy = 2;
              return;
          }
      }
    #+end_src 
    - ~if~ in the end 
*** chooseAction method
    #+begin_src java :classname 
      public Action chooseAction(Map<Direction, Occupant> neighbors) {
          // Rule 1
          Deque<Direction> emptyNeighbors = new ArrayDeque<>();
          boolean anyClorus = false;
          // TODO
          // (Google: Enhanced for-loop over keys of NEIGHBORS?)
          // for () {...}
          for (Map.Entry<Direction, Occupant> entry : neighbors.entrySet()) {
              if (entry.getValue().name().equals("empty")) {
                  emptyNeighbors.add(entry.getKey());
              }
              if (entry.getValue().equals("clorus")) {
                  anyClorus = true;
              }
          }

          if (emptyNeighbors.isEmpty()) {
              // TODO
              return new Action(Action.ActionType.STAY);
          }

          if (energy >= 1) {
              int indexToMove = StdRandom.uniform(0, emptyNeighbors.size());
              Direction dir = (Direction) emptyNeighbors.toArray()[indexToMove];
              return new Action(Action.ActionType.REPLICATE, dir);
          }

          if (anyClorus && StdRandom.uniform(2) == 0) {
              int indexToMove = StdRandom.uniform(0, emptyNeighbors.size());
              Direction dir = (Direction) emptyNeighbors.toArray()[indexToMove];
              return new Action(Action.ActionType.MOVE, dir);
          }

          return new Action(Action.ActionType.STAY);
      }
    #+end_src
    - Create an ~ArrayDeque~ object: ~Deque<Direction> emptyNeighbors = new ArrayDeque<>()~
    - Iterate on ~Map~: ~for (Map.Entry<Direction, Occupant> entry : neighbors.entrySet())~, ~entry.getValue()~ and ~entry.getKey()~
    - Return a random entry in ~ArrayDeque~: ~StdRandom.uniform(0, emptyNeighbors.size())~ and ~(Direction) emptyNeighbors.toArray()[indexToMove]~
    - Compare ~Object~ objects: ~obj1.equals(obj2)~
    - 50% possibility to move: ~if (anyClorus && StdRandom.uniform(2) == 0)~ 
** Clorus
*** chooseAction method 
    #+begin_src java :classname 
      public Action chooseAction(Map<Direction, Occupant> neighbors) {
          Deque<Direction> emptyNeighbors = new ArrayDeque<>();
          Deque<Direction> plipNeighbors = new ArrayDeque<>();

          for (Map.Entry<Direction, Occupant> entry : neighbors.entrySet()) {

              if (entry.getValue().name().equals("empty")) {
                  emptyNeighbors.add(entry.getKey());
              }

              if (entry.getValue().name().equals("plip")) {
                  plipNeighbors.add(entry.getKey());
              }
          }

          if (emptyNeighbors.isEmpty()) {
              return new Action(Action.ActionType.STAY);
          }

          if (!plipNeighbors.isEmpty()) {
              int index = StdRandom.uniform(0, plipNeighbors.size());
              Direction dir = (Direction) plipNeighbors.toArray()[index];
              return new Action(Action.ActionType.ATTACK, dir);
          } else {
              int index = StdRandom.uniform(0, emptyNeighbors.size());
              Direction dir = (Direction) emptyNeighbors.toArray()[index];
              if (energy >= 1) {
                  return new Action(Action.ActionType.REPLICATE, dir);
              }
              return new Action(Action.ActionType.MOVE, dir);
          }
      }
    #+end_src 
    - Store ~Plip~ objects' directions: ~Deque<Direction> plipNeighbors = new ArrayDeque<>()~
* Lab 6 Disjoint Sets
** Weighted Quick Union with Path Compression 
*** union
    #+begin_src java :classname 
      public void union(int v1, int v2) {
          // TODO
          validate(v1);
          validate(v2);
          if (!connected(v1, v2)) {
              if (sizeOf(v1) <= sizeOf(v2)) {
                  vertice[find(v2)] += vertice[find(v1)];
                  vertice[find(v1)] = find(v2);
              } else {
                  vertice[find(v1)] += vertice[find(v2)];
                  vertice[find(v2)] = find(v1);
              }
          }
      }
    #+end_src 
    - ~validate~ --> ~connected~ --> connect
    - ~vertice[find(v2)] += vertice[find(v1)];~ and ~vertice[find(v1)] = find(v2);~ 
*** find and parent
    #+begin_src java :classname 
      public int find(int vertex) {
          // TODO
          return vertice[vertex] < 0 ? vertex : find(parent(vertex));
      }

      public int parent(int v1) {
          // TODO
          return vertice[v1] < 0 ? v1 : vertice[v1];
      }
    #+end_src 
    - ~expression1 ? expression2 : expression3~ 
*** conneted
    #+begin_src java :classname 
      public boolean connected(int v1, int v2) {
          // TODO
          int r1 = find(v1);
          int r2 = find(v2);
          int p1 = parent(v1);
          int p2 = parent(v2);
    
          while (p1 != r1) {
              vertice[v1] = r1;
              v1 = p1;
              p1 = parent(v1);
          }
          while (p2 != r2) {
              vertice[v2] = r2;
              v2 = p2;
              p2 = parent(v2);
          }
    
          return r1 == r2;
      }
    #+end_src 
    - ~vertice[v1] = r1;~, ~v1 = p1~ and ~p1 = parent(v1)~ 

** Tests
*** TestUnionFind
    #+begin_src java :classname 
      @Test
      public void testConstructor() {
          UnionFind actual = new UnionFind(5);
          int[] expect = new int[5];
          Arrays.fill(expect, -1);
          assertArrayEquals(expect, actual.getSet());
      }

      @Test
      public void testUnion() {
          UnionFind actual = new UnionFind(5);
          actual.union(1, 0);
          int[] expect1 = {-2, 0, -1, -1, -1};
          assertArrayEquals(expect1, actual.getSet());
          actual.union(3, 2);
          int[] expect2 = {-2, 0, -2, 2, -1};
          assertArrayEquals(expect2, actual.getSet());
          actual.union(4, 3);
          int[] expect3 = {-2, 0, -3, 2, 2};
          assertArrayEquals(expect3, actual.getSet());
          actual.union(0, 3);
          int[] expect4 = {2, 0, -5, 2, 2};
          assertArrayEquals(expect4, actual.getSet());
          actual.union(0, 0);
          actual.union(1, 1);
          assertArrayEquals(expect4, actual.getSet());
          actual.union(1, 3);
          int[] expect5 = {2, 0, -5, 2, 2};
          assertArrayEquals(expect5, actual.getSet());
      }

      @Test
      public void testUnionPC() {
          UnionFind actual = new UnionFind(5);
          actual.union(1, 0);
          actual.union(3, 2);
          actual.union(4, 3);
          actual.union(0, 3);
          actual.union(0, 0);
          actual.union(1, 1);
          actual.union(1, 3);
          int[] expect5 = {2, 2, -5, 2, 2};
          assertArrayEquals(expect5, actual.getSet());
      }
    #+end_src 
    - ~int[] expect = new int[5]~ and ~Arrays.fill(expect, -1)~, not ~int expect[]~ but ~int[] expect~ 
** Challenge Lab 6 Falling Bubbles                               :UNRESOLVED:
* Lab 7 TreeMap
