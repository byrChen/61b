#+TAGS: UNRESOLVED(u) QUESTIONS(q) TOBEORG(t)
* Lab 1 javac, java, git
** Using Git
*** B. Local Repositories (Narrative Introduction)
   - ~git init~: Creates a box in which to permanently store panoramic pictures.
   - ~git add~: Takes a temporary photo of one thing that can be assembled into a panoramic photo later.
   - ~git commit~: Assembles all available temporary photos into a panoramic photo. Also destroys all temporary photos.
   - ~git log~: Lists all the panoramic photos we’ve ever taken.
   - ~git show~: Looks at what is in a particular panoramic photo.
   - ~git chechout~: Rearranges files back to how they looked in a given panoramic photo. Does not affect the panormiac photos in your box in any way.
*** C. Local Repositories (Technical Overview)
**** Initializing Local Repositories
     ~git init~: Git creates a .git subdirectory. Inside this directory it will store a bunch of metadata, as well as old the actual snapshots of the files. 
**** Tracked vs. Untracked Files
     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-08 15:59:57
     [[file:pictures/lab01/screenshot_2019-03-08_15-59-57.png]]
     TWo main categories: *untracked files* and *tracked files*.
     ~git status~: Determining the exact status(untracked, unmodified, modified staged) of each file in your repository.
**** Staging & Committing
     - ~git add FILE~: Stage a file.
     - ~git commit -m MESSAGE~: Commit snapshot as one block with a message.
     - ~git log~: See previous commits
**** Undoing Changes
     - ~git reset HEAD [file]~: Unstage a file that you haven’t yet committed, this will take the file’s status back to modified, leaving changes intact, equivalent of deleting one of the temporary images that you’re going to combine into a panorama.
     - ~git add [forgotten-file]~ + ~git commit --amend~: Amend latest commit (changing commit message or add forgotten files).
     - ~git checkout -- [file]~: Revert a file to its state at the time of the most recent commit.
     - ~git chechout commitnumber repository/file~: Revert a file to a specific commit.
*** D. Remote Repositories
    - ~git clone [remote-repo-URL]~: Makes a copy of the specified repository, but on your local computer. Also creates a working directory that has files arranged exactly like the most recent snapshot in the download repository. Also records the URL of the remote repository for subsequent network data transfers, and gives it the special remote-repo-name “origin”.
    - ~git remote add [remote-repo-name]~: Records a new location for network data transfers.
    - ~git remote -v~: Lists all locations for network data transfers.
    - ~git pull [remote-repo-name] master~: Get the most recent copy of the files as seen in remote-repo-name
    - ~git push [remote-repo-name] master~: Pushes the most recent copy of your files to the remote-repo-name.

** C. Git Exercise

   #+begin_src sh 
     touch lab1-checkoff
     cd lab1-checkoff/
     nano 61b.txt
     nano 61c.txt
     git add 61b.txt
     git commit -m "Add61b.txt"
     nano 61b.txt
     git add 61b.txt 61c.txt
     git commit -m "Update 61b.txt and add 61c.txt"
     nano 61b.txt
     git checkout -- 61b.txt
     git checkout 39e3c4ec06c95d57fda6e8d18e32cdcb05a9bb6e ./61b.txt
   #+end_src 

** F. Leap Year
*** Style
    #+begin_example
      Running style check on 2 files...
      LeapYear.java:37:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
      LeapYear.java:38:14: Conditional logic can be removed. [SimplifyBooleanReturn]
      LeapYear.java:40:9: '}' at column 9 should be on the same line as the next part of a multi-block statement (one that directly contains multiple blocks: if/else-if/else, do/while or try/catch/finally). [RightCurly]
      HelloNumbers.java:0: File does not end with a newline. [NewlineAtEndOfFile]
    #+end_example
     
    #+begin_src java :classname 
      // before
      if (year % 400 == 0) {
          return true;
      } else {
          return (year % 4 == 0 && year % 100 != 0);
      }
      // after
      if (year % 400 == 0) {
          return true;
      } else return (year % 4 == 0 && year % 100 != 0);

    #+end_src 
* Lab 2 Unit Testing with JUnit and IntLists 
** Application: IntLists
   #+begin_src java :classname 
     /**
      ,* Returns a list equal to L with all elements squared. Destructive.
      ,*/
     public static void dSquareList(IntList L) {

         while (L != null) {
             L.first = L.first * L.first;
             L = L.rest;
         }
     }

     /**
      ,* Returns a list equal to L with all elements squared. Non-destructive.
      ,*/
     public static IntList squareListIterative(IntList L) {
         if (L == null) {
             return null;
         }
         IntList res = new IntList(L.first * L.first, null);
         IntList ptr = res;
         L = L.rest;
         while (L != null) {
             ptr.rest = new IntList(L.first * L.first, null);
             L = L.rest;
             ptr = ptr.rest;
         }
         return res;
     }

     /**
      ,* Returns a list equal to L with all elements squared. Non-destructive.
      ,*/
     public static IntList squareListRecursive(IntList L) {
         if (L == null) {
             return null;
         }
         return new IntList(L.first * L.first, squareListRecursive(L.rest));
     }

     /** DO NOT MODIFY ANYTHING ABOVE THIS LINE! */


     /**
      ,* Returns a list consisting of the elements of A followed by the
      ,* *  elements of B.  May modify items of A. Don't use 'new'.
      ,*/

     public static IntList dcatenateIterative(IntList A, IntList B) {
         //TODO:  fill in method
         if (A == null){
             return B;
         }
         else {
             IntList C = A;
             while (C.rest != null){
                 C = C.rest;
             }
             C.rest = B;
             return A;
         }

     }

     public static IntList dcatenateRecursive(IntList A, IntList B) {
         //TODO:  fill in method
         if (A == null){
             return B;
         }
         else {
             IntList C = dcatenateIterative(A.rest, B);
             A.rest = C;
             return A;
         }
     }

     /**
      ,* Returns a list consisting of the elements of A followed by the
      ,* * elements of B.  May NOT modify items of A.  Use 'new'.
      ,*/
     public static IntList catenateIterative(IntList A, IntList B) {
         //TODO:  fill in method
          if (A == null){
             return B;
          }
          else {
              IntList C = new IntList(A.first, null);
              IntList D = C;
              while (A.rest != null) {
                  D.rest = new IntList(A.rest.first, null);
                  D = D.rest;
                  A = A.rest;
              }
              D.rest = B;
              return C;
          }
     }


     /**
      ,* Returns a list consisting of the elements of A followed by the
      ,* * elements of B.  May NOT modify items of A.  Use 'new'.
      ,*/
     public static IntList catenateRecursive(IntList A, IntList B) {
         //TODO:  fill in method
          if (A == null){
             return B;
          }
          else {
              IntList C = new IntList(A.first, catenateIterative(A.rest, B));
              return C;
          }
     }
   #+end_src 
   - Destructive: no ~new IntList~ 
     - Iterative: ~IntList B = A~ and ~while (B...) {}~
     - Recursive: ~IntList B = recursivefunc(A...)~ 
   - Non-destructive: use ~new IntList~ 
     - Iterative: ~IntList B = new IntList()~ and ~IntList C = B~
     - Recursive: ~IntList B = new IntList(recursivefunc(A...)...)~ 
* Lab 3 Unit Testing with JUnit, Debugging
** Writing a Reverse Method
   #+begin_src java :classname 
     public static IntList dreverse(IntList A) {
         IntList reverseList, B;
         for (reverseList = null; A != null; A = B) {
             B = A.rest;
             A.rest = reverseList;
             reverseList = A;
         }
         return  reverseList;
     }

     public static IntList reverse(IntList A) {
         IntList reverseList;
         for (reverseList = null; A != null; A = A.rest) {
             reverseList = new IntList(A.first, reverseList);
         }
         return reverseList;
         }
   #+end_src 
   #+begin_src java :classname 
     @Test
     public void testdReverse() {
         IntList A = IntList.of(1,2,3);
         IntList nullList = null;
         assertEquals(IntList.of(3,2,1), IntList.dreverse(A));
         IntList.dreverse(A);
         assertNotEquals(IntList.of(1, 2, 3), A);
         assertEquals(nullList, IntList.reverse(nullList));
     }

     @Test
     public void testReverse() {
         IntList A = IntList.of(1,2,3);
         IntList nullList = null;
         assertEquals(IntList.of(3,2,1), IntList.reverse(A));
         IntList.reverse(A);
         assertEquals(IntList.of(1, 2, 3), A);
         assertEquals(nullList, IntList.reverse(nullList));
     }
   #+end_src 
   - ~testdReverse~ for ~dreverse~ and ~testReverse~ for ~reverse~
   - ~assertEquals~ and ~assertNotEquals~
   - ~import static org.junit.Assert.*;~ and ~import org.junit.Test;~
*** Question:                                                     :QUESTIONS:
    1. ~dreverse~ 和 ~reverse~ 理解，特别是 ~dreverse~ 的思路？
    2. ~A~ 作为实参传递到函数后，为何 ~A = A.rest~ 不是 destructive 而 ~A.rest = ...~ 往往是 destructive ？传 ~A~ 并不是引用传递而仍然是值传递？所以返回后 ~A~ 中存储的地址不会变， ~A~ 指向的 reference type object 也不会变？ 
    3. Java 里实参到形参的引用传递（地址传递）和值传递？
** Flik int vs Integer as formal paras
   #+begin_src java :classname 
     public class Flik {
         public static boolean isSameNumber(int a, int b) {
             return a == b;
         }
     }
   #+end_src 
   - ~int~ is a *primitive* data type while ~Integer~ is a ~Wrapper~ class
* Lab 5 Huglife
** Plip
*** Basic Plip functionality
    #+begin_src java :classname 
      public void move() {
          // TODO
          energy -= 0.15;
          if (energy <= 0) {
              energy = 0;
              return;
          }
      }


      /**
       ,* Plips gain 0.2 energy when staying due to photosynthesis.
       ,*/
      public void stay() {
          // TODO
          energy += 0.2;
          if (energy >= 2) {
              energy = 2;
              return;
          }
      }
    #+end_src 
    - ~if~ in the end 
*** chooseAction method
    #+begin_src java :classname 
      public Action chooseAction(Map<Direction, Occupant> neighbors) {
          // Rule 1
          Deque<Direction> emptyNeighbors = new ArrayDeque<>();
          boolean anyClorus = false;
          // TODO
          // (Google: Enhanced for-loop over keys of NEIGHBORS?)
          // for () {...}
          for (Map.Entry<Direction, Occupant> entry : neighbors.entrySet()) {
              if (entry.getValue().name().equals("empty")) {
                  emptyNeighbors.add(entry.getKey());
              }
              if (entry.getValue().equals("clorus")) {
                  anyClorus = true;
              }
          }

          if (emptyNeighbors.isEmpty()) {
              // TODO
              return new Action(Action.ActionType.STAY);
          }

          if (energy >= 1) {
              int indexToMove = StdRandom.uniform(0, emptyNeighbors.size());
              Direction dir = (Direction) emptyNeighbors.toArray()[indexToMove];
              return new Action(Action.ActionType.REPLICATE, dir);
          }

          if (anyClorus && StdRandom.uniform(2) == 0) {
              int indexToMove = StdRandom.uniform(0, emptyNeighbors.size());
              Direction dir = (Direction) emptyNeighbors.toArray()[indexToMove];
              return new Action(Action.ActionType.MOVE, dir);
          }

          return new Action(Action.ActionType.STAY);
      }
    #+end_src
    - Create an ~ArrayDeque~ object: ~Deque<Direction> emptyNeighbors = new ArrayDeque<>()~
    - Iterate on ~Map~: ~for (Map.Entry<Direction, Occupant> entry : neighbors.entrySet())~, ~entry.getValue()~ and ~entry.getKey()~
    - Return a random entry in ~ArrayDeque~: ~StdRandom.uniform(0, emptyNeighbors.size())~ and ~(Direction) emptyNeighbors.toArray()[indexToMove]~
    - Compare ~Object~ objects: ~obj1.equals(obj2)~
    - 50% possibility to move: ~if (anyClorus && StdRandom.uniform(2) == 0)~ 
** Clorus
*** chooseAction method 
    #+begin_src java :classname 
      public Action chooseAction(Map<Direction, Occupant> neighbors) {
          Deque<Direction> emptyNeighbors = new ArrayDeque<>();
          Deque<Direction> plipNeighbors = new ArrayDeque<>();

          for (Map.Entry<Direction, Occupant> entry : neighbors.entrySet()) {

              if (entry.getValue().name().equals("empty")) {
                  emptyNeighbors.add(entry.getKey());
              }

              if (entry.getValue().name().equals("plip")) {
                  plipNeighbors.add(entry.getKey());
              }
          }

          if (emptyNeighbors.isEmpty()) {
              return new Action(Action.ActionType.STAY);
          }

          if (!plipNeighbors.isEmpty()) {
              int index = StdRandom.uniform(0, plipNeighbors.size());
              Direction dir = (Direction) plipNeighbors.toArray()[index];
              return new Action(Action.ActionType.ATTACK, dir);
          } else {
              int index = StdRandom.uniform(0, emptyNeighbors.size());
              Direction dir = (Direction) emptyNeighbors.toArray()[index];
              if (energy >= 1) {
                  return new Action(Action.ActionType.REPLICATE, dir);
              }
              return new Action(Action.ActionType.MOVE, dir);
          }
      }
    #+end_src 
    - Store ~Plip~ objects' directions: ~Deque<Direction> plipNeighbors = new ArrayDeque<>()~
* Lab 6 Disjoint Sets
** Weighted Quick Union with Path Compression 
*** union
    #+begin_src java :classname 
      public void union(int v1, int v2) {
          // TODO
          validate(v1);
          validate(v2);
          if (!connected(v1, v2)) {
              if (sizeOf(v1) <= sizeOf(v2)) {
                  vertice[find(v2)] += vertice[find(v1)];
                  vertice[find(v1)] = find(v2);
              } else {
                  vertice[find(v1)] += vertice[find(v2)];
                  vertice[find(v2)] = find(v1);
              }
          }
      }
    #+end_src 
    - ~validate~ --> ~connected~ --> connect
    - ~vertice[find(v2)] += vertice[find(v1)];~ and ~vertice[find(v1)] = find(v2);~ 
*** find and parent
    #+begin_src java :classname 
      public int find(int vertex) {
          // TODO
          return vertice[vertex] < 0 ? vertex : find(parent(vertex));
      }

      public int parent(int v1) {
          // TODO
          return vertice[v1] < 0 ? v1 : vertice[v1];
      }
    #+end_src 
    - ~expression1 ? expression2 : expression3~ 
*** conneted
    #+begin_src java :classname 
      public boolean connected(int v1, int v2) {
          // TODO
          int r1 = find(v1);
          int r2 = find(v2);
          int p1 = parent(v1);
          int p2 = parent(v2);
    
          while (p1 != r1) {
              vertice[v1] = r1;
              v1 = p1;
              p1 = parent(v1);
          }
          while (p2 != r2) {
              vertice[v2] = r2;
              v2 = p2;
              p2 = parent(v2);
          }
    
          return r1 == r2;
      }
    #+end_src 
    - ~vertice[v1] = r1;~, ~v1 = p1~ and ~p1 = parent(v1)~ 

** Tests
*** TestUnionFind
    #+begin_src java :classname 
      @Test
      public void testConstructor() {
          UnionFind actual = new UnionFind(5);
          int[] expect = new int[5];
          Arrays.fill(expect, -1);
          assertArrayEquals(expect, actual.getSet());
      }

      @Test
      public void testUnion() {
          UnionFind actual = new UnionFind(5);
          actual.union(1, 0);
          int[] expect1 = {-2, 0, -1, -1, -1};
          assertArrayEquals(expect1, actual.getSet());
          actual.union(3, 2);
          int[] expect2 = {-2, 0, -2, 2, -1};
          assertArrayEquals(expect2, actual.getSet());
          actual.union(4, 3);
          int[] expect3 = {-2, 0, -3, 2, 2};
          assertArrayEquals(expect3, actual.getSet());
          actual.union(0, 3);
          int[] expect4 = {2, 0, -5, 2, 2};
          assertArrayEquals(expect4, actual.getSet());
          actual.union(0, 0);
          actual.union(1, 1);
          assertArrayEquals(expect4, actual.getSet());
          actual.union(1, 3);
          int[] expect5 = {2, 0, -5, 2, 2};
          assertArrayEquals(expect5, actual.getSet());
      }

      @Test
      public void testUnionPC() {
          UnionFind actual = new UnionFind(5);
          actual.union(1, 0);
          actual.union(3, 2);
          actual.union(4, 3);
          actual.union(0, 3);
          actual.union(0, 0);
          actual.union(1, 1);
          actual.union(1, 3);
          int[] expect5 = {2, 2, -5, 2, 2};
          assertArrayEquals(expect5, actual.getSet());
      }
    #+end_src 
    - ~int[] expect = new int[5]~ and ~Arrays.fill(expect, -1)~, not ~int expect[]~ but ~int[] expect~ 
** Challenge Lab 6 Falling Bubbles                               :UNRESOLVED:
* Lab 7 TreeMap
** BSTMap.java
*** ~class Node~
    #+begin_src java :classname 
      private class Node {
          private K key;
          private V val;
          private Node left, right;
          private int size;

          public Node(K key, V val, int size) {
              this.key = key;
              this.val = val;
              this.size = size;
          }
      }
    #+end_src 
    - ~private~ 
*** ~clear~ 
    #+begin_src java :classname 
      public void clear() {
          root = null;
      }

      // not below
      public void clear() {
          clear(root);
      }

      public void clear(Node n) {
          n = null;
      }
    #+end_src 
    - ~n = root~ and ~n = nulll~ can not -> ~root = null~ 
*** ~get~
    #+begin_src java :classname 
      public int size() {
          return size(root);
      }

      public V get(Node n, K key) {
          if (key == null) throw new IllegalArgumentException("calls get() with a null key");
          if (n == null) return null;
          int cmp = key.compareTo(n.key);
          if      (cmp < 0) return get(n.left, key);
          else if (cmp > 0) return get(n.right, key);
          else              return n.val;
      }
    #+end_src 
    - ~int cmp = key.compareTo(n.key)~
    - Recursive: ~null~ + ~get(n.left, key)~ and ~get(n.right, key)~ 
*** ~updateSize~
    #+begin_src java :classname 
      private int updateSize(Node n) {
          if (n == null) return 0;
          n.size = 1 + updateSize(n.left) + updateSize(n.right);
          return n.size;
      }
    #+end_src 
    - Recursive: ~n.size = 1 + updateSize(n.left) + updateSize(n.right)~ 
*** ~put~ 
    #+begin_src java :classname 
      public void put(K key, V value) {
          if (key == null) throw new IllegalArgumentException("calls put() with a null key");
          root = put(root, key, value);
      }

      public Node put(Node n, K key, V val) {
          if (n == null) return new Node(key, val, 1);
          int cmp = key.compareTo(n.key);
          if      (cmp < 0) n.left  = put(n.left,  key, val);
          else if (cmp > 0) n.right = put(n.right, key, val);
          else              n.val   = val;
          n.size = updateSize(n);
          return n;
      }
    #+end_src 
    - Recursive: ~new Node(key, val, 1)~ + ~n.left  = put(n.left,  key, val)~ and ~n.right = put(n.right, key, val)~ 
*** ~remove~ 
    - ~remove~
      #+begin_src java :classname 
        public V remove(K key) {
            return remove(key, root);
        }

        public V remove(K key, Node n) {
            if (key == null) throw new IllegalArgumentException("calls delete() with a null key");
            if (containsKey(key)) {
                V result = get(key);
                root = updateBST(key, n);
                updateSize(n);
                return result;
            }
            return null;
        }

        public Node updateBST(K key, Node n) {
            int cmp = key.compareTo(n.key);
            if (cmp < 0)        n.left = updateBST(key, n.left);
            else if (cmp > 0)   n.right = updateBST(key, n.right);
            else {
                if      (size(n) == 1)      n = null;
                else if (n.left == null)    n = n.right;
                else if (n.right == null)   n = n.left;
                else {
                    Node max = maxNode(n.left);
                    n.left = updateBST(max.key, n.left);
                    n.key = max.key;
                    n.val = max.val;
                }
            }
            return n;
        }

        private Node maxNode(Node n) {
            // if (n == null || n.right == null) return n;
            if (n.right == null) return n;
            return maxNode(n.right);
        }
      #+end_src
      - ~Node updateBST~ to *update* the BST, and ~root = updateBST(key, n)~ to *redirect* ~root~ to the *updated* BST
      - Recursive: ~n.left = updateBST(key, n.left)~, ~n.right = updateBST(key, n.right)~
      - When ~size >= 3~ 
        #+begin_src java :classname 
          Node max = maxNode(n.left);
          n.left = updateBST(max.key, n.left);
          n.key = max.key;
          n.val = max.val;
        #+end_src 
    - ~removeV~
      #+begin_src java :classname 
        public V removeV(K key, Node n) {
            if (key == null) throw new IllegalArgumentException("calls delete() with a null key");
            if (containsKey(key)) {
                if (n.size == -1) return remove(key, n.right);
                int cmp = key.compareTo(n.key);
                if      (cmp > 0) return remove(key, n.right);
                else if (cmp < 0) return remove(key, n.left);
                else {
                    V result = n.val;

                    if (n == root) {
                        Node tempP = new Node(n.key, n.val, -1);
                        tempP.right = root;
                        root = tempP;
                        V tempV = remove(key, root);
                        root = root.right;
                    }

                    else{

                        Node p = getParent(n, root);

                        if (size(n) == 1) {
                            if (p.left == n) p.left = null;
                            else             p.right = null;
                        }

                        else if (n.left == null) {
                            if (p.left == n) p.left = n.right;
                            else             p.right = n.right;
                        }

                        else if (n.right == null) {
                            if (p.left == n) p.left = n.left;
                            else             p.right = n.left;
                        }

                        else if (n.left.right == null) {
                            n.left.right = n.right;
                            if (p.left == n) p.left = n.left;
                            else             p.right = n.left;
                        }

                        else if (n.right.left == null) {
                            n.right.left = n.left;
                            if (p.left == n) p.left = n.right;
                            else             p.right = n.right;
                        }

                        else {
                            Node max = maxNode(n.left);
                            Node maxP = getParent(max, root);
                            maxP.right = max.left;
                            max.left = maxP;
                            max.right = n.right;
                            if (p.left == n) p.left = max;
                            else             p.right = max;
                        }
                    }

                    updateSize(root);
                    return result;
                }
            }
            return null;
        }

        private Node getParent(Node son, Node parent) {
            if (son == parent.left || son == parent.right) return parent;
            K compKey = parent.key;
            Node max = maxNode(parent.left);
            if (max != null) {
                compKey = max.key;
            }
            int cmp = son.key.compareTo(compKey);
            if (cmp > 0) return getParent(son, parent.right);
            else return getParent(son, parent.left);
        }
      #+end_src
      - When calling ~maxNode~, need ~if (n == null || n.right == null)~ not ~if (n.right == null || n == null)~ 
*** ~keySet~ <<1>>
    #+begin_src java :classname 
      public Set<K> keySet() {
          return keySet(root);
      }

      public Set<K> keySet(Node n) {
          if (n == null) return Collections.emptySet();
          Set<K> s = new HashSet<>();
          s.addAll(keySet(n.left));
          s.add(n.key);
          s.addAll(keySet(n.right));
          return s;
      }
    #+end_src 
    - ~Collections.emptySet()~ for empty set
    - ~s1.add(element)~ and ~s1.addAll(s2)~
    - ~s.addAll(keySet(n.left))~ --> ~s.add(n.key)~ --> ~s.addAll(keySet(n.right))~ to get *sorted* ~keySet~ 
*** ~iterator~ and ~printInOrder~
    #+begin_src java :classname 
      public Iterator<K> iterator() {
          return keySet(root).iterator();
      }
    #+end_src 
    #+begin_src java :classname 
      public void printInOrder() {
          for (K k : keySet(root)) {
              System.out.println(k);
          }
      }
    #+end_src 
    - ~Set~ *implements* ~Collections~, while ~Collection~ *implements* ~Iterable~ -> ~Set~ is *iterable*, ~Set.iterator~ to return ~Iterator~ [[2]]
    - ~for~ can be used on *iterables* [[file:~/csnds/cs/code/61b/rnl.org::2178][Iteration]]
*** Question:                                                     :QUESTIONS:
    1. 这种把方法定义全部以树为单位 与 以节点为单位的区别与优劣？而对于 ~size~ 又不是以树为单位，而是以节点为单位？
    2. ~keySet~ 的直接实现or用额外实例变量 ~list~ 存储实现，与 ~printInOrder~ 和 ~iterator~ 在这两种实现下的不同？ [[1]] 直接实现对吗？用额外的 ~list~ 是否不好实现，因为存储结构不方便遍历树？什么情况下不方便直接实现而需要采用一种合适的结构间接实现呢？以及是否间接实现就要详细写 ~Iterator~ ？间接结构怎么选择？
** Tests
*** TestBSTMapExtra (~testkeySet~)
    #+begin_src java :classname 
      @Test 
      public void testkeySet() {
          BSTMap actual = new BSTMap();
          actual.put("d", 1);
          actual.put("b", 1);
          actual.put("a", 1);
          actual.put("c", 1);
          actual.put("e", 1);
          actual.put("f", 1);
          actual.put("g", 1);
          String[] c = {"a", "b", "c", "d", "e", "f", "g"};
          Set<String> expect = new HashSet<>(Arrays.asList(c));
          assertEquals(actual.keySet(), expect);
          Iterator<String> seer = actual.iterator();
          assertEquals(seer.next(), "a");
          assertEquals(seer.next(), "b");
          assertEquals(seer.next(), "c");
          assertEquals(seer.next(), "d");
          assertEquals(seer.next(), "e");
          assertEquals(seer.next(), "f");
          assertEquals(seer.next(), "g");
      }
    #+end_src 
    - Comparison among ~Arrays~, ~List~ and ~Set~
      - ~List~ and ~Set~ are *interfaces*, while ~Arrays~ is a *class*
        - Interface: Both ~List~ and ~Set~ *implement* ~Collection~, while ~Collection~ *implements* ~Iterable~
        - Class: ~Arrays~ *extends* ~Object~ 
      - Convertion
        - ~List~ <-> ~Arrays~
          - ~Arrays~ -> ~List~ <<2>>
            #+begin_src java :classname 
              String[] s = new String[]{"A", "B", "C", "D","E"};
              List<String> list = Arrays.asList(s);

              s[0] ="AA";
              System.out.println("list: " + list);

              list: [AA, B, C, D, E]
            #+end_src
            - ~Arrays.asList(array)~
            - Elements in ~list~ *equals* elements in ~s~: changes in ~s~ will affect ~list~ 
          - ~List~ -> ~Arrays~ <<3>>
            #+begin_src java :classname 
              String[] dest = list.toArray(new String[0]);//new String[0]是指定返回数组的类型
              System.out.println("dest: " + Arrays.toString(dest));

              dest: [AA, B, C, D, E]

              list.set(0, "Z");
              System.out.println("modified list: " + list);
              System.out.println("dest: " + Arrays.toString(dest));

              modified list: [Z, B, C, D, E]
              dest: [AA, B, C, D, E]
            #+end_src
            - ~list.toArray(Array type)~
            - Elements in ~dest~ *not equals* elements in ~list~: changes in ~list~ won't affect ~dest~ 
        - ~List~ <-> ~Set~ 
          - ~List~ -> ~Set~: ~Set<String> set = new HashSet<>(list);~ 
          - ~Set~ -> ~List~: ~List<String> list_1 = new ArrayList<>(set);~
          - Same as ~toArray()~, changes won't affect
          - Can also use ~addAll(Collection<? extends E> c)~ to convert
        - ~Arrays~ <-> ~Set~ 
          - ~Arrays~ -> ~Set~: ~set = new HashSet<>(Arrays.asList(s));~ 
          - ~Set~ -> ~Arrays~: ~dest = set.toArray(new String[0]);~  
      - ~Arrays.asList()~ and ~Collection.toArray()~
        - ~Arrays.asList~
          ~public static <T> List<T> asList(T... a)~: Returns a *fixed-size list* backed by the *specified array*.
          #+begin_src java :classname 
            public class Arrays {
                ...

                @SafeVarargs
                @SuppressWarnings("varargs")
                public static <T> List<T> asList(T... a) {
                    return new ArrayList<>(a);
                }
                ...
                 private static class ArrayList<E> extends AbstractList<E>
                    implements RandomAccess, java.io.Serializable
                {
                    private static final long serialVersionUID = -2764017481108945198L;
                    private final E[] a;

                    ArrayList(E[] array) {
                        a = Objects.requireNonNull(array);
                    }

                    ...
                }
            }
          #+end_src
          - ~ArrayList~ above is different from ~java.util.ArrayList~, it's a *nest class* of ~java.util.Arrays~ 
          - ~list~ [[2]] is an *instance* of ~java.util.Arrays$ArrayList~, not ~java.util.ArrayList~
          - Return of ~Arrays.asList~ is *fixed-size*, doesn't have ~resize~ as ~java.util.ArrayList~ 
        - ~Collection.toArray()~
          - ~Object[] toArray()~: Returns an *array* containing all of the elements in this *collection*
            #+begin_src java :classname 
              public abstract class AbstractCollection<E> implements Collection<E> {
                  ...

                  public Object[] toArray() {
                      // Estimate size of array; be prepared to see more or fewer elements
                      Object[] r = new Object[size()];
                      Iterator<E> it = iterator();
                      for (int i = 0; i < r.length; i++) {
                          if (! it.hasNext()) // fewer elements than expected
                              return Arrays.copyOf(r, i);
                          r[i] = it.next();
                      }
                      return it.hasNext() ? finishToArray(r, it) : r;
                  }
              }
            #+end_src
          - ~<T> T[] toArray(T[] a)~: Returns an *array* containing all of the elements in this *collection*; the *runtime type* of the returned array is that of the specified array.
            #+begin_src java :classname 
              public abstract class AbstractCollection<E> implements Collection<E> {
                  ...

                  @SuppressWarnings("unchecked")
                  public <T> T[] toArray(T[] a) {
                      // Estimate size of array; be prepared to see more or fewer elements
                      int size = size();
                      T[] r = a.length >= size ? a :
                                (T[])java.lang.reflect.Array
                                .newInstance(a.getClass().getComponentType(), size);
                      Iterator<E> it = iterator();

                      for (int i = 0; i < r.length; i++) {
                          if (! it.hasNext()) { // fewer elements than expected
                              if (a == r) {
                                  r[i] = null; // null-terminate
                              } else if (a.length < i) {
                                  return Arrays.copyOf(r, i);
                              } else {
                                  System.arraycopy(r, 0, a, 0, i);
                                  if (a.length > i) {
                                      a[i] = null;
                                  }
                              }
                              return a;
                          }
                          r[i] = (T)it.next();
                      }
                      // more elements than expected
                      return it.hasNext() ? finishToArray(r, it) : r;
                  }

                  ...
              }
            #+end_src
            - *Runtime type* of ~dest~ [[3]] is ~String[]~, decided by ~new String[0]~  <<2>>
**** Question:                                                   :QUESTIONS:
     1. 是否 ~List~ 和 ~Set~ 都没有固定长度而 ~Arrays~ 的长度是指定的？
     2. ~Arrays.asList~ 返回的 ~ArrayList~ 和 ~java.util.ArrayList~ 异同？除了固定长度还有啥？
     3. ~Collection.toArray~ 返回的 ~Arrays~ 和 ~java.util.Arryas~ 异同？
** Challenge BST Performance                                     :UNRESOLVED:
