#+TAGS: QUESTIONS(q) TOBEORG(t) UNCOVERED(u) EXTRA(e) SLIDE(s)
* 1 Introduction to Java                                             :SLIDE:
** Essentials
   #+begin_src java :classname HelloWorld
     public class HelloWorld {
         public static void main(String[] args) {
             System.out.println("Hello world!");
         }
     }
   #+end_src
   *Some key syntactic features*
   - The pg consists of a *class declaration*: ~public class~. In Java, all code lives *inside of classes*.
   - Code is running inside of a *method called main*: ~public static void main(String[] args)~.
   -  ~{~ and ~}~.
   - Semi-colons ~;~.
*** Running a Java Pg 
    *The most common way to execute a Java pg*: Compiler ~javac~ --> Interpreter ~java~

    #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/compilation_figure.svg @ 2019-03-01 10:36:13
    [[file:pictures/1_Introductio_t_Java/compilation_figure_2019-03-01_10-36-13.svg]]

    #+begin_src sh 
      javac HelloWorld.java 
      java HelloWorld
    #+end_src 
    
    #+RESULTS:
    : Hello world!

*** Vars and Loops
    #+begin_src java :classname HelloNumbers
      public class HelloNumbers {
          public static void main(String[] args) {
              int x = 0;
              while (x < 10) {
                  System.out.print(x + " ");
                  x = x + 1;
              }
          }
      }
    #+end_src 
    - *Some interesting features of this pg* 
      - Var x *must declared and given a type* before *used*.
      - Loop def in ~{}~, boolean expression in ~()~.
      - ~System.out.print~ instead of ~System.out.println~, no new line.
    - Exercise 1.1.2 Modify ~HelloNumbers~ so that it prints out the cumulative sum of the integers from 0 to 9. For example, your output should start with 0 1 3 6 10... and should end with 45. 
      #+begin_src java :classname HelloNumbers
        public class HelloNumbers {
            public static void main(String[] args) {
                int x = 1;
                int sum = 0;
                while (sum < 46) {
                    System.out.print(sum + " ");
                    sum = x + sum;
                    x = x + 1;
                }
            }
        }
      #+end_src 
 
      #+RESULTS:
      : 0 1 3 6 10 15 21 28 36 45

*** Static Typing
    One of the most important features of Java is that *all vars and expressions* have a so-called ~static type~, the type of a var can *never change*.
    #+begin_src java :classname HelloNumbers
      public class HelloNumbers {
          public static void main(String[] args) {
              int x = 0;
              while (x < 10) {
                  System.out.print(x + " ");
                  x = x + 1;
              }
              x = "horse";
          }
      }
    #+end_src 
    - *Static typing advs*
      - The *compiler* ensures that all *types are compatible*, easier to *debug*.
      - *Compiled* programs will *never* run into *type errors*.
      - Every var, para, and func has *a declared type*, easier to understand and reason code.
    #+begin_src java :classname test
      public class test {
          public static void main(String[] args) {
              String h = 5 + "horse";
              System.out.print(h);
          }
      }
    #+end_src 
    #+begin_src python :results output
      print(5+'horse')
    #+end_src 
    - For java, *stronly typed*, ~String~ can concatenate the elements into a str, while ~int~ can't concatenate a num and a str.
    - For python, type not constrained, ~5+'horse'~ errors. 
*** Def Funcs in Java
    #+begin_src python :results output
      def larger(x, y):
          if x > y:
              return x
          return y

      print(larger(8, 10))
    #+end_src 
    #+begin_src java :classname LargerDemo
      public class LargerDemo {
          public static int larger(int x, int y) {
              if (x > y) {
                  return x;
              }
              return y;
          }

          public static void main(String[] args) {
              System.out.println(larger(8, 10));
          }
      }
    #+end_src 
    - In python, funcs can be declared *anywhere*.
    - In java, java code is *part of a class*, funcs must defined *belong to some class* and called *methods*.
    - ~def~ in python, ~public static~ in java.  
** Objects
*** Static vs. Non-Static Methods
    - Static Methods
     All code in Java must be *part of a class* (or something similar).
     #+begin_src java :classname Dog
       public class Dog {
           public static void makeNoise() {
               System.out.println("Bark!");
           }
       }
     #+end_src 
     #+begin_src java :classname DogLauncher
       public class DogLauncher {
           public static void main(String[] args) {
               Dog.makeNoise();
           }
       }
     #+end_src 
      - No ~main~ method in class ~Dog~. 
      - ~DogLauncher~ is a *client* of ~Dog~.
      - Neither or the two techniques(add ~main~ to ~Dog~ or create ~DogLauncher~) is better.
    - Instance Variables and Object Instantiation
      - Approach 1: create separate classes for each type of ~Dog~.
         #+begin_src java :classname TinyDog
           public class TinyDog {
               public static void makeNoise() {
                   System.out.println("yip yip yip yip");
               }
           }
         #+end_src 
         #+begin_src java :classname MalamuteDog
           public class MalamuteDog {
               public static void makeNoise() {
                   System.out.println("arooooooooooooooo!");
               }
           }
         #+end_src 
      - Approach 2: create instances of the ~Dog~ class and make the behavior of the ~Dog~ methods contingent upon the properties of the specific ~Dog~.
        #+begin_src java :classname Dog
          public class Dog {
              public int weightInPounds;
  
              public void makeNoise() {
                  if (weightInPounds < 10) {
                      System.out.println("yipyipyip!");
                  } else if (weightInPounds < 30) {
                      System.out.println("bark. bark.");
                  } else {
                      System.out.println("woof!");
                  }
              }
          }
        #+end_src 
        #+begin_src java :classname DogLauncher
          public class DogLauncher {
              public static void main(String[] args) {
                  Dog d;
                  d = new Dog();
                  d.weightInPounds = 20;
                  d.makeNoise();
              }
          }
        #+end_src 
      - Some key observations and terminology:
        - ~Object~ in Java is an *instance* of any class.
        - *Instance variables* or *non-static variables*: variables *must* be declared *inside the class* (new variables can be added at runtime in Python or Matlab).
        - *Instance methods* or *non-static methods* (no ~static~ keyword): methods created in class.
        - ~new~ to instantiate a ~class~.
        - *Instantiated object* can be assinged to a *declared* variable of the appropriate type: ~d = new Dog()~ 
    - Constructors in Java
      #+begin_src java :classname Dog
        public class Dog {
            public int weightInPounds;
 
            public Dog(int w) {
                weightInPounds = w;
            }
 
            public void makeNoise() {
                if (weightInPounds < 10) {
                    System.out.println("yipyipyip!");
                } else if (weightInPounds < 30) {
                    System.out.println("bark. bark.");
                } else {
                    System.out.println("woof!");
                }    
            }
        }
      #+end_src 
      #+begin_src java :classname DogLauncher
        public class DogLauncher {
            public static void main(String[] args) {
                Dog d = new Dog(20);
                d.makeNoise();
            }
        }
      #+end_src 
       - *Constructors* can save the time and messiness of manually typing out potentially many *instance variable assignments*.
       - The *constructor* with signature ~public Dog(int w)~ will be invoked anytime when ~new Dog(n)~.
       - Similar to ~__init__~ in Python.
    - Array Instantiation, Arrays of Objects
      - Array instantiation
        #+begin_src java :classname ArrayDemo
          public class ArrayDemo {
              public static void main(String[] args) {
                  /* Create an array of five integers. */
                  int[] someArray = new int[5];
                  someArray[0] = 3;
                  someArray[1] = 4;
              }
          }
        #+end_src 
      - Arrays of instantiated objects
        #+begin_src java :classname DogArrayDemo
          public class DogArrayDemo {
              public static void main(String[] args) {
                  /* Create an array of two dogs. */
                  Dog[] dogs = new Dog[2];
                  dogs[0] = new Dog(8);
                  dogs[1] = new Dog(20);
  
                  /* Yipping will result, since dogs[0] has weight 8. */
                  dogs[0].makeNoise();
              }
          }
        #+end_src 
        - ~class[] var = new class[n]~ for arrays
        - Two different ~new~:
          1. ~new Dog[2]~ to *create* an *array* that hold 2 ~Dog~ *objects(not instantiated)*.
          2. ~new Dog(8)~ to *instantiate* each ~Dog~ *object*.
*** Class Methods vs. Instance Methods
    Java allows us to define *2 types* of methods:
    1. *Class methods*, a.k.a *static* methods: *Static methods* are actions that are taken by the *class itself*.
    2. *Instance methods*, a.k.a *non-static* methods: *Instance methods* are actions that can be taken only by *a specific instance of a class*.
    #+begin_src java :classname Dog
      public class Dog {
          public int weightInPounds;

          public Dog(int w) {
              weightInPounds = w;
          }

          public void makeNoise() {
              if (weightInPounds < 10) {
                  System.out.println("yipyipyip!");
              } else if (weightInPounds < 30) {
                  System.out.println("bark. bark.");
              } else {
                  System.out.println("woof!");
              }
          }

          public static Dog maxDog(Dog d1, Dog d2) {
              if (d1.weightInPounds > d2.weightInPounds) {
                  return d1;
              }
              return d2;
          }

          public Dog maxDog(Dog d2) {
              if (this.weightInPounds > d2.weightInPounds) {
                  return this;
              }
              return d2;
          }

      }
     #+end_src 
    #+begin_src java :classname DogLauncher
       public class DogLauncher {
           public static void main(String[] args) {
               Dog d = new Dog(100);
               Dog d2 = new Dog(20);
               d.maxDog(d,d2);
               Dog.maxDog(d,d2);
           }
       }
    #+end_src
    - Class method: ~public static Dog maxDog~.
    - Instance method: ~public Dog maxDog~.
     
    - Exercise 1.2.1: What would the following method do? If you're not sure, try it out.        
      #+begin_src java :classname Dog
        public class Dog {
            public int weightInPounds;
 
            public Dog(int w) {
                weightInPounds = w;
            }
 
            public static Dog maxDog(Dog d1, Dog d2) {
                if (weightInPounds > d2.weightInPounds) {
                    return this;
                }
                return d2;
            }
        }
      #+end_src 
      - ~javac Dog.java~ output: *non-static variable* (~weightInPounds~) this *cannot* be referenced from a *static context* (~maxDog~).
    - Static Variables
      #+begin_src java :classname Dog
        public class Dog {
            public int weightInPounds;
            public static String binomen = "Canis familiaris";
            ...
        }
      #+end_src 
      - *Inherented* to *class itself* rather than the *instance* of class.
      - Usage: ~Dog.binomen~, not ~d.binomen~.
      - Java allows ~d.binomen~, a bad style. 
      - Exercise 1.2.2: Complete this exercise:
        #+begin_src java :classname Dog
          public class Dog {
              public int weightInPounds;
  
              public Dog(int w) {
                  weightInPounds = w;
              }
  
              public void makeNoise() {
                  if (weightInPounds < 10) {
                      System.out.println("yipyipyip!");
                  } else if (weightInPounds < 30) {
                      System.out.println("bark. bark.");
                  } else {
                      System.out.println("woof!");
                  }
              }
  
              public static Dog maxDog(Dog d1, Dog d2) {
                  if (d1.weightInPounds > d2.weightInPounds) {
                      return d1;
                  }
                  return d2;
              }
  
              public Dog maxDog(Dog d2) {
                  if (this.weightInPounds > d2.weightInPounds) {
                      return this;
                  }
                  return d2;
              }
  
          }
        #+end_src 
        #+begin_src java :classname Dogloop
           public class Dogloop {
               public static void main(String[] args) {
                   Dog smallDog = new Dog(5);
                   Dog mediumDog = new Dog(25);
                   Dog hugeDog = new Dog(150);
   
                   Dog[] manyDogs = new Dog[4];
                   manyDogs[0] = smallDog;
                   manyDogs[1] = hugeDog;
                   manyDogs[2] = new Dog(130);
   
                   int i = 0;
                   while (i < manyDogs.length) {
                       Dog.maxDog(manyDogs[i], mediumDog).makeNoise();
                       i = i + 1;
                   }
               }
           }
        #+end_src
        - Env analysis and output
          #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-17 14:43:29
          [[file:pictures/1_Introductio_t_Java/screenshot_2019-03-17_14-43-29.png]]
          #+begin_example
            bark. bark.
            woof!
            woof!
            Exception in thread "main" java.lang.NullPointerException
                    at Dog.maxDog(Dog.java:19)
                    at Dogloop.main(Dogloop.java:14)
          #+end_example
*** public static void main(String[] args)
    ~public static void main(String[] args)~:
    - ~public~: So far, all of *methods* start with ~public~.
    - ~static~: ~static~ method, not associated with *any particular instance*.
    - ~void~: No return type.
    - ~main~: Method's name.
    - ~String[] args~: A *para* passed to the ~main~ method.
     
    - Command Line Args
      Since ~main~ is called by the *Java interpreter itself(~javac~) rather than another Java class*, it is the *interpreter's job* to *supply these args*. They refer usually to the *command line arguments*. 
  
      #+begin_src java :classname 
        public class ArgsDemo {
            public static void main(String[] args) {
                System.out.println(args[0]);
            }
        }
      #+end_src 
  
      #+begin_src sh 
        java ArgsDemo these are command line args
      #+end_src 
  
      #+RESULTS:
      : these
  
      - ~args~ = ~{"these", "are", "command", "line", "args"}~
    - Summing Command Line Arguments
      - Exercise 1.2.3: try to write a program that sums up the command line arguments, assuming they are numbers. For a solution, see the webcast or the code provided on GitHub.
        #+begin_src java :classname argsum
          public class argsum {
              public static void main(String[] args) {
                  int i = 0;
                  int sum = 0;
                  while(i < args.length) {
                      sum += Integer.parseInt(args[i]);
                      i += 1;
                  }
                  System.out.print(sum);
              }
          }
        #+end_src 
        #+begin_src sh 
          java argsum 1 2 3 4 5 6
        #+end_src 
        #+RESULTS:
        : 21
        - ~Integer.parseInt(String)~: Convert ~String~ to a *primitive* ~int~ and *return* it.
* 2 Lists                                                            :SLIDE:
** Mystery of the Walrus
   ~List~ could easily change the number of object after the simulation had begun.
*** The Mystery of the Walrus
    #+begin_src java :classname PollQuestions
      public class PollQuestions {
          public static void main(String[] args) {
              Walrus a = new Walrus(1000, 8.3);
              Walrus b;
              b = a;
              b.weight = 5;
              System.out.println(a);
              System.out.println(b);      

              int x = 5;
              int y;
              y = x;
              x = 2;
              System.out.println("x is: " + x);
              System.out.println("y is: " + y);      
          }

          public static class Walrus {
              public int weight;
              public double tuskSize;

              public Walrus(int w, double ts) {
                  weight = w;
                  tuskSize = ts;
              }

              public String toString() {
                  return String.format("weight: %d, tusk size: %.2f", weight, tuskSize);
              }
          }
      }
    #+end_src 
    - Env analysis
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-19 23:37:17
      [[file:pictures/2._Lists/screenshot_2019-03-19_23-37-17.png]]
*** Bits
    72 and 'H' both stored as 01001000 *in memory*, interpreter differs them by *type*.
    8 primitive types of Java: byte, short, int, long, float, double, boolean, and char.
    #+begin_src java :classname 
      char c = 'H';
      int x = c;
      System.out.println(c);
      System.out.println(x);
    #+end_src 
    #+begin_example output
      H
      72
    #+end_example
*** Declaring a Variable (Simplified)
    #+begin_src java :classname 
      int x;
      double y;
    #+end_src 
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-20 00:12:16
    [[file:pictures/2._Lists/screenshot_2019-03-20_00-12-16.png]]
    #+begin_src java :classname 
      x = -1431195969;
      y = 567213.112;
    #+end_src 
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-20 00:12:55
    [[file:pictures/2._Lists/screenshot_2019-03-20_00-12-55.png]]
    - When you *declare* a variable of a certain type, Java finds a *continuous* block with exactly enough bits to hold a thing of that type.
    - In addition to setting aside memory, the Java interpreter also *creates an entry* in an *internal table* that *maps each variable name to the location of the first bit* in the box.
    - the *exact memory address* is *below the level of abstraction accessible* to us in Java
    - Java does not write anything into the *reserved* box when a variable is *declared*. Java compiler *prevents* you from using a variable until after the box has been filled with bits using the = operator.
     
    - Simplified Box Notation
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-20 15:05:29
      [[file:pictures/2._Lists/screenshot_2019-03-20_15-05-29.png]]
*** The Golden Rule of Equals (GRoE)
    In Java, ~=~ for *any* assignment means *interpreter copying bits* from A into B.
*** Reference Types
    - ~primitive type~: ~byte~, ~short~, ~int~, ~long~, ~float~, ~double~, ~boolean~, ~char~.
    - ~reference type~: Everything else, including arrays.
     
    - Object Instantiation
      #+begin_src java :classname 
        public static class Walrus {
            public int weight;
            public double tuskSize;
 
            public Walrus(int w, double ts) {
                weight = w;
                tuskSize = ts;
            }
        }
      #+end_src 
      Use ~new Walrus(1000, 8.3)~ 
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:08:50
      [[file:pictures/2._Lists/screenshot_2019-03-31_23-08-50.png]]
      In *real implementations* of the Java programming language, there is actually some *additional overhead* for any object, so a Walrus takes somewhat more than 96 bits. 
    - Reference Variable Declaration
      When a variable of *any reference type declared*, Java allocates *a box of 64 bits* to store the *address(fist bit)* of the variable *in memory*.
      1. ~Walrus someWalrus~: Creating a *box of 64 bits*.
      2. ~someWalrus = new Walrus(1000, 8.3)~: Creating a new ~Walrus~ and return its *address* by the ~new~ operator.
         - If Walrus ~weight~ is stored starting at bit ~5051956592385990207~ and ~tuskSize~ at ~5051956592385990239~ (more 32 bits than ~weight~, which is ~int~):
           #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:39:47
           [[file:pictures/2._Lists/screenshot_2019-03-31_23-39-47.png]]
         - Assigning ~null~ to a *reference variable* (such as ~someWalrus~):
           #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:41:47
           [[file:pictures/2._Lists/screenshot_2019-03-31_23-41-47.png]]
    - Box and Pointer Notation
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:45:22
      [[file:pictures/2._Lists/screenshot_2019-03-31_23-45-22.png]]
    - Resolving the Mystery of the Walrus
      #+begin_src java :classname 
        Walrus a = new Walrus(1000, 8.3);
        Walrus b;
        b = a;
      #+end_src 
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-04-01 00:28:59
      [[file:pictures/2._Lists/screenshot_2019-04-01_00-28-59.png]]
*** Parameter Passing
    - Exercise 2.1.1
      #+begin_src java :classname PassByValueFigure
        public class PassByValueFigure {
            public static void main(String[] args) {
                Walrus walrus = new Walrus(3500, 10.5);
                int x = 9;

                doStuff(walrus, x);
                System.out.println(walrus);
                System.out.println(x);
            }

            public static void doStuff(Walrus W, int x) {
                W.weight = W.weight - 100;
                x = x - 5;
            }
        }
      #+end_src 
      - ~doStuff~ has an effect on only ~walrus~, not ~x~.
*** Instantiation of Arrays
     #+begin_src java :classname 
       int[] x; //declaration
       Planet[] planets;
       x = new int[]{0, 1, 2, 95, 4}; //instantiate
     #+end_src 
     - *Declaration* ~type[] x~ (~type~ can be ~primitive~ or ~reference~): creating memory boxes of *64 bits* to store *addresses*.
     - *Instantiation* ~x = new int[]{...}~: creating boxes of 32 bits each and returns the address of the overall object (this list) for assignment to x
*** IntLists
    #+begin_src java :classname 
      public class IntList {
          public int first;
          public IntList rest;        

          public IntList(int f, IntList r) {
              first = f;
              rest = r;
          }
      }
    #+end_src 
    to make a list of numbers 5, 10, and 15.
    #+begin_src java :classname 
      // build forwards
      IntList L = new IntList(5, null);
      L.rest = new IntList(10, null);
      L.rest.rest = new IntList(15, null);
      // or backwards
      IntList L = new IntList(15, null);
      L = new IntList(10, L);
      L = new IntList(5, L);
    #+end_src 
    above code is ugly and prone to errors -> adopt the *usual object oriented* programming strategy of *adding helper methods* to class to perform basic tasks

    - ~size~ and ~iterativeSize~ (helper methods)
      #+begin_src java :classname 
        public int size() {
            if (rest == null) {
                return 1;
            }
            return 1 + this.rest.size();
        }
        //iterative size
        public int iterativeSize() {
            IntList p = this;
            int totalSize = 0;
            while (p != null) {
                totalSize += 1;
                p = p.rest;
            }
            return totalSize;
        }
      #+end_src 
      - ~if (this == null) return 0;~ leads to ~NullPointer error~
      - use ~p~ for ~pointer~ in ~iterativeSize~ as ~this~ *can't be reassigned* in Java.    
    - ~get~
      #+begin_src java :classname 
        public class IntList {
            public int first;
            public IntList rest;
 
            public IntList(int f, IntList r) {
                first = f;
                rest = r;
            }
 
            public int get(int i) {
                if (i == 0) {
                    return first;
                }
                return rest.get(i - 1);
            }
        }
      #+end_src 
** The SLList
   ~IntList~ is a *naked recursive* data structure 
*** Improvement #1: Rebranding
    #+begin_src java :classname 
      public class IntNode {
          public int item;
          public IntNode next;

          public IntNode(int i, IntNode n) {
              item = i;
              next = n;
          }
      }
    #+end_src 
*** Improvement #2: Bureaucracy
    #+begin_src java :classname 
      public class SLList {
          public IntNode first;

          public SLList(int x) {
              first = new IntNode(x, null);
          }
      }
    #+end_src 
    #+begin_src java :classname 
      IntList L1 = new IntList(5, null);
      SLList L2  = new SLList(5);
    #+end_src 
    ~SLList~ *hides* the detail that there exists a *null link* from the user 
*** addFirst and getFirst
    #+begin_src java :classname 
      public class SLList {
          public IntNode first;

          public SLList(int x) {
              first = new IntNode(x, null);
          }

          /** Adds an item to the front of the list. */
          public void addFirst(int x) {
              first = new IntNode(x, first);
          }

          public int getFirst() {
              return first.item;
          }
      }
    #+end_src 
    #+begin_src java :classname 
      // IntList
      IntList L = new IntList(15, null);
      L = new IntList(10, L);
      L = new IntList(5, L);
      int x = L.first;
      // SLList 
      SLList L = new SLList(15);
      L.addFirst(10);
      L.addFirst(5);
      int x = L.getFirst()
    #+end_src 
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-05-30 23:43:42
    [[file:pictures/2._Lists/screenshot_2019-05-30_23-43-42.png]]
    - ~SLList~ class acts as a *middleman* between the *list user* and the *naked recursive data structure*
    - ~IntList~ user may have a potentially *undesireable* possibility to have *extra* variables that point to the middle of the ~IntList~
      #+begin_src java :classname 
        IntList L = new IntList(15, null);
        L2 = new IntList(10, L);
        L1 = new IntList(5, L2);
      #+end_src
     
    - Exercise 2.2.1: Try to write an ~addFirst~ method to the ~IntList~ class (tricky as well as inefficient)
      #+begin_src java :classname 
        public class IntList {
            public int first;
            public IntList rest;        
 
            public IntList(int f, IntList r) {
                first = f;
                rest = r;
            }
 
            public void addFirst(int x, IntList L) {
                rest = L;
                first = x;
            }
        }
      #+end_src 
      #+begin_src java :classname 
        L = new IntList(15, null);
        L.addFirst(10, L);
        L.addFirst(5, L);
        int x = L.first
      #+end_src 
*** Improvement #3: Public vs. Private
    ~SLList~ can be *bypassed* and the *raw power* of *naked data structure* (with all its dangers) can be accessed. A programmer can easily modify the list *directly*, without going through the *kid-tested*, *mother-approved* ~addFirst~ method, for example:
    #+begin_src java :classname 
      SLList L = new SLList(15);
      L.addFirst(10);
      L.first.next.next = L.first.next;
    #+end_src 
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-05-31 00:15:38
    [[file:pictures/2._Lists/screenshot_2019-05-31_00-15-38.png]]
    - This results in a malformed list with an infinite loop -> to deal with, change ~public IntNode first~ to ~private IntNode first~
    - ~Private~ *variables and methods* can only be accessed by code inside the *same* ~.java~ file
*** Improvement #4: Nested Classes
    #+begin_src java :classname 
      public class SLList {
          public static class IntNode {
              public int item;
              public IntNode next;
              public IntNode(int i, IntNode n) {
                  item = i;
                  next = n;
              }
          }

          private IntNode first;
          ...
    #+end_src 
    - ~static~ means that *methods* inside the ~static~ class can not access any of the *members* of the *enclosing class*
     
    - Exercise 2.2.2
      #+begin_src java :classname 
        /** A rather contrived exercise to test your understanding of when
            nested classes may be made static. This is NOT an example of good
            class design, even after you fix the bug.
 
            The challenge with this file is to delete the keyword static the
            minimum number of times so that the code compiles.
 
            Guess before TRYING to compile, otherwise the compiler will spoil
            the problem.*/
        public class Government {
          private int treasury = 5;
 
          private void spend() {
            treasury -= 1;
          }
 
          private void tax() {
            treasury += 1;
          }
 
          public void report() {
            System.out.println(treasury);
          }
 
          public static Government greaterTreasury(Government a, Government b) {
            if (a.treasury > b.treasury) {
              return a;
            }
            return b;
          }
 
          public static class Peasant {
            public void doStuff() {
              System.out.println("hello");			
            }
          }
 
          public static class King { 
            public void doStuff() {
              spend();			
            }
          }
 
          public static class Mayor {
            public void doStuff() {
              tax();			
            }
          }
 
          public static class Accountant {
            public void doStuff() {
              report();			
            }
          }
 
          public static class Thief {
            public void doStuff() {
              treasury = 0;			
            }
          }
 
          public static class Explorer {
            public void doStuff(Government a, Government b) {
              Government favorite = Government.greaterTreasury(a, b);
              System.out.println("The best government has treasury " + favorite.treasury);			
            }
          }
        }
      #+end_src 
      - Extra ~static class~: ~King~, ~Mayor~, ~Accountant~, ~Thief~
      - ~Explorer~ is ok because it accesses ~greaterTreasury~ and ~treasury~ through ~Government favorite~, not *directly*.    
*** addLast() and size()
    - ~addLast~ 
      #+begin_src java :classname 
        /** Adds an item to the end of the list. */
        public void addLast(int x) {
            IntNode p = first;

            /* Advance p to the end of the list. */
            while (p.next != null) {
                p = p.next;
            }
            p.next = new IntNode(x, null);
        }
      #+end_src 
    - ~private static int size(IntNode p)~: Returns the size of the list *starting* at ~IntNode p~
      #+begin_src java :classname 
        /** Returns the size of the list starting at IntNode p. */
        private static int size(IntNode p) {
            if (p.next == null) {
                return 1;
            }

            return 1 + size(p.next);
        }
      #+end_src
      - A *private helper* (~SLList~) method that interacts with the underlying *naked recursive* data structure (~IntNode~) 
      - *Recursive*: ~return 1 + size(p.next)~
      - ~private~: variables and methods can only be accessed by code inside the *same* ~.java~ file
      - ~static~: variables and methods *inherented to class itself* rather than *instances of class* 
    - ~public int size()~: Returns the size of the *whole* list (starting at ~first~)  
      #+begin_src java :classname 
        public int size() {
            return size(first);
        }
      #+end_src
      - ~size()~ and ~size(IntNode p)~: *overloaded* with the same name but *different signatures*  
*** Improvement #5: Caching
    add a ~size~ variable to the ~SLList~ class that tracks the current size. This practice of *saving important data to speed up retrieval* is sometimes known as *caching*.
    #+begin_src java :classname 
      public class SLList {
          ... /* IntNode declaration omitted. */
          private IntNode first;
          private int size;

          public SLList(int x) {
              first = new IntNode(x, null);
              size = 1;
          }

          public void addFirst(int x) {
              first = new IntNode(x, first);
              size += 1;
          }

          public int size() {
              return size;
          }
          ...
      }
    #+end_src 
    - make ~size()~ incredibly fast no matter how large the list
    - slow down ~addFirst~ and ~addLast~ method
    - increase memory of usage of ~SLList~ class 
*** Improvement #6: The Empty List
    #+begin_src java :classname 
      public class SLList {
          ...
          public SLList() {
              first = null;
              size = 0;
          }

          public SLList(int x) {
              first = new IntNode(x, null);
              size = 1;
          }

          /** Adds an item to the end of the list. */
          public void addLast(int x) {
              size += 1
              if (first == Null) {
                  first = new IntNode(x, Null);
                  return;
              }
              IntNode p = first;

              /* Advance p to the end of the list. */
              while (p.next != null) {
                  p = p.next;
              }
              p.next = new IntNode(x, null);
          }

          /** Crashes when you call addLast on an empty SLList. Fix it. */
          public static void main(String[] args) {
              SLList x = new SLList();
              x.addLast(5);
          }
      }
    #+end_src 
    - ~SLList(int x)~ and ~SLList~ *overloaded*
    - ~addLast~ crashes on *empty* SLList
*** Improvement #6b: Sentinel Nodes
    make all ~SLLists~ to use the *same methods* -> create a special ~IntNode~ node: *sentinel node*  
    #+begin_src java :classname 
      public void addLast(int x) {
          size += 1;
          IntNode p = sentinel;
          while (p.next != null) {
              p = p.next;
          }

          p.next = new IntNode(x, null);
      }
    #+end_src 
    - Empty list created by ~SLList L = new SLList()~
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-06 00:18:33
      [[file:pictures/2._Lists/screenshot_2019-06-06_00-18-33.png]]
    - a ~SLList~ with 5, 10, 15
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-06 00:19:26
      [[file:pictures/2._Lists/screenshot_2019-06-06_00-19-26.png]]
    - ~sentinel = new IntNode(random, Null)~
**** Question:                                                    :QUESTIONS:
     1.在哪里定义 ~sentinel~ ？ ~sentinel~ 与 ~first~ 和 ~addFirst~ 怎么串联起来？   
*** Invariants
    An *invariant* is a *fact* about a *data structure* that is guaranteed to be *true* (assuming there are no bugs in your code)
    A ~SLList~ with a *sentinel node* has at least the following invariants:
    - The ~sentinel~ reference always points to a *sentinel node*.
    - The *front item* (if it exists), is always at ~sentinel.next.item~.
    - The ~size~ variable is always the total number of items that have been added.
** The DLList
*** addLast
    Previous ~addLast~ is *slow* for long lists -> adding a ~last~ variable 
    #+begin_src java :classname 
      public class SLList {
          private IntNode sentinel;
          private IntNode last;
          private int size;    

          public void addLast(int x) {
              last.next = new IntNode(x, null);
              last = last.next;
              size += 1;
          }
          ...
      }
    #+end_src 
    - Exercise 2.3.1
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-09 22:14:35
      [[file:pictures/2._Lists/screenshot_2019-06-09_22-14-35.png]]
     ~addLast~ and ~getLast~ *rapid*, ~removeLast~ slow   
*** SecondToLast
    Adding a ~secondToLast~ 
*** Improvement #7: Looking Back
    Adding a previous pointer to each ~IntNode~ 
    #+begin_src java :classname 
      public class IntNode {
          public IntNode prev;
          public int item;
          public IntNode next;
      }
    #+end_src 
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-09 22:51:21
    [[file:pictures/2._Lists/screenshot_2019-06-09_22-51-21.png]]
*** Improvement #8: Sentinel Upgrade
    ~last~ sometimes points at the ~sentinel~ node, and sometimes at a real node ->
    - Adding a *second sentinel* node to the back of the list
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-09 23:08:50
      [[file:pictures/2._Lists/screenshot_2019-06-09_23-08-50.png]]
    - Implementing the list so that it is *circular*, with the *front and back* pointers sharing the *same sentinel* node
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-09 23:09:34
      [[file:pictures/2._Lists/screenshot_2019-06-09_23-09-34.png]]
*** Generic DLLists
    Creating data structures that hold any ~reference~ type 
    - Adding ~<>~ to define generic ~DLList~ 
      #+begin_src java :classname 
        public class DLList<BleepBlorp> {
            private IntNode sentinel;
            private int size;

            public class IntNode {
                public IntNode prev;
                public BleepBlorp item;
                public IntNode next;
                ...
            }
            ...
        }
      #+end_src
    - Instantiate generic ~DLList~ 
      #+begin_src java :classname 
        DLList<String> d2 = new DLList<>("hello");
        d2.addLast("world");
      #+end_src 
    - Generics only work with ~reference~ types -> using the ~reference~ version of the ~primitive~ type
      #+begin_src java :classname 
        DLList<Integer> d1 = new DLList<>(5);
        d1.insertFront(10);
      #+end_src 
** Arrays
*** Array Creation
    Three valid notations for array creation
    #+begin_src java :classname 
      x = new int[3];
      y = new int[]{1, 2, 3, 4, 5};
      int[] z = {9, 10, 11, 12, 13};
    #+end_src 
*** Array Access and Modification
    #+begin_src java :classname 
      public class ClassNameHere {
          public static void main(String[] args) {
              int[] z = null;
              int[] x, y;

              x = new int[]{1, 2, 3, 4, 5};
              y = x;
              x = new int[]{-1, 2, 5, 4, 99};
              y = new int[3];
              z = new int[0];
              int xL = x.length;

              String[] s = new String[6];
              s[4] = "ketchup";
              s[x[3] - x[1]] = "muffins";

              int[] b = {9, 10, 11};
              System.arraycopy(b, 0, x, 3, 2);
          }
      }
    #+end_src 
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-11 21:03:11
    [[file:pictures/2._Lists/screenshot_2019-06-11_21-03-11.png]]
    - ~System.arraycopy(b, 0, x, 3, 2)~ = ~x[3:5] = b[0:2]~ in python
      - ~b~: The array to use as a source
      - ~0~: Where to start in the source array
      - ~x~: The array to use as a destination
      - ~3~: Where to start in the destination array
      - ~2~: How many items to copy 
*** 2D Arrays in Java
    2D array in Java is actually just an *array of arrays*
    #+begin_src java :classname 
      public class ArrayBasics2 {
          public static void main(String[] args) {
              int[][] pascalsTriangle;
              pascalsTriangle = new int[4][];
              int[] rowZero = pascalsTriangle[0];
		
              pascalsTriangle[0] = new int[]{1};
              pascalsTriangle[1] = new int[]{1, 1};
              pascalsTriangle[2] = new int[]{1, 2, 1};
              pascalsTriangle[3] = new int[]{1, 3, 3, 1};
              int[] rowTwo = pascalsTriangle[2];
              rowTwo[1] = -5;

              int[][] matrix;
              matrix = new int[4][];
              matrix = new int[4][4]; 

              int[][] pascalAgain = new int[][]{{1}, {1, 1}, 
                                                {1, 2, 1}, {1, 3, 3, 1}};
          }
      } 
    #+end_src 
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-11 21:26:52
    [[file:pictures/2._Lists/screenshot_2019-06-11_21-26-52.png]]

    - Exercise 2.4.1
      #+begin_src java :classname 
        public class ArrayDanger {
 
            public static void main(String[] args) {
                int[][] x = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};
 
                int[][] z = new int[3][];
                z[0] = x[0];
                z[1] = x[1];
                z[2] = x[2];
                z[0][0] = -z[0][0];
 
                int[][] w = new int[3][3];
                System.arraycopy(x[0], 0, w[0], 0, 3);
                System.arraycopy(x[1], 0, w[1], 0, 3);
                System.arraycopy(x[2], 0, w[2], 0, 3);
                w[0][0] = -w[0][0];
                System.out.println("x[0][0]: " + x[0][0] + ", w[0][0]: " + w[0][0]);
            }
        } 
      #+end_src 
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-11 21:31:26
      [[file:pictures/2._Lists/screenshot_2019-06-11_21-31-26.png]]
      - ~z[i] = x[i]~ will make ~z[i]~ and ~x[i]~ point to the same array (the *same memory box*), so any operations on the one will have the *same effect* on the other
      - ~System.arraycopy~ will *create new memory box* and just copy the *value* from *src array to des array*. 
*** Arrays vs. Classes
    Both ~arrays~ and ~classes~ can be used to organize a *bunch of memory boxes*. In both cases, the number of memory boxes is *fixed*
    - Key differences between memory boxes in ~arrays~ and ~classes~
      - ~Array~ boxes are *numbered* and accessed using ~[]~ notation, and ~class~ boxes are *named* and accessed using dot notation ~.~
      - ~Array~ boxes must all be the *same* type. ~Class~ boxes can be *different* types
    - One particularly notable *impact of these difference* is that ~[]~ notation allows us to specify which index we'd like *at runtime*
      #+begin_src java :classname 
        int indexOfInterest = askUserForInteger();
        int[] x = {100, 101, 102, 103};
        int k = x[indexOfInterest];
        System.out.println(k);

        $ javac arrayDemo
        $ java arrayDemo
        What index do you want? 2
        102
      #+end_src
      - By contrast, *specifying fields* in a class is not something we do at runtime
        #+begin_src java :classname 
          String fieldOfInterest = "mass";
          Planet p = new Planet(6e24, "earth");
          double mass = p[fieldOfInterest];

          $ javac classDemo
          FieldDemo.java:5: error: array required, but Planet found
                  double mass = earth[fieldOfInterest];        
                                         ^
  
          String fieldOfInterest = "mass";
          Planet p = new Planet(6e24, "earth");
          double mass = p.fieldOfInterest;

          $ javac classDemo
          FieldDemo.java:5: error: cannot find symbol
                  double mass = earth.fieldOfInterest;        
                                     ^
            symbol:   variable fieldOfInterest
             location: variable earth of type Planet
        #+end_src
        - ~reflection~: A way to specify desired fields in a class at runtime, which is considered very *bad* coding style for *typical* programs
**** Question:                                                    :QUESTIONS:
     1. 那两个运行时定义类成员的例子是什么意思？
     2. 运行时定义 ~array~ 值也是不好的风格？ 
*** Appendix: Java Arrays vs. Other Languages
    - Have no special syntax for *"slicing"* (such as in Python).
    - Cannot be *shrunk or expanded* (such as in Ruby).
    - Do not have *member methods* (such as in Javascript).
    - Must contain values only of the *same type* (unlike Python).
** The AList
   Unlike the ~DLList~, the ~AList~ will use *arrays* to store data instead of a *linked list*.
   ~int get(int i)~ in ~DLList~ costs $n/2$ times in worst case -> accessing ~array[i]~ takes *constant* time -> *array-based* list instead of *linked*-list  
*** Our First Attempt: The Naive Array Based List
    - Optional Exercise 2.5.1: Try to build an AList class that supports addLast, getLast, get, and size operations. Your AList should work for any size array up to 100.
      #+begin_src java :classname 
        public class AList {
            private int[] items;
            private int size;
 
            /** Creates an empty list. */
            public AList() {
                items = new int[100];
                size = 0;
            }
 
            /** Inserts X into the back of the list. */
            public void addLast(int x) {
                items[size] = x;
                size = size + 1;
            }
 
            /** Returns the item from the back of the list. */
            public int getLast() {
                return items[size - 1];
            }
            /** Gets the ith item in the list (0 is the front). */
            public int get(int i) {
                return items[i];
            }
 
            /** Returns the number of items in the list. */
            public int size() {
                return size;
            }
 
            /** Deletes item from back of the list and
             ,* returns deleted item. */
            public int removeLast() {
                int x = getLast();
                size = size - 1;
                return x;
            }
        } 
      #+end_src 
      - Any change to *list(abstract idea)* must be reflected in a change in one or more *memory boxes(concrete representation)* in implementation: ~size~, ~items~ and ~items[i]~ above
      - *Invariants* guide the changes
        - The position of the next item to be inserted is always ~size~
        - ~size~ is always the number of items in the ~AList~
        - The last item in the list is always in position ~size - 1~ 
*** Naive Resizing Arrays
    #+begin_src java :classname 
      public void resize(int capacity) {
          int[] a = new int[capacity];
          System.arraycopy(items, 0, a, 0, size);
          items = a;
      }

      public void addLast(int x) {
          if (size == items.length) {
              resize(size + 1);
          }
          items[size] = x;
          size = size + 1;
      }
    #+end_src 
    - ~System.arraycopy(items, 0, a, 0, size);~
    - Only if ~size == items.length~ would call ~resize~ 
*** Analyzing the Naive Resizing Array
    #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/chap2/fig25/insert_experiment.png @ 2019-08-06 12:08:11
    [[file:pictures/2._Lists/insert_experiment_2019-08-06_12-08-10.png]]
    - ~add~ in ~SLList~ takes the same additional amount of time
    - ~addLast~ in ~AList~ 
      - *Creating* all those memory boxes and *recopying* their contents takes time
      - Each operation takes *linear* time (integral is a *parabola*)
*** Geometric Resizing
    Grow the size of array by a *multiplicative* amount, rather than an *additive* amount
    #+begin_src java :classname 
      public void insertBack(int x) {
          if (size == items.length) {
              resize(size + RFACTOR);
          }
          items[size] = x;
          size += 1;
      }
    #+end_src 
    #+begin_src java :classname 
      public void insertBack(int x) {
          if (size == items.length) {
              resize(size * RFACTOR);
          }
          items[size] = x;
          size += 1;
      }
    #+end_src 
*** Memory Performance
    Usage ratio R: size of the list / length of the ~items~ array, halve the size of the array when R falls to less than 0.25
*** Generic ALists <<ilink3>>
    #+begin_src java :classname 
      public class AList<Glorp> {
          private Glorp[] items;
          private int size;

          /** Creates an empty list. */
          public AList() {
              items = (Glorp []) new Object[8];
              size = 0;
          }

          /** Inserts X into the back of the list. */

          public void resize(int capacity) {
              Glorp[] a = (Glorp []) new Object[capacity]; <<elink4>>
              System.arraycopy(items, 0, a, 0, size);
              items = a;
          }

          public void addLast(int x) {
              if (size == items.length) {
                  resize(size + 1);
              }
              items[size] = x;
              size = size + 1;
          }

          /** Returns the item from the back of the list. */
          public Glorp getLast() {
              return items[size - 1];
          }
          /** Gets the ith item in the list (0 is the front). */
          public Glorp get(int i) {
              return items[i];
          }

          /** Returns the number of items in the list. */
          public int size() {
              return size;
          }

          /** Deletes item from back of the list and
           ,* returns deleted item. */
          public Glorp removeLast() {
              Glorp x = getLast();
              items[size - 1] = null;
              size = size - 1;
              return x;
          }
      } 
   #+end_src 
    - Not ~Glorp[] items = new Glorp[8];~ but ~Glorp[] items = (Glorp []) new Object[8];~
    - Java only destroys *objects* when the last *reference* has been lost: ~items[size - 1] = null;~ to *save memory* and *avoid loitering*, while ~int~ need not ~items[size - 1] = 0~
* 3 Testing                                                          :SLIDE:
  Testing and Selection Sort
** JUnit Testing
*** Ad hoc test 
    #+begin_src java :classname 
      public class TestSort {
          /** Tests the sort method of the Sort class. */
          public static void testSort() {
              String[] input = {"i", "have", "an", "egg"};
              String[] expected = {"an", "egg", "have", "i"};
              Sort.sort(input);
              for (int i = 0; i < input.length; i += 1) {
                  if (!input[i].equals(expected[i])) {
                      System.out.println("Mismatch in position " + i + ", expected: " + expected + ", but got: " + input[i] + ".");
                      break;
                  }
              }
          }

          public static void main(String[] args) {
              testSort();
          }
      }
    #+end_src 
    #+begin_src java :classname 
      public class Sort {
          /** Sorts strings destructively. */
          public static void sort(String[] x) {        
          }
      }
    #+end_src 
    - ~==~ can't be used for ~Object~
    - ~java.util.Arrays.equals~ for ~Array~
*** JUnit 
    #+begin_src java :classname 
      public static void testSort() {
          String[] input = {"i", "have", "an", "egg"};
          String[] expected = {"an", "egg", "have", "i"};
          Sort.sort(input);
          org.junit.Assert.assertArrayEquals(expected, input);
      }
    #+end_src 
** Selection Sort <<ilink13>>
   #+begin_src java :classname 
     public static void sort(String[] x) { 
         // find the smallest item
         // move it to the front
         // selection sort the rest (using recursion?)
     }
   #+end_src 
*** findSmallest
    #+begin_src java :classname 
      /** Returns the smallest string in x. 
       ,* @source Got help with string compares from https://goo.gl/a7yBU5. */
      public static String findSmallest(String[] x) {
          String smallest = x[0];
          for (int i = 0; i < x.length; i += 1) {
              int cmp = x[i].compareTo(smallest);
              if (cmp < 0) {
                  smallest = x[i];
              }
          }
          return smallest;
      }
    #+end_src 
    - Not ~if (x[i] < smallest)~ but ~int cmp = x[i].compareTo(smallest);~ 
    #+begin_src java :classname 
      public class TestSort {
          ...
          public static void testFindSmallest() {
              String[] input = {"i", "have", "an", "egg"};
              String expected = "an";

              String actual = Sort.findSmallest(input);
              org.junit.Assert.assertEquals(expected, actual);        

              String[] input2 = {"there", "are", "many", "pigs"};
              String expected2 = "are";

              String actual2 = Sort.findSmallest(input2);
              org.junit.Assert.assertEquals(expected2, actual2);
      }
          public static void main(String[] args) {
              testFindSmallest(); // note: we changed this from testSort!
          }
      }
    #+end_src 
    - ~org.junit.Assert.assertEquals(expected, actual)~ 
*** Swap
    #+begin_src java :classname 
      public static void swap(String[] x, int a, int b) {
          String temp = x[a];
          x[a] = x[b];
          x[b] = temp;
      }
    #+end_src 
    #+begin_src java :classname 
      public class TestSort {
          ...    

          /** Test the Sort.swap method. */
          public static void testSwap() {
              String[] input = {"i", "have", "an", "egg"};
              int a = 0;
              int b = 2;
              String[] expected = {"an", "have", "i", "egg"};

              Sort.swap(input, a, b);
              org.junit.Assert.assertArrayEquals(expected, input);
          }

          public static void main(String[] args) {
              testSwap();
          }
      }
    #+end_src 
*** Revising findSmallest
    #+begin_src java :classname 
      /** Sorts strings destructively. */
      public static void sort(String[] x) { 
          // find the smallest item
          String smallest = findSmallest(x);

          // move it to the front
          swap(x, 0, smallest);

          // selection sort the rest (using recursion?)
      }
    #+end_src 
    - ~smallest~ should be the index
    ->
    #+begin_src java :classname 
      public static int findSmallest(String[] x) {
          int smallestIndex = 0;
          for (int i = 0; i < x.length; i += 1) {
              int cmp = x[i].compareTo(x[smallestIndex]);
              if (cmp < 0) {
                  smallestIndex = i;
              }
          }
          return smallestIndex;
      }
    #+end_src 
    #+begin_src java :classname 
      public static void testFindSmallest() {
          String[] input = {"i", "have", "an", "egg"};
          int expected = 2;

          int actual = Sort.findSmallest(input);
          org.junit.Assert.assertEquals(expected, actual);        

          String[] input2 = {"there", "are", "many", "pigs"};
          int expected2 = 1;

          int actual2 = Sort.findSmallest(input);
          org.junit.Assert.assertEquals(expected2, actual2);
      }
    #+end_src 
    #+begin_src java :classname 
      /** Sorts strings destructively. */
      public static void sort(String[] x) { 
          // find the smallest item
          // move it to the front
          // selection sort the rest (using recursion?)
          int smallestIndex = findSmallest(x);
          swap(x, 0, smallestIndex);
      }
    #+end_src 
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-09 14:20:51
    [[file:pictures/3._Testing/screenshot_2019-08-09_14-20-51.png]]
*** Recursive Helper Methods
    Considering only a subset of a larger array -> create a *private helper* method that has an *additional parameter* (or parameters) that delineate which part of the array to consider.
    #+begin_src java :classname 
      private static void sort(String[] x, int start) { 
          int smallestIndex = findSmallest(x);
          swap(x, start, smallestIndex);
          sort(x, start + 1);
      }
    #+end_src 
    #+begin_src java :classname 
      /** Sorts strings destructively. */
      public static void sort(String[] x) { 
          sort(x, 0);
      }
    #+end_src 
*** Debugging and Completing Sort
    Running ~testSort~ 
    1. Bug 1
      #+begin_src java :classname 
        Exception in thread "main" java.lang.ArrayIndexOutOfBoundsException: 4
            at Sort.swap(Sort.java:16)
      #+end_src 
      ->
      #+begin_src java :classname 
        /** Sorts strings destructively starting from item start. */
        private static void sort(String[] x, int start) { 
            if (start == x.length) {
                return;
            }
            int smallestIndex = findSmallest(x);
            swap(x, start, smallestIndex);
            sort(x, start + 1);
        }
      #+end_src
    2. Bug 2
      #+begin_src java :classname
        Exception in thread "main" arrays first differed at element [0]; 
        expected<[an]> bit was:<[have]>
      #+end_src 
      -> 
      #+begin_src java :classname 
        public static int findSmallest(String[] x, int start) {
            int smallestIndex = start;
            for (int i = start; i < x.length; i += 1) {
                int cmp = x[i].compareTo(x[smallestIndex]);
                if (cmp < 0) {
                    smallestIndex = i;
                }
            }
            return smallestIndex;
        }
      #+end_src 
      #+begin_src java :classname 
        public static void testFindSmallest() {
            String[] input = {"i", "have", "an", "egg"};
            int expected = 2;
  
            int actual = Sort.findSmallest(input, 0);
            org.junit.Assert.assertEquals(expected, actual);        
  
            String[] input2 = {"there", "are", "many", "pigs"};
            int expected2 = 2;
  
            int actual2 = Sort.findSmallest(input2, 2);
            org.junit.Assert.assertEquals(expected2, actual2);
        }
      #+end_src 
      #+begin_src java :classname
        /** Sorts strings destructively starting from item start. */
        private static void sort(String[] x, int start) { 
            if (start == x.length) {
                return;
            }
            int smallestIndex = findSmallest(x, start);
            swap(x, start, smallestIndex);
            sort(x, start + 1);
        }
      #+end_src
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-09 14:32:18
    [[file:pictures/3._Testing/screenshot_2019-08-09_14-32-18.png]]
** Reflections on the Development Process
   Small units' function --> small units' tests --> writing small units to pass --> gathering small units and get bugs --> revising small units' tests and small units --> continue debuging
** Better JUnit
*** Two majro enhancements 
    1. Test annotation
       - Precede each method with ~@org.junit.Test~
       - Change each test method to be *non-static*.
       - Remove ~main~ method from the ~TestSort~ class.
    2. ~import org.junit.Test~ and ~import static org.junit.Assert.*~
       - ~@org.junit.Test~ -> ~@Test~
       - Omit ~org.junit.Assert.~ 
* 4 Inheritance, Implements                                          :SLIDE:
** Intro, Hello World Java
*** Method overloading
    #+begin_src java :classname 
      public static String longest(SLList<String> list) {
          int maxDex = 0;
          for (int i = 0; i < list.size(); i += 1) {
              String longestString = list.get(maxDex);
              String thisString = list.get(i);
              if (thisString.length() > longestString.length()) {
                  maxDex = i;
              }
          }
          return list.get(maxDex);
      }
    #+end_src 
    - ~SLList<String> list~ for ~SLList~ and ~AList<String> list~ for ~AList~
    - Many disadvantages
*** Hypernyms, Hyponyms, and Interface
    #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/subclass.png @ 2019-08-09 17:37:17
    [[file:pictures/4._Inheritance,_Implements/subclass_2019-08-09_17-37-17.png]]
    - To express relationship above
      1. Define a *interface* (superclass or hyernym)
         #+begin_src java :classname 
           public interface List61B<Item> {
               public void addFirst(Item x);
               public void add Last(Item y);
               public Item getFirst();
               public Item getLast();
               public Item removeLast();
               public Item get(int i);
               public void insert(Item x, int position);
               public int size();
           }
         #+end_src 
      2. Specify subclasses (hyponyms): using ~implements List61B<Item>~ 
         - ~public class AList<Item> implements List61B<Item>{...}~ and ~public class SLList<Item> implements List61B<Item>{...}~
         - Any instances belong to *its class* and *superclasses of its class* ("is-a" relationship) 
*** Overriding
    #+begin_src java :classname 
      class SLList<Item> {
          ...
          @Override
          public void addFirst(Item x) {
              insert(x, 0);
          }
      }
    #+end_src 
    - ~@Override~
    - Subclass overrides methods: ~SLList~ overrides ~addFirst~ 
*** Interface Inheritance
    - *Subclass* inherits all the methods/behaviors of the *superclasses*
    - A *superclass* memory box can refer to a *subclass* object (GRoE of ~=~ )
      - ~List61B<String> someList = new SLList<String>();~ and ~someList.addFirst("elk");~ will compile and run well
      - ~SLList<String> list~ and ~AList<String> list~ -> ~public static String longest(List61B<String> list)~
*** Implementation Inheritance
    - Every var in Java has *dynamic (run-time type)* and *static (compile-time type)* types
      ~List61B<String> lst = new SLList<String>();~ 
      - *Static type* of ~lst~: *unchangeable* declaration of ~lst~ -> ~List61B~
      - *Dynamic type* of ~lst~: object's type that ~lst~ refers to -> ~SLList~
    - Java checks object's *static type* when *compiling* and *dynamic type* when *running* (like *override method*)
      - Override and *dynamic method selection*
        - Define default in ~List61B~
          #+begin_src java :classname 
            default public void print() {
                for (int i = 0; i < size(); i += 1) {
                    System.out.print(get(i) + " ");
                }
                System.out.println();
            }
          #+end_src
          - ~default~ keywork
          - Efficient for ~AList~, inefficient for ~SLList~ 
        - Override in ~SLList~
         #+begin_src java :classname 
           @Override
           public void print() {
               for (Node p = sentinel.next; p != null; p = p.next) {
                   System.out.print(p.item + " ");
               }
           }
         #+end_src
         - ~@Override~ tag         
      - Non-override (overload)
        #+begin_src java :classname 
          public static void peek(List61B<String> list) {
              System.out.println(list.getLast());
          }
          public static void peek(SLList<String> list) {
              System.out.println(list.getFirst());
          }
        #+end_src
        #+begin_src java :classname 
          SLList<String> SP = new SLList<String>();
          List61B<String> LP = SP;
          SP.addLast("elk");
          SP.addLast("are");
          SP.addLast("cool");
          peek(SP);
          peek(LP);
        #+end_src
        - ~peek(SP)~ runs the second ~peek~ while ~peek(LP)~ runs the first
*** Interface Inheritance vs Implementation Inheritance
    - Interface Inheritance (*what*): Simply tells *what* the subclasses should be able to do.
    - Implementation inheritance (*how*): Tells the subclasses *how* they should behave.
    - Common: "is-a" not "has-a"
*** Question:                                                     :QUESTIONS:
    - [ ] 这小节是不是搞错了？不是 interface inheritance 是 has-a 而 implementation(class) inheritance 是 is-a 的关系吗？这两者与公有继承和私有继承有什么关系？
** Extends, Casting, Higher Order Function
*** Extends
    - ~RotatingSLList~ 
      #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/list_subclasses.png @ 2019-08-10 09:28:03
      [[file:pictures/4._Inheritance,_Implements/list_subclasses_2019-08-10_09-28-03.png]]
      #+begin_src java :classname 
        public class RotatingSLList<Item> extends SLList<Item> {
            public void rotateRight() {
                Item x = removeLast();
                addFirst(x);
            }
        }
      #+end_src 
      - By using ~extends~:
        - Subclasses inherit all instance and static *variables*, all *methods* and all *nested classes* of superclasses.
        - *Constructors* are not inherited, and *private* members cannot be *directly accessed* by subclasses.
    - ~VengefulSLList~
       #+begin_src java :classname 
         public class VengefulSLList<Item> extends SLList<Item> {
             SLList<Item> deletedItems;

             public VengefulSLList() {
                 super();
                 deletedItems = new SLList<Item>();
             }

             @Override
             public Item removeLast() {
                 Item x = super.removeLast();
                 deletedItems.addLast(x);
                 return x;
             }

             /** Prints deleted items. */
             public void printLostItems() {
                 deletedItems.print();
             }
         }
       #+end_src
      - ~super~ to call *overridden methods and constructors* defined in the *superclass*: ~Item x = super.removeLast();~
      - Constructor is not inherited, using ~super(paras)~ to make an *explicit call* to the *correct* superclass's constructor, while *implicit call* as just ~deletedItems = new SLList<Item>();~ would only call to superclass's *no-argument constructor*
        #+begin_src java :classname 
          public VengefulSLList(Item x) {
              super(x);
              deletedItems = new SLList<Item>();
          }

          public VengefulSLList() {
              super();
              deletedItems = new SLList<Item>();
          }
        #+end_src
        - ~super(x)~ explicitly calls ~SLList(Item x)~
        - ~super()~ explicitly calls ~SLList()~ 
    - The /Object/ Class
      Every class in Java ~extends~ the /Object/ class: /VengefulSLList/ ~extends~ /SLList/ *explicitly*, while /SLList/ ~extends~ /Object/ *implicitly*
*** Encapsulation
    The root of encapsulation lies in this notion of hiding information from the outside, abstracting away the complexity inside.
    - Inheritance may break encapsulation
      - 2 ~bark~ method for class ~Dog~ 
        #+begin_src java :classname 
          public void bark() {
              System.out.println("bark");
          }
  
          public void barkMany(int N) {
              for (int i = 0; i < N; i += 1) {
                  bark();
              }
          }
        #+end_src
        #+begin_src java :classname 
          public void bark() {
              barkMany(1);
          }
  
          public void barkMany(int N) {
              for (int i = 0; i < N; i += 1) {
                  System.out.println("bark");
              }
          }
        #+end_src
      - ~VerboseDog~ inherits ~Dog~ 
        #+begin_src java :classname 
          @Override
          public void barkMany(int N) {
              System.out.println("As a dog, I say: ");
              for (int i = 0; i < N; i += 1) {
                  bark();
              }
          }
        #+end_src
        - Second ~bark~ lead to infinite loop when ~VerbodeDog.barkMany(n)~ is called, encapsulation is broken
*** Type Checking and Casting
    - Type Checking
      #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/dynamic_selection.png @ 2019-08-10 18:43:46
      [[file:pictures/4._Inheritance,_Implements/dynamic_selection_2019-08-10_18-43-46.png]]
      - ~sl.printLostItems();~ and ~VengefulSLList<Integer> vsl2 = sl;~ both result in *compile-time error*
      - In general, the compiler only allows *method calls* and *assignments* based on *compile-time* types (*declared* type)
    - Casting
      Telling the compiler to view an expression as a *different compile-time* type.
      #+begin_src java :classname 
        public static Dog maxDog(Dog d1, Dog d2) { ... }
      #+end_src
      #+begin_src java :classname 
        Poodle frank = new Poodle("Frank", 5);
        Poodle frankJr = new Poodle("Frank Jr.", 15);

        Dog largerDog = maxDog(frank, frankJr);
        Poodle largerPoodle = maxDog(frank, frankJr); //does not compile! RHS has compile-time type Dog
        Poodle largerPoodle = (Poodle) maxDog(frank, frankJr); // compiles! Right hand side has compile-time type Poodle after casting
      #+end_src
      - Casting allows to pass at *compile-time*: ~Poodle largerPoodle = (Poodle) maxDog(frank, frankJr);~, and this code won't raise exception at *run-time* due to ~frank~ and ~frankJr~ are both ~Poodle~
      - Casting may raise ~ClassCastException~ at *run-time*
        #+begin_src java :classname 
          Poodle frank = new Poodle("Frank", 5);
          Malamute frankSr = new Malamute("Frank Sr.", 100);

          Poodle largerPoodle = (Poodle) maxDog(frank, frankSr); // runtime exception when frankSr (Malamute can't be casted to Poodle)
        #+end_src
        - Casting allows to pass ~Poodle largerPoodle = (Poodle) maxDog(frank, frankSr);~ at *compile-time* 
        - ~ClassCastException~ raised at *run-time* when ~frankSr~ returned: ~Malamute~ can't be casted to ~Poodle~ 
*** Higher Order Functions
    Using *interface inheritance* to define higher order functions
    #+begin_src java :classname 
      public interface IntUnaryFunction {
          int apply(int x);
      }
    #+end_src 
    #+begin_src java :classname 
      public class TenX implements IntUnaryFunction {
          /* Returns ten times the argument. */
          public int apply(int x) {
              return 10 * x;
          }
      }
    #+end_src 
    #+begin_src java :classname 
      public class HoFDemo {
          public static int do_twice(IntUnaryFunction f, int x) {
              return f.apply(f.apply(x));
          }

          public static void main(String[] args) {
              System.out.println(do_twice(new Tenx(), 2));
          }
      }
    #+end_src 
    ~System.out.println(do_twice(new TenX(), 2));~ 
** Subtype Polymorphism vs. HOFs
*** Subtype Polymorphism
    *Polymorphism* refers to how *objects* can have many *forms or types* in Java
    - Explicit HoF Approach
      #+begin_src python :results output
        def print_larger(x, y, compare, stringify):
            if compare(x, y):
                return stringify(x)
            return stringify(y)
      #+end_src
      - A common way to print out the larger of two objects
    - Subtype Polymorphism Approach
      #+begin_src python :results output
        def print_larger(x, y):
            if x.largerThan(y):
                return x.str()
            return y.str()
      #+end_src
      - Object itself makes the choices. The ~largerFunction~ that is called is *dependent* on what ~x~ and ~y~ actually are.
*** Max Function
    - ~max~ function
      #+begin_src java :classname 
        public static Object max(Object[] items) {
            int maxDex = 0;
            for (int i = 0; i < items.length; i += 1) {
                if (items[i] > items[maxDex]) {
                    maxDex = i;
                }
            }
            return items[maxDex];
        }

        public static void main(String[] args) {
            Dog[] dogs = {new Dog("Elyse", 3), new Dog("Sture", 9), new Dog("Benjamin", 15)};
            Dog maxDog = (Dog) max(dogs);
            maxDog.bark();
      #+end_src
      - ~items[i] > items[maxDex]~ raises error as ~>~ doesn't work with arbitrary Object types
      - Java can't redefine ~>~ operator
    - ~maxDog~ function in the ~Dog~ class
      #+begin_src java :classname 
        public static Dog maxDog(Dog[] dogs) {
            if (dogs == null || dogs.length == 0) {
                return null;
            }
            Dog maxDog = dogs[0];
            for (Dog d : dogs) {
                if (d.size > maxDog.size) {
                    maxDog = d;
                }
            }
            return maxDog;
        }
      #+end_src
      - Can't be generalized to other class (~Birds~ ...) 
    - Use interface inheritance to generalized ~max~ func
      #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/dog_comparable.png @ 2019-08-11 10:11:54
      [[file:pictures/4._Inheritance,_Implements/dog_comparable_2019-08-11_10-11-54.png]]
      #+begin_src java :classname 
        public interface OurComparable {
            public int compareTo(Object o);
        }
      #+end_src
      - ~Object o~ can be implemented by all *Objects*  
      #+begin_src java :classname 
        public class Dog implements OurComparable {
            private String name;
            private int size;

            public Dog(String n, int s) {
                name = n;
                size = s;
            }

            public void bark() {
                System.out.println(name + " says: bark");
            }

            public int compareTo(Object o) {
                Dog uddaDog = (Dog) o;
                return this.size - uddaDog.size;
            }
        }
      #+end_src
      - ~(Dog) o~ to cast from ~Object~ to ~Dog~ 
      #+begin_src java :classname 
        public static OurComparable max(OurComparable[] items) {
            int maxDex = 0;
            for (int i = 0; i < items.length; i += 1) {
                int cmp = items[i].compareTo(items[maxDex]);
                if (cmp > 0) {
                    maxDex = i;
                }
            }
            return items[maxDex];
        }
      #+end_src
      - ~items[i].compareTo(items[maxDex]);~ 
    - Interfaces Quiz
        #+begin_src java :classname 
          public class DogLauncher {
              public static void main(String[] args) {
                  ...
                  Dog[] dogs = new Dog[]{d1, d2, d3};
                  System.out.println(Maximizer.max(dogs));
              }
          }

          public class Dog implements OurComparable {
              ...
              public int compareTo(Object o) {
                  Dog uddaDog = (Dog) o;
                  if (this.size < uddaDog.size) {
                      return -1;
                  } else if (this.size == uddaDog.size) {
                      return 0;
                  }
                  return 1;
              }
              ...
          }

          public class Maximizer {
              public static OurComparable max(OurComparable[] items) {
                  ...
                  int cmp = items[i].compareTo(items[maxDex]);
                  ...
                      }
          }
        #+end_src
      - If omitting the ~compareTo()~ method from the ~Dog~ class -> ~Dog~ class fails to compile as it doen't implement ~compareTo~
      - If omitting ~implements OurComparable~ from the ~Dog~ class header -> ~DogLauncher~ class fails to compile due to ~System.out.println(Maximizer.max(dogs));~, cause ~max~ only accepts an array of ~OurComparable~ objects, not ~Dog~
      - ~Maximizer~ operates at a higher level of abstraction, it should pass compile
*** Comparable
    #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/comparable_interface.png @ 2019-08-11 11:11:02
    [[file:pictures/4._Inheritance,_Implements/comparable_interface_2019-08-11_11-11-02.png]]
    #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/comparable.png @ 2019-08-11 11:12:01
    [[file:pictures/4._Inheritance,_Implements/comparable_2019-08-11_11-12-01.png]]
    #+begin_src java :classname 
      public class Dog implements Comparable<Dog> {
          ...
          public int compareTo(Dog uddaDog) {
              return this.size - uddaDog.size;
          }
      }
    #+end_src
    - ~Comparable<T>~ -> ~public class Dog implements Comparable<Dog>~ : built-in interface ~Comparable~ takes a *generic type* ~<T>~ , which avoids casting.
*** Comparator
    #+begin_src java :classname 
      public interface Comparator<T> {
          int compare(T o1, T o2);
      }
    #+end_src
    #+begin_src java :classname 
      import java.util.Comparator;

      public class Dog implements Comparable<Dog> { <<elink5>>
          ...
          public int compareTo(Dog uddaDog) {
              return this.size - uddaDog.size;
          }

          private static class NameComparator implements Comparator<Dog> {
              public int compare(Dog a, Dog b) {
                  return a.name.compareTo(b.name);
              }
          }

          public static Comparator<Dog> getNameComparator() {
              return new NameComparator();
          }
      }
    #+end_src
    #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/comparator.png @ 2019-08-11 13:35:10
    [[file:pictures/4._Inheritance,_Implements/comparator_2019-08-11_13-35-10.png]]
    - ~Comparable~ used to compare Objects in natural order, ~Comparator~ used to compare in other user-defined order
    - About nested ~private static class NameComparator implements Comparator<Dog>~ <<ilink2>>
      - ~Dog~ can only implements just one interface ~Comparable~
      - ~Comparator~ is used to augment comparison order 
      - *Nested* because each ~class~ implements ~Comparator<T>~ can only compare 2 objects of class ~T~, it should be *nested* in ~class T~ according to *OOP*
      - Each comparator is an *object*, not *class or method* (In Java7 or earlier, can't take in or return *class or method*)
      - ~static~ for no need to instantiate a ~Dog~ object, just ~Dog.NameComparator()~ to get a comparator
      - ~private~ just for convention: ~Dog.NameComparator()~ -> ~Dog.getNameComparator()~ 
    - To retrieve *NameComparator*: ~Comparator<Dog> nc = Dog.getNameComparator();~
    - Use *NameComparator* to compare 2 ~Dog~ objects: ~nc.compare(dog1, dog2);~
    - ~String~'s built-in ~compareTo~
*** To summarize <<ilink1>> <<elink13>>
    - *Interfaces* in Java provide the ability to make *callbacks*. A *callback* function is the *helping* function (in the scenario, ~compareTo~). In some languages, this is accomplished using *explicit function passing*; in Java, by *wrapping* the *needed function* in an *interface*.
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-11 14:23:33
      [[file:pictures/4._Inheritance,_Implements/screenshot_2019-08-11_14-23-33.png]]
    - *Comparable* is an *attribute of objects*, object can compare itself to another object of the same class if it is *Comparable*.
    - *Comparator* is an *independent object* compares 2 *Comparable objects* to each other, its class is *defined within the class* and it's *independent of Comparable object*
*** Question:                                                     :QUESTIONS:
    1. [[ilink2]] 中关于 nested 原因的分析对吗？为什么 Comparator 一定要是 Object？如下可以吗？
       #+begin_src java :classname 
         import java.util.Comparator;

         public class Dog implements Comparable<Dog> {
             ...
             public int compareTo(Dog uddaDog) {
                 return this.size - uddaDog.size;
             }

             public static class NameComparator implements Comparator<Dog> {
                 public static int compare(Dog a, Dog b) {
                     return a.name.compareTo(b.name);
                 }
             }

         }
       #+end_src
       需要比较时直接 ~Dog.NameComparator.compare(dog1, dog2)~ 。
    2. Comparator 不还是需要为每一种比较策略定义一个 nexted class 以及一个 getcomparator() ？这样做的意义？
    3. Java8 之后是怎么显式传递函数作为参数或者把函数作为返回值？
** Java libraries and packages                                :UNCOVERED:
* 5 Generics and Autoboxing                                :UNCOVERED:SLIDE:
* 6 Exceptions, Iterators, Iterables, Object Methods                 :SLIDE:
** Lists, Sets, ArraySet 
*** Lists in Real Java Code
    #+begin_src java :classname 
      import java.util.List;
      import java.util.ArrayList;

      public class Example {
          public static void main(String[] args) {
              List<Integer> L = new ArrayList<>();
              L.add(5);
              L.add(10);
              System.out.println(L);
          }
      }
    #+end_src 
*** Sets
    - Java
      #+begin_src java :classname 
        import java.util.Set;
        import java.util.HashSet;
  
        Set<String> s = new HashSet<>();
        s.add("Tokyo");
        s.add("Lagos");
        System.out.println(S.contains("Tokyo")); // true
      #+end_src
    - Python
      #+begin_src python :results output
        s = set()
        s.add("Tokyo")
        s.add("Lagos")
        print("Tokyo" in s) // True
      #+end_src 
*** ArraySet
    #+begin_src java :classname 
      import java.util.Iterator;

      public class ArraySet<T> implements Iterable<T> {
          private T[] items;
          private int size; // the next item to be added will be at position size

          public ArraySet() {
              items = (T[]) new Object[100];
              size = 0;
          }

          /* Returns true if this map contains a mapping for the specified key.
           ,*/
          public boolean contains(T x) {
              for (int i = 0; i < size; i += 1) {
                  if (items[i].equals(x)) {
                      return true;
                  }
              }
              return false;
          }

          /* Associates the specified value with the specified key in this map. */
          public void add(T x) {
              if (contains(x)) {
                  return;
              }
              items[size] = x;
              size += 1;
          }

          /* Returns the number of key-value mappings in this map. */
          public int size() {
              return size;
          }
      }
    #+end_src 
    - ~items = (T[]) new Object[100];~
    - ~items[i].equals(x)~ 
** Throwing Exceptions 
   Throw an *exception* when a user tries to add ~null~ to ~ArraySet~: ~throw new ExceptionObject(parameter1, ...)~ 
   #+begin_src java :classname 
     /* Associates the specified value with the specified key in this map.
        Throws an IllegalArgumentException if the key is null. */
     public void add(T x) {
         if (x == null) {
             throw new IllegalArgumentException("can't add null");
         }
         if (contains(x)) {
             return;
         }
         items[size] = x;
         size += 1;
     }
   #+end_src 
   - ~null.equals(x)~ causes ~NullPointerException~, use ~x == null~ 
   - ~throw new IllegalArgumentException("can't add null");~
   - Built-in set of strings cancontain a ~null~ in Java, below prints ~True~ 
     #+begin_src java :classname 
       Set<String> s = new HashSet<>();
       s.add(null);
       System.out.println(s.contains(null));
     #+end_src 
** Iteration <<elink2>>
*** Enhanced For Loop
    #+begin_src java :classname 
      Set<String> s = new HashSet<>();
      Set<String> s = new HashSet<>();
      s.add("Tokyo");
      s.add("Lagos");
      for (String city : s) {
          System.out.println(city);
      }
    #+end_src 
    - Java knows that ~HashSet~ has a ~iterator()~ method
    - ~ArraySet~ raises error because Java thinks it doesn't have an ~iterator()~ method
      - To enable ~ArraySet~ *enhanced loop*
        1. ~ArraySet~ need to have an ~iterator()~ method
        2. ~ArraySet~ need to tell Java that it has an ~iterator()~ method
    - Use ~iterator()~ method to a *ugly loop*
      #+begin_src java :classname 
        Set<String> s = new HashSet<>();
        ...
        Iterator<String> seer = s.iterator();
        while (seer.hasNext()) {
            String city = seer.next();
            ...
        }
      #+end_src
      - *Ugly loop* doesn't need to tell Java that ~iterator()~ method exists
*** Implementing Iterators
    - Skeleton for ~ArrayList~ 
      The compiler need to confirm
      - ~ArrayList~ class has an ~iterator()~ method and Java knows it
        #+begin_src java :classname 
          public interface Iterable<T> {
              Iterator<T> iterator();
          }
        #+end_src
        #+begin_src java :classname 
          public interface List<T> extends Iterable<T> {
              ...
          }
        #+end_src
        #+begin_src java :classname 
          public class ArrayList<T> implements List<T> {
              ...
              public Iterator<T> iterator() {
                  ...
              }
          }
        #+end_src
        - ~public interface List<T> extends Iterable<T>~ and ~public class ArrayList<T> implements List<T>~ -> class ~ArrayList~ has an ~iterator()~ method and Java knows it: ~public Iterator<T> iterator()~ 
      - ~Iterator~ interface have ~hasNext()~ and ~next()~
          #+begin_src java :classname 
            public interface Iterator<T> {
                boolean hasNext();
                T next();
            }
          #+end_src
          #+begin_src java :classname 
            private class ArrayListIterator<T> implements Iterator<T> {
                public boolean hasNext() {
                    ...
                }
                public T next() {
                    ...
                }
                ...
            }
          #+end_src
        - ~ArrayListIterator<T>~ is a nested class of ~ArrayList<T>~ 
    - Full edition for ~ArraySet~ 
      #+begin_src java :classname 
        import java.util.Iterator;
  
        public class ArraySet<T> implements Iterable<T> {
            private T[] items;
            private int size; // the next item to be added will be at position size
  
            public ArraySet() {
                items = (T[]) new Object[100];
                size = 0;
            }
  
            /* Returns true if this map contains a mapping for the specified key.
             ,*/
            public boolean contains(T x) {
                for (int i = 0; i < size; i += 1) {
                    if (items[i].equals(x)) {
                        return true;
                    }
                }
                return false;
            }
  
            /* Associates the specified value with the specified key in this map.
               Throws an IllegalArgumentException if the key is null. */
            public void add(T x) {
                if (x == null) {
                    throw new IllegalArgumentException("can't add null");
                }
                if (contains(x)) {
                    return;
                }
                items[size] = x;
                size += 1;
            }
  
            /* Returns the number of key-value mappings in this map. */
            public int size() {
                return size;
            }
  
            /** returns an iterator (a.k.a. seer) into ME */
            public Iterator<T> iterator() {
                return new ArraySetIterator();
            }
  
            private class ArraySetIterator implements Iterator<T> {
                private int wizPos;
  
                public ArraySetIterator() {
                    wizPos = 0;
                }
  
                public boolean hasNext() {
                    return wizPos < size;
                }
  
                public T next() {
                    T returnItem = items[wizPos];
                    wizPos += 1;
                    return returnItem;
                }
            }
  
            public static void main(String[] args) {
                ArraySet<Integer> aset = new ArraySet<>();
                aset.add(5);
                aset.add(23);
                aset.add(42);
  
                //iteration
                for (int i : aset) {
                    System.out.println(i);
                }
            }
  
        }
      #+end_src
      - ~public Iterator<T> iterator()~ and ~private class ArraySetIterator implements Iterator<T>~ make ~ArraySet~ can use *ugly loop*
      - ~public class ArraySet<T> implements Iterable<T>~ tells Java that ~ArraySet~ has a ~iterator()~ method, then can ~ArraySet~ use *enhanced loop* (~for (ArraySet<Integer> asee : aset) {}~)
    - ~Comparable~ vs ~Comparator~ and ~Iterable~ vs ~Iterator~ <<elink1>>
      - ~Comparable~ has method ~comparator()~ which returns a ~Comparator~ object, ~Iterable~ is similar.
      - ~Comparable~ and ~Iterable~ are interfaces implemented by classes, describing a kind of classes' *attribute* (*comparable* and *iterable*)
      - ~Comparator~ and ~Iterator~ are *nested classes* inside classes which implement ~Comparable~ and ~Iterable~, instances of them are objects whose methods can take in ~Comparable~ and ~Iterable~ objects as arguments
** Object Methods
   All classes inherit from the overarching Object class. The methods that are inherited are as follows:
   - ~String toString()~
   - ~boolean equals(Object obj)~
   - ~Class <?> getClass()~
   - ~int hashCode()~
   - ~protected Objectclone()~
   - ~protected void finalize()~
   - ~void notify()~
   - ~void notifyAll()~
   - ~void wait()~
   - ~void wait(long timeout)~
   - ~void wait(long timeout, int nanos)~
*** toString() <<elink12>>
    The ~toString()~ method provides a string representation of an object.
    - ~System.out.println(dog)~
      #+begin_src java :classname 
        String s = dog.toString()
        System.out.println(s)
      #+end_src
    - The default ~Object~ class' ~toString()~ method prints the *location* of the object in *memory* (hexidecimal string)
      - Classes like ~Arraylist~ and ~Array~ have their own *overridden* versions of the ~toString()~ method
      - Override ~toString()~ in ~ArraySet~ 
        #+begin_src java :classname 
          import java.util.Iterator;

          public class ArraySet<T> implements Iterable<T> {
              ...

              @Override
              public String toString() {
                  String returnString = "{";
                  for (int i = 0; i < size; i += 1) {
                      returnString += keys[i];
                      returnString += ", ";
                  }
                  returnString += "}";
                  return returnString;
              }

              @Override
              public String toString() {
                  StringBuilder returnSB = new StringBuilder("{");
                  for (int i = 0; i < size - 1; i += 1) {
                      returnSB.append(items[i].toString());
                      returnSB.append(", ");
                  }
                  returnSB.append(items[size - 1]);
                  returnSB.append("}");
                  return returnSB.toString();
                  /* hmmm */
              }

              @Override
              public String toString() {
                  List<String> listOfItems = new ArrayList<>();
                  for (T x : this) {
                      listOfItems.add(x.toString());
                  }
                  return "{" + String.join(", ", listOfItems) + "}";
              }

              public static void main(String[] args) {
                  ArraySet<Integer> aset = new ArraySet<>();
                  aset.add(5);
                  aset.add(23);
                  aset.add(42);

                  //toString
                  System.out.println(aset);
          }
        #+end_src
        - Use ~String~
          - ~returnString += keys[i]~ *creates an entirely new string* first and then appends to ~returnString~, which is incredibly inefficient -> use ~StringBuilder~
          - Say concatenating one character to a string takes 1 second, then ~toString({1, 2, 3, 4, 5})~ takes ~1 + 2 + 3 + 4 + ... + 11~ seconds
        - Use ~StringBuilder~ whose objects are *mutable*: ~append~ instead of ~+=~ 
          - ~StringBuilder returnSB = new StringBuilder("{")~
          - ~returnSB.append(items[i].toString())~
          - ~return returnSB.toString()~ 
        - Use ~List<String>~
          - ~List<String> listOfItems = new ArrayList<>()~
          - ~for (T x : this) {listOfItems.add(x.toString());}~
          - ~String.join(", ", listOfItems)~ 
**** Question:                                                    :QUESTIONS:
     1. 当 ~ArraySet<T>~ 中的 ~T~ 仍为 ~ArraySet~ 时，以上定义的 ~toString()~ 还能正常工作吗？是不是 ~T~ 只能为 *primitive type* ？如果可以，怎么实现 ~T~ 为 *reference type* 呢？
     2. ~toString({1, 2, 3, 4, 5})~ 的分析对吗？为什么书上只有 ~1 + ... + 7~ ？
*** equals()
    ~equals()~ and ~==~ have different behaviors in Java. ~==~ Checks if two *objects* are actually the *same object in memory* (if *two boxes* hold the same thing)
    - The default ~Object~ class' ~equals(Object o)~ acts like ~==~ in that it checks if the *memory address* of the ~this~ is the same as ~o~
      - Override ~equals()~ in ~ArraySet~ 
        #+begin_src java :classname 
          import java.util.Iterator;

          public class ArraySet<T> implements Iterable<T> {
              ...
              @Override
              public boolean equals(Object other) {
                  if (this == other) {
                      return true;
                  }
                  if (other == null) {
                      return false;
                  }
                  if (other.getClass() != this.getClass()) {
                      return false;
                  }
                  ArraySet<T> o = (ArraySet<T>) other;
                  if (o.size() != this.size()) {
                      return false;
                  }
                  for (T item : this) {
                      if (!o.contains(item)) {
                          return false;
                      }
                  }
                  return true;
              }

              public static void main(String[] args) {
                  //equals
                  ArraySet<Integer> aset2 = new ArraySet<>();
                  aset2.add(5);
                  aset2.add(23);
                  aset2.add(42);

                  System.out.println(aset.equals(aset2));
                  System.out.println(aset.equals(null));
                  System.out.println(aset.equals("fish"));
                  System.out.println(aset.equals(aset));

                  //EXTRA VIDEO CODE
                  //ArraySet<String> asetOfStrings = ArraySet.of("hi", "I'm", "here");
                  //System.out.println(asetOfStrings);
              }

          }
        #+end_src
        - ~public boolean equals(Object other)~ not ~public boolean equals(ArraySet<T> other)~ 
        - ~other.getClass() != this.getClass()~
        - ~ArraySet<T> o = (ArraySet<T>) other~ to cast ~Object~ to ~ArraySet<T>~ 
        - Rules for Equals in Java
          - ~equals~ must be an *equivalence* relation
            - *reflexive*: ~x.equals(x)~ is ~true~
            - *symmetric*: ~x.equals(y)~ if and only if *y.equals(x)*
            - *transitive*: ~x.equals(y)~ and ~y.equals(z)~ implies ~x.equals(z)~
          - It must take an ~Object~ argument, in order to *override* the original ~.equals(Object o)~ method.
          - It must be *consistent* if ~x.equals(y)~, then as long as ~x~ and ~y~ remain unchanged: ~x~ must continue to equal ~y~
          - It is never ~true~ for ~null~, ~x.equals(null)~ must be ~false~
*** of()
    #+begin_src java :classname 
      import java.util.Iterator;

      public class ArraySet<Glerp> implements Iterable<Glerp> {
          ...
          public static <Glerp> ArraySet<Glerp> of(Glerp... stuff) {
              ArraySet<Glerp> returnSet = new ArraySet<Glerp>();
              for (Glerp x : stuff) {
                  returnSet.add(x);
              }
              return returnSet;
          }

          public static void main(String[] args) {
              ArraySet<String> asetOfStrings = ArraySet.of("hi", "I'm", "here");
              System.out.println(asetOfStrings);
          }

      }
    #+end_src 
    - ~public static <Glerp> ArraySet<Glerp> of(Glerp... stuff)~ not ~public static ArraySet<T> of(T... stuff)~ because of it is ~static~, it can't find ~T~ in ~public class ArraySet<T> implements Iterable<T>~
    - ~ArraySet<Glerp> returnSet = new ArraySet<Glerp>()~
    - ~ArraySet<String> asetOfStrings = ArraySet.of("hi", "I'm", "here")~ 
** Throwing Exceptions (legacy)                                   :UNCOVERED:
** Checked vs. Unchecked exception (legacy)                       :UNCOVERED:
** Iteration (legacy)                                             :UNCOVERED:
* 7 Packages and Access Control                            :UNCOVERED:SLIDE:
* 8 Efficient Programming                                            :SLIDE:
** Encapsulation, API's, ADT's
*** Encapsulation
    - Module: *A set of methods* that work together *as a whole* to perform some task or set of related tasks.
    - Encapsulated: A module is said to be encapsulated if its *implementation is completely hidden*, and it can be accessed only through *a documented interface*.
*** API's
    An API(Application Programming Interface) of an ADT is the list of *constructors and methods* and a short description of each.
    API consists of syntactic and semantic specification.
    - Compiler verifies that syntax is met.
    - Tests help verify that semantics are correct.
*** ADT's
    ADT's (Abstract Data Structures) are high-level types that are defined by their *behaviors*, not their *implementations*.
    - Delegation vs Extension: Write a *Stack* class using a *Linked List* as its underlying data structure <<ilink12>>
      - Extension: inheriting from parent class
        #+begin_src java :classname 
          public class ExtensionStack<Item> extends LinkedList<Item> {
              public void push(Item x) {
                  add(x);
              }
          }
        #+end_src
      - Delegation: delegating another class to perform some actions
        #+begin_src java :classname 
          public class DelegationStack<Item> {
              private LinkedList<Item> L = new LinkedList<Item>();
              public void push(Item x) {
                  L.add(x);
              }
          }
        #+end_src
        #+begin_src java :classname 
          public class StackAdapter<Item> {
              private List L;
              public StackAdapter(List<Item> worker) {
                  L = worker;
              }

              public void push(Item x) {
                  L.add(x);
              }
          }
        #+end_src
        - Can use *any class* that implements the *List* interface (LinkedList, ArrayList, etc).
    - View: Use ~subList(a, b)~ to reverse only part of the list
      Views are an alternative representation of an *existed object*. Views essentially *limit the access* to the underlying object but *mutate* the underlying object
      #+begin_src java :classname 
        public class List<T> {
            ...
            public List<Item> sublist(int start, int end) {
                return new this.Sublist(start,end);
            }

            private class Sublist extends AbstractList<Item>{
                private int start, end;
                public Sublist(inst start, int end) {...}
                public T get(int k) {return AbstractList.this.get(start+k);}
                public void add(int k, T x) {AbstractList.this.add(start+k, x); end+=1;}
            }
        }
      #+end_src
      #+begin_src java :classname 
        /** Create an ArrayList. */
        List<String> L = new ArrayList<>();
        /** Add some items. */
        L.add(“at”);
        L.add(“ax”);
        ...

        List<String> SL = L.subList(1, 3);
        SL.reverse();
      #+end_src
      #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/reverse_list1.png @ 2019-08-19 09:37:17
      [[file:pictures/8._Efficient_Programming/reverse_list1_2019-08-19_09-37-17.png]]
      #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/reverse_list2.png @ 2019-08-19 09:37:39
      [[file:pictures/8._Efficient_Programming/reverse_list2_2019-08-19_09-37-39.png]]
**** Question:                                                    :QUESTIONS:
     - [ ] [[ilink12][Stack]] 实现？ <<elink3>>
** Asymptotics I
*** $\Theta$ is a *tight bound*, including *upper and lower bound* correspond to *worst and best case* (can be reached)
    $R(N) \in \Theta(f(N))$ means that there exists positive constants $k_{1}, k_{2}$ such that:
    $k_{1} \cdot f(N) \leq R(N) \leq k_{2} \cdot f(N)$ ,  for all values of $N$ greater than some $N_{0}$
*** $O$ is just an *upper bound*, it is not the same but often used as *worst case* (may not be able to reach) 
    $R(N) \in O(f(N))$ means that there exists positive constants $k$ such that:
    $R(N) \leq k \cdot f(N)$ ,  for all values of $N$ greater than some $N_{0}$
** Asymptotics II
*** Loop
    #+begin_src java :classname 
      int N = A.length;
      for (int i = 0; i < N; i += 1)
          for (int j = i + 1; j < N; j += 1)
              if (A[i] == A[j])
                  return true;
      return false;
    #+end_src 
    - $\theta\left(N^{2}\right)$
    #+begin_src java :classname 
      public static void printParty(int N) {
          for (int i = 1; i <= N; i = i * 2) {
              for (int j = 0; j < i; j += 1) {
                  System.out.println("hello");   
                  int ZUG = 1 + 1;
              }
          }
      }
    #+end_src 
    - $C(N)=1+2+4+\ldots+N=2 N-1$ (if N is a power of 2)
    - Runtime (by definition) must also be *linear*
      #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/loops2_graph2.png @ 2019-08-19 15:09:42
      [[file:pictures/8._Efficient_Programming/loops2_graph2_2019-08-19_15-09-42.png]]
*** Recursion
    #+begin_src java :classname 
      public static int f3(int n) {
          if (n <= 1) 
              return 1;
          return f3(n-1) + f3(n-1);
      }
    #+end_src 
    - $\theta\left(2^{N}\right)$
*** Binary Search: $\theta\left(\log _{2}(n)\right)$
*** Merge Sort: $\theta\left(n \log _{2}(n)\right)$
** Omega and Amortized Analysis (extra)
*** $\Omega$ is just an *lower bound*, it is not the same but often used as *best case* (may not be able to reach) 
    $R(N) \in \Omega(f(N))$ means that there exists positive constants $k$ such that:
    $R(N) \ge k \cdot f(N)$ ,  for all values of $N$ greater than some $N_{0}$
    1. Used to prove $\Theta$ : $R(N)=O(f(N))$ and $R(N)=\Omega(f(N))$ -> $R(N)=\Theta(f(N))$
    2. Used to prove the difficulty of a problem.
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 13:56:31
    [[file:pictures/8._Efficient_Programming/screenshot_2019-08-20_13-56-31.png]]
*** Amortized Analysis (Rigurous Explanation) 
    For length-1 *ArrayList*, 
    - Cost model: only consider array reads and writes
    - Compute the cost of a sequence of array adds and their average (*amortized*) cost
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 15:18:53
      [[file:pictures/8._Efficient_Programming/screenshot_2019-08-20_15-18-53.png]]
      \begin{aligned} S(N)=1+(2\times1+1)+(2\times2+1)+1+...+a_{N-1}+a_{N}=\frac{(1+2+...+2^{\lfloor log_{2}^N \rfloor})\times2+\lfloor log_{2}^N \rfloor+1+N-(\lfloor log_{2}^N \rfloor+1)}{N}=\frac{4\times2^{\lfloor log_{2}^N \rfloor}+N}{N} \end{aligned}
      \begin{aligned} \lim_{n \to \infty}S(N) = \lim_{n \to \infty} \frac{4\times2^{\lfloor log_{2}^N \rfloor}+N}{N} \leq 5\end{aligned}
    - Average (*amortized*) cost is bounded by 5
**** Question:                                                    :QUESTIONS:
     1. 怎么理解 amortized ？怎么翻译，直观上理解？
* 9 Disjoint Sets                                                    :SLIDE:
  #+begin_src java :classname 
    public interface DisjointSets {
        /** connects two items P and Q */
        void connect(int p, int q);

        /** checks to see if two items are connected */
        boolean isConnected(int p, int q); 
    }
  #+end_src 
** Quick Find
*** ListOfsets: ~List<Set<Integer>>~ like ~[{0}, {1}, {2}, {3}, {4}, {5}, {6}]~
*** QuickFind
    - The *indices* of the array represent the *elements* of the set.
    - The *value* at an index is the *set number* it belongs to.
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 09:41:37
    [[file:pictures/9._Disjoint_Sets/screenshot_2019-08-20_09-41-37.png]]
    #+begin_src java :classname 
      public class QuickFindDS implements DisjointSets {
  
          private int[] id;
  
          /* Θ(N) */
          public QuickFindDS(int N){
              id = new int[N];
              for (int i = 0; i < N; i++){
                  id[i] = i;
              }
          }
  
          /* need to iterate through the array => Θ(N) */
          public void connect(int p, int q){
              int pid = id[p];
              int qid = id[q];
              for (int i = 0; i < id.length; i++){
                  if (id[i] == pid){
                      id[i] = qid;
                  }
              }
          }
  
          /* Θ(1) */
          public boolean isConnected(int p, int q){
              return (id[p] == id[q]);
          }
      }
    #+end_src 
    - ~connect~ too slow, unpractical
*** Summary
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 09:11:19
    [[file:pictures/9._Disjoint_Sets/screenshot_2019-08-20_09-11-19.png]]
** Quick Union
   Instead of an id, assign each item *the index of its parent*. -1 for no parent *'root'* items
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 09:42:13
   [[file:pictures/9._Disjoint_Sets/screenshot_2019-08-20_09-42-13.png]]
   #+begin_src java :classname 
     public class QuickUnionDS implements DisjointSets {
         private int[] parent;

         public QuickUnionDS(int num) {
             parent = new int[num];
             for (int i = 0; i < num; i++) {
                 parent[i] = i;
             }
         }

         private int find(int p) {
             while (parent[p] >= 0) {
                 p = parent[p];
             }
             return p;
         }

         @Override
         public void connect(int p, int q) {
             int i = find(p);
             int j= find(q);
             parent[i] = j;
         }

         @Override
         public boolean isConnected(int p, int q) {
             return find(p) == find(q);
         }
     }
   #+end_src 
   - Finding the root of an item (~find(item)~) becomes very expensive when the tree becomes too long
*** Summary
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 09:43:37
    [[file:pictures/9._Disjoint_Sets/screenshot_2019-08-20_09-43-37.png]]
** Weighted Quick Union (WQU)
   When calling ~connect~, always link the root of the *smaller weight* tree to the *larger weight* tree
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 09:58:30
   [[file:pictures/9._Disjoint_Sets/screenshot_2019-08-20_09-58-30.png]]
   - Option 2 is better
   - ~connect~ need to track the tree's weight: number of items in that tree
   - Maximum height = maximum ~connect~ times = runtime upper = $\Theta (log^N)$ (actually $log_{2}^N$ here)
*** Summary
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 10:11:29
    [[file:pictures/9._Disjoint_Sets/screenshot_2019-08-20_10-11-29.png]]
** WQU with Path Compression
   Connect all the items along ~find~ to the root when calling ~connect~ and ~isConnected~
*** Summary
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 10:40:49
    [[file:pictures/9._Disjoint_Sets/screenshot_2019-08-20_10-40-49.png]]
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 10:29:31
    [[file:pictures/9._Disjoint_Sets/screenshot_2019-08-20_10-29-31.png]]
    For M operations (~connect~ or ~isConnected~) on N elements
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 10:38:40
    [[file:pictures/9._Disjoint_Sets/screenshot_2019-08-20_10-38-40.png]]
    - $O(N+NM) = O((N+1)M) = O(NM)$ : *construction* + *actions* (~connect~ or ~isConnected~), similar for others
    - *Amortized runtime* and *iterated logarithm*: $\alpha(N)$ = $log^*(N)$ = constant in long term. ( $log^*(N) = 5$ for $N=2^{65536}$ )
* 10 ADTs                                                            :SLIDE:
  An Abstract Data Type (ADT) is defined only by its *operations*, not by its *implementation*
  #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 16:34:58
  [[file:pictures/10._ADTs/screenshot_2019-08-20_16-34-58.png]]
  #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 16:32:24
  [[file:pictures/10._ADTs/screenshot_2019-08-20_16-32-24.png]]
  - Interfaces are in white, classes are in blue.
** Binary Search Trees (BSTs)
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-20 16:59:28
   [[file:pictures/10._ADTs/screenshot_2019-08-20_16-59-28.png]]
   #+begin_src java :classname 
     private class BST<Key> {
         private Key key;
         private BST left;
         private BST right;

         public BST(Key key, BST left, BST Right) {
             this.key = key;
             this.left = left;
             this.right = right;
         }

         public BST(Key key) {
             this.key = key;
         }
     }
   #+end_src 
*** Operations
    - Search
      #+begin_src java :classname 
        static BST find(BST T, Key sk) {
            if (T == null)
                return null;
            if (sk.equals(T.key))
                return T;
            else if (sk ≺ T.key)
                return find(T.left, sk);
            else
                return find(T.right, sk);
        }
      #+end_src
    - Insert
      Always insert at a *leaf node*
      #+begin_src java :classname 
        static BST insert(BST T, Key ik) {
            if (T == null)
                return new BST(ik);
            if (ik ≺ T.key)
                T.left = insert(T.left, ik);
            else if (ik ≻ T.key)
                T.right = insert(T.right, ik);
            return T;
        }
      #+end_src
    - Delete
      Hibbard deletion
      - No children
        #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 10:07:36
        [[file:pictures/10._ADTs/screenshot_2019-08-21_10-07-36.png]]
      - One children
        #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 10:23:26
        [[file:pictures/10._ADTs/screenshot_2019-08-21_10-23-26.png]]
      - Two children
        #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 10:24:03
        [[file:pictures/10._ADTs/screenshot_2019-08-21_10-24-03.png]]
*** BSTs as Sets and Maps
    - Sets
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 10:32:02
      [[file:pictures/10._ADTs/screenshot_2019-08-21_10-32-02.png]]
      - One BST for one set
      - ~contains~ costs $O(n)$ in ArraySet while $log(n)$ in BSTSet
    - Maps
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 10:39:38
      [[file:pictures/10._ADTs/screenshot_2019-08-21_10-39-38.png]]
      - No efficient way to look up by value: $O(n)$
*** Deletion                                                  :TOBEORG:EXTRA:
** Question:                                                      :QUESTIONS:
   1. 关于 ADT 与 interface 的关系？ ADT 一定是 interface 但 interface 不一定是 ADT ？(~default~ implement)
   2. BST 只适合表示一个 set 吧？如果是 Sets 呢？（比如 Disjoint Sets ）
* 11 Balanced Trees                                                  :SLIDE:
** Intro to B-Trees
*** BST Performance
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 10:56:01
    [[file:pictures/11._Balanced_Trees/screenshot_2019-08-21_10-56-01.png]]
    - depth
    - height
    - average depth
*** BST insertion order
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 10:56:52
    [[file:pictures/11._Balanced_Trees/screenshot_2019-08-21_10-56-52.png]]
    Random trees are bushy, not spindly
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 11:08:39
    [[file:pictures/11._Balanced_Trees/screenshot_2019-08-21_11-08-39.png]]
** B-Trees
   Including 2-3-4/2-3 trees, below is a 2-3-4 tree
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 11:33:07
    [[file:pictures/11._Balanced_Trees/screenshot_2019-08-21_11-33-07.png]]
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 11:33:26
   [[file:pictures/11._Balanced_Trees/screenshot_2019-08-21_11-33-26.png]]
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 11:33:48
   [[file:pictures/11._Balanced_Trees/screenshot_2019-08-21_11-33-48.png]]
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 11:35:03
   [[file:pictures/11._Balanced_Trees/screenshot_2019-08-21_11-35-03.png]]
   1. Inserting into a leaf node
   2. If the new node has 4 nodes (for 2-3-4 tree, while 3 for 2-3 tree),  then pop up the *middle left* node to parent node and re-arrange the children accordingly
   3. If step 2 results in the parent node having 4 nodes, then repeat step 2 *at parent node*
   4. Repeat step 2 and 3 until the parent node can accommodate 
** B-Trees deletion                                           :TOBEORG:EXTRA:
** B-Tree invariants and runtime
*** Invariants
    Invariants of a B-tree guarantees the B-tree *must be bushy*, while *inserting order* may decide the *height*
    - All leaves must be the same distance from the source.
    - A non-leaf node with $k$ items must have exactly $k+1$ children
    
    - 2-3 tree insertion example
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 18:05:47
      [[file:pictures/11._Balanced_Trees/screenshot_2019-08-21_18-05-47.png]]
      - 1,2,3,4,5,6,7 order
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-21 18:06:16
      file:pictures/11._Balanced_Trees/screenshot_2019-08-21_18-06-16.png
      - 2,3,4,5,6,1,7 order
*** Runtime analysis
    - Height: Between $log_{L+1}(N)$ and $log_{2}(N)$ -> $\Theta(logN)$, where $L$ is 2 for 2-3 tree and 3 for 2-3-4 tree.
    - Runtime for ~contain~ and ~add~: $O(H+1)L$ -> $O(HL)$ -> $O(LlogN)$, when insert into the *rightest position* in the *rightest node* of height $H$
*** Summary
    - BSTs have best case height $\Theta (\log N)$, and worst case height $\Theta (N)$
    - B-Trees are a *modification* of the binary search tree that avoids $\Theta (N)$ worst case
** Rotating Trees
   B-trees are difficult to implement. Besides insertion, rotating can also yield different structures for the same BST
   - ~rotateLeft(G)~: Let ~x~ be the *right* child of ~G~. Make ~G~ the *new left* child of ~x~.
     #+begin_src java :classname 
       // make a right-leaning link lean to the left
       private Node rotateLeft(Node h) {
           // assert (h != null) && isRed(h.right);
           Node x = h.right;
           h.right = x.left;
           x.left = h;
           return x;
       }
     #+end_src
     #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-22 09:15:31
     [[file:pictures/11._Balanced_Trees/screenshot_2019-08-22_09-15-31.png]]
   - ~rotateRight(G)~: Let ~x~ be the *left* child of ~G~. Make ~G~ the *new right* child of ~x~.
     #+begin_src java :classname 
       private Node rotateRight(Node h) {
           // assert (h != null) && isRed(h.left);
           Node x = h.left;
           h.left = x.right;
           x.right = h;
           return x;
       }
     #+end_src
     #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-22 09:18:02
     [[file:pictures/11._Balanced_Trees/screenshot_2019-08-22_09-18-02.png]]
** Red-Black Trees
   Creating a tree that is *implemented using a BST*, but is *structurally identical to a 2-3 tree* and thus stays *balanced* -> *left-leaning red-black trees (LLRB)*
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-22 09:34:23
   [[file:pictures/11._Balanced_Trees/screenshot_2019-08-22_09-34-23.png]]
   Red for *glue* link, black for normal links
*** Properties of LLRB's
    - *1-1* correspondence with 2-3 trees, Every 2-3 tree has a *unique* LLRB red-black tree associated with it (As for 2-3-4 trees, they maintain correspondence with *standard Red-Black trees*)
    - No node has *2* red links (max number of items per node is 2)
    - There are no red right-links.
    - Every path from *root to leaf* has same number of *black links* (because 2-3 trees have same number of links to every leaf). LLRBS are therefore *balanced*
    - Height is *no more than 2x* height of corresponding 2-3 tree. In actual $2H+1$: H(black)+H(children'red)+1(root's red))
*** Insertion of LLRB
    Inserting into the LLRB as a normal BST (which could break its 1-1 mapping to a 2-3 tree) and use rotations to massage the tree back into a proper structure.
    Performing Task 1-4 if the LLRB tree does not satisfy the *1-1 correspondence* with a 2-3 tree or breaks the *LLRB invariants* until a legal LLRB
    - Task 1: Insertion Color
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-22 11:00:34
      [[file:pictures/11._Balanced_Trees/screenshot_2019-08-22_11-00-34.png]]
    - Task 2: Insertion on the *Right* -> *Left Leaning Violation* -> Rotate *left* the appropriate node to fix.
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-22 11:02:22
      [[file:pictures/11._Balanced_Trees/screenshot_2019-08-22_11-02-22.png]]
      - New Rule: Representation of *Temporary 4-Nodes*
        #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-22 11:03:43
        [[file:pictures/11._Balanced_Trees/screenshot_2019-08-22_11-03-43.png]]
    - Task 3: *Double* Insertion on the *Left* -> *Incorrect 4-Node Violation* -> Rotate *right* the appropriate node to fix.
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-22 11:04:52
      [[file:pictures/11._Balanced_Trees/screenshot_2019-08-22_11-04-52.png]]
    - Task 4: Splitting *Temporary 4-Nodes*
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-22 11:07:02
      [[file:pictures/11._Balanced_Trees/screenshot_2019-08-22_11-07-02.png]]
*** Runtime and implementation
    Same as 2-3 tree: $logN$
    #+begin_src java :classname 
      private Node put(Node h, Key key, Value val) {
          if (h == null) { return new Node(key, val, RED); }

          int cmp = key.compareTo(h.key);
          if (cmp < 0)      { h.left  = put(h.left,  key, val); }
          else if (cmp > 0) { h.right = put(h.right, key, val); }
          else              { h.val   = val;                    }

          if (isRed(h.right) && !isRed(h.left))      { h = rotateLeft(h);  }
          if (isRed(h.left)  &&  isRed(h.left.left)) { h = rotateRight(h); }
          if (isRed(h.left)  &&  isRed(h.right))     { flipColors(h);      } 

          return h;
      }
    #+end_src 
*** Summary
    - BSTs are *simple*, but they are subject to *imbalance*.
    - 2-3 Trees (B-Trees) are *balanced*, but painful to implement and relatively slow.
    - LLRBs *insertion* is simple to implement (but *deletion* is hard).
      - Works by maintaining *mathematical bijection* with a *2-3 trees*.
    - Java’s ~TreeMap~ is a red-black tree (not left leaning).
      - Maintains correspondence with *2-3-4 tree* (is *not a 1-1 correspondence*).
      - Allows glue links on either side
      - More complex implementation, but significantly (?) faster.
    - Beyond
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-22 11:29:01
      [[file:pictures/11._Balanced_Trees/screenshot_2019-08-22_11-29-01.png]]
** Question:                                                      :QUESTIONS: <<elink7>>
   - [ ] 2-3 和 2-3-4 的实现？
   - [ ] 红黑树的实现？
* L19 Hashing
  Limitations of BSTs and B-Trees
  1. Requiring items to be *comparable*
  2. Complexity of $\Theta(logN)$
** DataIndexedIntegerSet
   #+begin_src java :classname 
     public class DataIndexedIntegerSet {
         private boolean[] present;

         public DataIndexedIntegerSet() {
             present = new boolean[2000000000];
         }

         public void add(int x) {
             present[x] = true;
         }

         public boolean contains(int x) {
             return present[x];
         }
   #+end_src 
   - ~add~ and ~contains~ both take $\Theta(1)$ time
   - Extremely wasteful
   - Can't insert a ~String~ 
** DataIndexedEnglishWordSet
   #+begin_src java :classname 
     public class DataIndexedEnglishWordSet {
         private boolean[] present;
 
         public DataIndexedEnglishWordSet() {
             present = new boolean[2000000000];
         }
 
         public void add(String s) {
             present[englishToInt(s)] = true;
         }
 
         public boolean contains(int i) {
             return present[englishToInt(s)];
         }

         /** Converts ith character of String to a letter number.
          ,* e.g. 'a' -> 1, 'b' -> 2, 'z' -> 26 */
         public static int letterNum(String s, int i) {
             int ithChar = s.charAt(i);
             if ((ithChar < 'a') || (ithChar > 'z'))
                 { throw new IllegalArgumentException(); }
             return ithChar - 'a' + 1;
         }

         public static int englishToInt(String s) {
             int intRep = 0;
             for (int i = 0; i < s.length(); i += 1) {           
                 intRep = intRep * 27;
                 intRep = intRep + letterNum(s, i);
             }
             return intRep;
         }
     }

   #+end_src 
   - Can't use uppercase characters
   - 27 >= 26
** DataIndexedStringSet
   #+begin_src java :classname 
     public static int asciiToInt(String s) {
         int intRep = 0;
         for (int i = 0; i < s.length(); i += 1) {           
             intRep = intRep * 126;
             intRep = intRep + s.charAt(i);
         }
         return intRep;
     }
   #+end_src 
** Integer Overflow and Hash Codes
*** Integer Overflow 
    In Java, the largest possible integer is 2,147,483,647, the next number after 2,147,483,647 is -2,147,483,648 -> collisions
*** Hash Codes
    A hash code “projects a value from a set with *many (or even an infinite number of)* members to a value from a set with a *fixed number of (fewer)* members.”
    - Target set: set of Java integers, which is of size 4294967296
    - Pigeonhole principle: items more than 4294967296 will share the same *hash code* -> Collsions are inevitable
    - Two fundamental challenges: collision handling and computing a hashcode
** Hash Tables: Handling Collisions
*** Resolving Ambiguity: separate chaining data indexed array
    ~true~ and ~false~ -> *separate* chaining data indexed array
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-23 15:22:15
    [[file:pictures/L19_Hashing/screenshot_2019-08-23_15-22-15.png]]
    - Still wasteful
*** Hash Table
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-23 15:30:47
    [[file:pictures/L19_Hashing/screenshot_2019-08-23_15-30-47.png]]
    - Data --*hash function*--> an *integer representation* called a *hash code*.
    - Hash code --*reduce* (usually modulus operator)--> a valid index
    - Downside: chains could be very long
** Hash Table Performance
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-23 16:54:11
   [[file:pictures/L19_Hashing/screenshot_2019-08-23_16-54-11.png]]
   - With no resizing
     - Longest list's length = $N/5$ in the best case and $N$ in the worst case -> $Q(N)$ is $\Theta(N)$ -> Runtimes = $\Theta(Q)$ = $\Theta(N)$
     - Less memory but more runtimes $\Theta(N)$ > $\Theta(1)$
   - With resizing
     - Even lists' length $Q=N/M$ -> To make $\Theta(Q) = \Theta(N/M) = \Theta(1)$ -> make $N/M = \Theta(1)$ -> *resize* $M$ when $N/M \geq a, a>1$ (such as 1.5)
     - Most ~add~ operations will be $\Theta(1)$. Some will be $\Theta(N)$ time (to *resize*), as long as resizing by a *multiplicative factor*, the *average runtime* will still be $\Theta(1)$ (similar to ~AList~) [[ilink3]]
     - Two demands: Resizing by a *multiplicative factor* and *evenly* distributed
** Hash Tables in Java
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-24 10:53:51
   [[file:pictures/L19_Hashing/screenshot_2019-08-24_10-53-51.png]]
   - ~hashCode()~: Default implementation simply returns the *memory address* of the object.
   - ~Math.floorMod()~: Reduce hash code to a valid index
   - 2 important warnings which both may result in items getting lost:
     - Never store objects that *can change* in a HashSet or HashMap
     - Never override ~equals~ without also overriding ~hashCode~
*** Question:                                                     :QUESTIONS:
    1. 为什么 override ~equals~ 必须 override ~hashCode~ ？
** Good HashCodes
   Multiplying data by powers of some *base* as ensuring that all the data gets scrambled together into a seemingly *random integer*.
*** Typical Base 
    A typical hash code base is a *small prime*.
    - Prime: 
      - Never even: Avoids the overflow issue
        - Base 126: Any string that ends in the same *last 32* characters has the same hash code: $126^{32}=126^{33}=...=0$ -> overflow
      - Lower chance of resulting hashCode having a bad relationship with the number of buckets
    - Small: 
      - Lower cost to compute
      - Real hash codes don't care about uniqueness
*** Example
    - Java 8 hash code for strings
      #+begin_src java :classname 
        @Override
        public int hashCode() {
            int h = cachedHashValue;
            if (h == 0 && this.length() > 0) {
                for (int i = 0; i < this.length(); i++) {
                    h = 31 * h + this.charAt(i);
                }
                cachedHashValue = h;
            }
            return h;
        }
      #+end_src
      - Caches calculated hash code so future ~hashCode~ calls are faster
    - Hashing a Collection
      #+begin_src java :classname 
        @Override
        public int hashCode() {
            int hashCode = 1;
            for (Object o : this) {
                hashCode = hashCode * 31;
                hashCode = hashCode + o.hashCode();
            }
            return hashCode;
        }
      #+end_src
      - To save time hashing: Look at only first few items. (Higher chance of collisions but things will still work.)
    - Hashing a Recursive Data Structure (binary tree hashCode, assuming sentinel leaves) 
      #+begin_src java :classname 
        @Override
        public int hashCode() {
            if (this.value == null) {
                return 0;
            }
            return  this.value.hashCode() +
                31 * this.left.hashCode() +
                31 * 31 * this.right.hashCode();
        }
      #+end_src
      - Computation of the hashCode of a recursive data structure involves *recursive computation*.
*** Question:                                                     :QUESTIONS:
    1. 为什么真的哈希码不关心唯一性？那数据冲突了怎么办？
** Summary
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-08-24 11:26:20 <<ilink9>>
   [[file:pictures/L19_Hashing/screenshot_2019-08-24_11-26-20.png]]
* L20 Heaps and PQs
** Priority Queues
   #+begin_src java :classname 
     /** (Min) Priority Queue: Allowing tracking and removal of the
      ,* smallest item in a priority queue. */
     public interface MinPQ<Item> {
         /** Adds the item to the priority queue. */
         public void add(Item x);
         /** Returns the smallest item in the priority queue. */
         public Item getSmallest();
         /** Removes the smallest item from the priority queue. */
         public Item removeSmallest();
         /** Returns the size of the priority queue. */
         public int size();
     }
   #+end_src 
*** Unharmounious Texts
    - Naive Implementation: *Store* and *Sort*
      Create a *list* of all messages sent for the entire day. Sort it using your *comparator*. Return the M messages that are largest.
      #+begin_src java :classname 
        public List<String> unharmoniousTexts(Sniffer sniffer, int M) {
            ArrayList<String> allMessages = new ArrayList<String>();

            for (Timer timer = new Timer(); timer.hours() < 24; ) {
                allMessages.add(sniffer.getNextMessage());
            }

            Comparator<String> cmptr = new HarmoniousnessComparator();
            Collections.sort(allMessages, cmptr, Collections.reverseOrder());
    
            return allMessages.sublist(0, M);
        }
      #+end_src
      - Potentially uses a huge amount of memory $\Theta(N)$, $N$ is number of texts -> using a ~MinPQ~ to reduce to $\Theta(M)$: ~MinPQ<String> unharmoniousTexts = new HeapMinPQ<Transaction>(cmptr)~ 
    - Better Implementation: *Track* the M Best
      #+begin_src java :classname 
        public List<String> unharmoniousTexts(Sniffer sniffer, int M) {
            Comparator<String> cmptr = new HarmoniousnessComparator();
            MinPQ<String> unharmoniousTexts = new HeapMinPQ<Transaction>(cmptr);
            for (Timer timer = new Timer(); timer.hours() < 24; ) {
                unharmoniousTexts.add(sniffer.getNextMessage());
                if (unharmoniousTexts.size() > M) 
                    { unharmoniousTexts.removeSmallest(); }
            }
            ArrayList<String> textlist = new ArrayList<String>();
            while (unharmoniousTexts.size() > 0) {
                textlist.add(unharmoniousTexts.removeSmallest());
            }
            return textlist;
        }
      #+end_src
      - Can *track* top $M$ transactions using only $M$ memory
*** To implement a ~MinPQ~
    - *Ordered* Array
    - *Bushy* BST: Maintaining bushiness is annoying. Handling *duplicate* priorities is awkward.
    - HashTable: No good! Items go into *random* places.
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 18:33:17
    [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_18-33-17.png]]
*** Question:                                                     :QUESTIONS:
    - [ ] ~Queue~ 的实现？ <<elink6>>
** Heaps
   *Binary min-heap*: Binary tree that is *complete* and obeys *min-heap property*.
   - *Min-heap*: Every node is *less than or equal* to both of its children.
   - Complete: Missing items only at the bottom level (if any), all nodes are as far left as possible.
   #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 18:36:35
   [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_18-36-35.png]]
** Tree Representations
*** Approach 1: Create *mapping* from *node* to *children*
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 18:55:19
    [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_18-55-19.png]]
    #+begin_src java :classname 
      public class Tree1A<Key> {
          Key k; // e.g. 0
          Tree1A left;
          Tree1A middle;
          Tree1A right;
          ...
      }

      public class Tree1B<Key> {
          Key k; // e.g. 0
          Tree1B[] children;
          ...
      }

      public class Tree1C<Key> {
          Key k; // e.g. 0
          Tree1C favoredChild;
          Tree1C sibling;
          ...
      }
    #+end_src 
*** Approach 2: Store *keys* in an *array*. Store *parentIDs* in an *array*.
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 19:01:49
    [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_19-01-49.png]]
    #+begin_src java :classname 
      public class Tree2<Key> {
          Key[] keys;
          int[] parents;
          ...
      }
    #+end_src 
*** Approach 3: Store *keys* in an *array*. *Don’t* store *structure* anywhere.
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 20:50:14
    [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_20-50-14.png]]
    #+begin_src java :classname 
      public class Tree3<Key> {
          Key[] keys;
          ...

          public void swim(int k) {
              if (keys[parent(k)] ≻ keys[k]) {
                  swap(k, parent(k));
                  swim(parent(k));              
              }
          }

          public int parent(int k) {
              return (k - 1) / 2;
          }
      }
    #+end_src 
    - Only works for *complete* trees
    - Recursive: ~swap(k, parent(k))~ and ~swim(parent(k))~ 
*** Approach 3B (book implementation): Leaving *One Empty Spot*
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 21:05:29
    [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_21-05-29.png]]
*** Heap Implementation of a Priority Queue
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 21:21:22
    [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_21-21-22.png]]
**** Question:                                                    :QUESTIONS:
     1. 怎么理解上图红字，相同的优先级意味着什么？为什么 ~Heaps~ 比 Bushy ~BST~ 更适合相同的优先级的情况？
     2. 怎么大体衡量 Array based heaps 比 approach 1a 表示法节约的空间？
** Data Structures Summary
*** Search Data Structures <<ilink6>>
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 22:11:04
    [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_22-11-04.png]]

    #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 22:11:45
    [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_22-11-45.png]]

    #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 22:12:04
    [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_22-12-04.png]]

    #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 22:12:37
    [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_22-12-37.png]]
    - Abstraction often happens in layers!
    #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 22:13:26
    [[file:pictures/L20_Heaps_and_PQs/screenshot_2019-10-15_22-13-26.png]]
**** Question:                                                    :QUESTIONS:
     1. 怎么理解上面几张图？
* L21 Prefix Operations and Tries
** Tries
*** Intro
    - ADTs vs. Specific Implementations <<ilink7>>
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-15 23:56:27
      [[file:pictures/L21_Tries/screenshot_2019-10-15_23-56-27.png]]
    - Special cases to implement ~Set~ and ~Map~
      Better than *BST* and *Hash Table* 
      - Special Case 1: Character Keyed Map <<ilink8>>
        Keys are always ASCII characters.
        #+begin_src java :classname 
          public class DataIndexedCharMap<V> {
              private V[] items;
              public DataIndexedCharMap(int R) {
                  items = (V[]) new Object[R];
              }
              public void put(char c, V val) {
                  items[c] = val;
              }
              public V get(char c) {
                  return items[c];
              }
          }
        #+end_src
      - Special Case 2: String Keyed Map
        Keys are always strings -> Basic idea: Store *each letter* of the string as a node in a tree -> Use data structure *Trie*
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-10-16 09:21:16
      [[file:pictures/L21_Tries/screenshot_2019-10-16_09-21-16.png]]
**** Question:                                                    :QUESTIONS:
     - [ ] [[ilink7][specific implements]] 以及 [[ilink6][search data structure]] 中能否全实现一遍？
     - [ ] [[ilink8][Character Keyed Map]] 里 ~items[c]~ 是把 ~c~ 先转换为 ~int~ 再存的吧？那就是要求容量必须大于所存的最大索引？
*** Tries for ~String~ keys
    - Key ideas
      - Every node stores only one letter.
      - Nodes can be shared by multiple keys.
    - Search *Hits* and *Misses*
      Insert “sam”, “sad”, “sap”, “same”, “a”, and “awls”, not “aw”, “awl”, “sa”, etc.
      #+DOWNLOADED: screenshot @ 2019-10-16 10:15:35
      [[file:pictures/L21_Tries/screenshot_2019-10-16_10-15-35.png]]
      - *Hits*: contained in the tree *and* the final code is blue
      - *Misses*:
        - If not contained 
        - If contained but the final node is white
    - Comparison with BST and HashSet
      #+DOWNLOADED: screenshot @ 2019-10-16 10:26:44
      [[file:pictures/L21_Tries/screenshot_2019-10-16_10-26-44.png]]
*** Trie Maps
    #+DOWNLOADED: screenshot @ 2019-10-16 10:28:21
    [[file:pictures/L21_Tries/screenshot_2019-10-16_10-28-21.png]]
    - *Hits* only if *contained and blue and not null*
** Trie Implementation and Performance
*** Basic Implementations
    #+begin_src java :classname 
      public class TrieSet {
          private static final int R = 128; // ASCII
          private Node root;    // root of trie
  
          private static class Node {
              private char ch;  
              private boolean isKey;   
              private DataIndexedCharMap next;
              private Node(char c, boolean b, int R) {
                  ch = c; isKey = b;
                  next = new DataIndexedCharMap<Node>(R);
              }
          }
  
          private static class Node {
              private boolean isKey;   
              private DataIndexedCharMap next;
              private Node(boolean b, int R) {
                  isKey = b;
                  next = new DataIndexedCharMap<Node>(R);
              }
          }    

      }
  
      public class DataIndexedCharMap<V> {
          private V[] items;
          public DataIndexedCharMap(int R) {
              items = (V[]) new Object[R];
          }
          ...
      }
    #+end_src
    #+DOWNLOADED: screenshot @ 2019-10-16 11:00:16
    [[file:pictures/L21_Tries/screenshot_2019-10-16_11-00-16.png]]
    #+DOWNLOADED: screenshot @ 2019-10-16 11:00:36
    [[file:pictures/L21_Tries/screenshot_2019-10-16_11-00-36.png]]
    - Do not store ~char ch~ in node
*** Trie Performance in Terms of $N$
    #+DOWNLOADED: screenshot @ 2019-10-16 11:03:00
    [[file:pictures/L21_Tries/screenshot_2019-10-16_11-03-00.png]]
    - $N$ is the num of *keys*, not nodes. $L$ is the length of the key
    - Runtime <<ilink4>>
      - ~add~ runtime
        - Independent of $N$: $\Theta(1)$
        - Dependent of $L$: $\Theta(L)$ <<ilink5>>
      - ~contains~ runtime
        - Independent of $N$: $\Theta(1)$
        - Dependent of $L$: $O(L)$
    - Huge memory waste of storing $R$ links per node
**** Question:                                                    :QUESTIONS:
     1. 分析复杂度时为什么不考虑插入 key 的长度 [[ilink4]]？为什么考虑 key 长度时 ~add~ 和 ~contains~ 复杂度不一样？ [[ilink5]]
** Alternate Child Tracking Strategies
   #+DOWNLOADED: screenshot @ 2019-10-16 12:47:41
   [[file:pictures/L21_Tries/screenshot_2019-10-16_12-47-41.png]]
   DataIndexedCharMap is very memory hungry, can use ANY kind of *map* from *character to node*, e.g.
   - BST
   - Hash Table
*** Alternate Idea #1: The Hash-Table Based Trie
    #+DOWNLOADED: screenshot @ 2019-10-16 12:49:05
    [[file:pictures/L21_Tries/screenshot_2019-10-16_12-49-05.png]]
*** Alternate Idea #2: The BST-Based Trie
    #+DOWNLOADED: screenshot @ 2019-10-16 12:50:25
    [[file:pictures/L21_Tries/screenshot_2019-10-16_12-50-25.png]]
*** Comparison
    - Using a BST or a Hash Table to store links to children will usually use *less memory*.
      - DataIndexedCharMap: 128 links per node
      - BST: $C$ links per node, where $C$ is the number of children.
      - Hash Table: $C$ links per node.
      - Note: Cost per link is *higher* in BST and Hash Table
    - Using a BST or a Hash Table will take *slightly more time*.
      - DataIndexedCharMap: $\Theta(1)$
      - BST: $O(logR)$
      - Hash Table: $O(R)$, where $R$ is size of alphabet
      - Since $R$ is fixed (e.g. 128), can think of all 3 as $\Theta(1)$
    - Comparison
      #+DOWNLOADED: screenshot @ 2019-10-16 13:20:05
      [[file:pictures/L21_Tries/screenshot_2019-10-16_13-20-05.png]]
** Trie String Operations
   *main appeal* of tries is their ability to efficiently support *string specific operations* like *prefix matching*.
*** Finding all keys that match a given prefix: ~keysWithPrefix(“sa”)~ -> ~[sad, sam, same, sap]~
    - Collecting Trie Keys: ~collect()~ and ~colHelp(String s, List<String> x, Node n)~
      #+DOWNLOADED: screenshot @ 2019-10-16 13:41:19
      [[file:pictures/L21_Tries/screenshot_2019-10-16_13-41-19.png]]
      - Recursive: ~colHelp(s + c, x, n.next.get(c))~, tree structures usually refer to recursive methods
    - ~keysWithPrefix~
      #+DOWNLOADED: screenshot @ 2019-10-16 13:42:44
      [[file:pictures/L21_Tries/screenshot_2019-10-16_13-42-44.png]]
*** Finding longest prefix of a string: ~longestPrefixOf(“sample”)~ -> ~sam~ 
**** Question:                                                    :QUESTIONS:
     1. 怎么实现 ~longestPrefixOf~ 
** Autocomplete
   Create a *Trie based map* from *strings to values* --> type in a string ~s~ --> call ~keysWithPrefix(s)~ --> return the $n$ strings with the highest value.
   - Value represents how important Google thinks that string is.
   - Can store billions of strings efficiently since they share nodes.
*** Top 3 matches example
    - Basic
      #+DOWNLOADED: screenshot @ 2019-10-16 14:13:38
      [[file:pictures/L21_Tries/screenshot_2019-10-16_14-13-38.png]]
      - The number of keys with the appropriate prefix will be *too big* for a *short string*, extremely *inefficient*
    - More efficient
      #+DOWNLOADED: screenshot @ 2019-10-16 14:15:08
      [[file:pictures/L21_Tries/screenshot_2019-10-16_14-15-08.png]]
    - Even more efficient
      #+DOWNLOADED: screenshot @ 2019-10-16 14:16:29
      [[file:pictures/L21_Tries/screenshot_2019-10-16_14-16-29.png]]
**** Question:                                                    :QUESTIONS:
     - [ ] radix trie 实现
** Trie Summary
   #+DOWNLOADED: screenshot @ 2019-10-16 14:18:10
   [[file:pictures/L21_Tries/screenshot_2019-10-16_14-18-10.png]]
   - More generally, can sometimes take special advantage of *key type* to improve *sets and maps*, further types of *string sets/maps*
     - Suffix Trees
     - DAWG
* L22 Range Searching and Multi-Dimensional Data
** Multi-Dimensional Data
*** Intro 
    - Two fairly general implementations of sets and maps:
      - *Hash Table*: Requires that keys can be *hashed*.
      - *Search Tree*: Requires that keys can be *compared*.
    - Two special case implementations:
      - *Data Indexed Array*: Requires that keys are *small*
      - *Trie*: Requires that keys are *strings*.
    -> Map/Set for *Multi-dimensional keys*
*** Motivation: 2D Range Finding and Nearest Neighbors (hash table)
    #+DOWNLOADED: screenshot @ 2019-10-16 14:48:21
    [[file:pictures/L22_Range_Searching_and_Multi-Dimensional_Data/screenshot_2019-10-16_14-48-21.png]]
    - ~nearest()~ have to iterate over all $N$ items due to each item is *effectively random* (points are *evenly* spread out), $\Theta(N)$
** Uniform Partitioning
   #+DOWNLOADED: screenshot @ 2019-10-16 14:58:58
   [[file:pictures/L22_Range_Searching_and_Multi-Dimensional_Data/screenshot_2019-10-16_14-58-58.png]]
   - Runtime for ~nearest()~ in *spatial hashing* will be 16 times faster than original hashing -> still $\Theta(N)$
*** Question:                                                     :QUESTIONS:
    1. 上图中的第二点 "Typical implementation would ..." 怎么理解？
** Quadtrees
*** Trees vs. Hash Tables 
    #+DOWNLOADED: screenshot @ 2019-10-16 15:44:45
    [[file:pictures/L22_Range_Searching_and_Multi-Dimensional_Data/screenshot_2019-10-16_15-44-45.png]]
*** Building Trees of Two Dimensional Data
    *Hash table* in *uniform* partition -> *Quadtrees* in *Hierarchical* partition
    #+DOWNLOADED: screenshot @ 2019-10-16 15:53:51
    [[file:pictures/L22_Range_Searching_and_Multi-Dimensional_Data/screenshot_2019-10-16_15-53-51.png]]
    #+DOWNLOADED: screenshot @ 2019-10-16 16:42:36
    [[file:pictures/L22_Range_Searching_and_Multi-Dimensional_Data/screenshot_2019-10-16_16-42-36.png]]
    #+DOWNLOADED: screenshot @ 2019-10-16 16:27:43
    [[file:pictures/L22_Range_Searching_and_Multi-Dimensional_Data/screenshot_2019-10-16_16-27-43.png]]
** Higher Dimensional Data
*** Intro 
    - 3D Data -> *Oct-tree*
      #+DOWNLOADED: screenshot @ 2019-10-16 16:46:19
      [[file:pictures/L22_Range_Searching_and_Multi-Dimensional_Data/screenshot_2019-10-16_16-46-19.png]]
    - Higher Dimensional Data -> common solution *k-d tree*, can handle arbitrary numbers of dimensions
*** K-d Trees
    #+DOWNLOADED: screenshot @ 2019-10-17 09:41:40
    [[file:pictures/L22_Range_Searching_and_Multi-Dimensional_Data/screenshot_2019-10-17_09-41-40.png]]

    - ~nearest()~
      - Inefficient pseudocode
        #+DOWNLOADED: screenshot @ 2019-10-17 09:45:01
        [[file:pictures/L22_Range_Searching_and_Multi-Dimensional_Data/screenshot_2019-10-17_09-45-01.png]]
        - Optimization: Do not explore subspaces that can’t possible have a better answer than current best.
      - Efficient pseudocode
        #+DOWNLOADED: screenshot @ 2019-10-17 09:43:09
        [[file:pictures/L22_Range_Searching_and_Multi-Dimensional_Data/screenshot_2019-10-17_09-43-09.png]]
** Multi-Dimensional Data Summary
   #+DOWNLOADED: screenshot @ 2019-10-17 09:52:04
   [[file:pictures/L22_Range_Searching_and_Multi-Dimensional_Data/screenshot_2019-10-17_09-52-04.png]]
** Question:                                                      :QUESTIONS:
   - [ ] uniform partition + hash table 怎么实现？
   - [ ] quadtree 实现？
* L23 Tree and Graph Traversals
** Trees and Traversals 
*** Trees implementations 
    #+DOWNLOADED: screenshot @ 2019-10-17 11:14:52
    [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-17_11-14-52.png]]
*** Tree traversal 
    #+begin_src java :classname 
      preOrder(BSTNode x) {
          if (x == null) return;
          print(x.key);
          preOrder(x.left);
          preOrder(x.right);
      }

      inOrder(BSTNode x) {
          if (x == null) return;
          inOrder(x.left);
          print(x.key);
          inOrder(x.right);
      }

      postOrder(BSTNode x) {
          if (x == null) return;
          postOrder(x.left);
          postOrder(x.right);
          print(x.key);
      }
    #+end_src 
    - *Traverse* is different from *visit* 
    - Example: Postorder Traversal for gathering file sizes.
      #+DOWNLOADED: screenshot @ 2019-10-22 10:13:27
      [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-13-27.png]]
** Graphs
*** Definition
    #+DOWNLOADED: screenshot @ 2019-10-22 10:24:29
    [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-24-29.png]]
    #+DOWNLOADED: screenshot @ 2019-10-22 10:23:53
    [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-23-53.png]]
*** Simple graph
    #+DOWNLOADED: screenshot @ 2019-10-22 10:26:23
    [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-26-23.png]]
*** Types
    #+DOWNLOADED: screenshot @ 2019-10-22 10:26:51
    [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-26-51.png]]
*** Terminology
    #+DOWNLOADED: screenshot @ 2019-10-22 10:27:29
    [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-27-29.png]]
** Graph Problems
   #+DOWNLOADED: screenshot @ 2019-10-22 10:33:19
   [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-33-19.png]]
   #+DOWNLOADED: screenshot @ 2019-10-22 10:33:43
   [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-33-43.png]]
** Depth-First Traversal
*** s-t Connectivity 
    #+DOWNLOADED: screenshot @ 2019-10-22 10:41:14
    [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-41-14.png]]
    #+DOWNLOADED: screenshot @ 2019-10-22 10:41:34
    [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-41-34.png]]
    - Example
      #+DOWNLOADED: screenshot @ 2019-10-22 10:50:58
      [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-50-58.png]]
*** Depth First Traversal
    #+DOWNLOADED: screenshot @ 2019-10-22 10:53:36
    [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-53-36.png]]
    - Example: DepthFirstPaths
      #+DOWNLOADED: screenshot @ 2019-10-22 10:54:25
      [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_10-54-25.png]]
** Tree Vs. Graph Traversals
*** Tree Traversal
    #+DOWNLOADED: screenshot @ 2019-10-22 11:02:16
    [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_11-02-16.png]]
*** Graph Traversal
    - DFS Preorder
      #+DOWNLOADED: screenshot @ 2019-10-22 11:04:01
      [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_11-04-01.png]]
    - DFS Postorder
      #+DOWNLOADED: screenshot @ 2019-10-22 11:04:30
      [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_11-04-30.png]]
    - BFS order
      #+DOWNLOADED: screenshot @ 2019-10-22 11:21:27
      [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_11-21-27.png]]
      #+DOWNLOADED: screenshot @ 2019-10-22 11:11:14
      [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_11-11-14.png]]
** Summary
   #+DOWNLOADED: screenshot @ 2019-10-22 11:13:46
   [[file:pictures/L23_Tree_and_Graph_Traversals/screenshot_2019-10-22_11-13-46.png]]
* L24 Graph Traversals and Implementations
** Graph API
   #+DOWNLOADED: screenshot @ 2019-10-22 15:29:11
   [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_15-29-11.png]]
   #+DOWNLOADED: screenshot @ 2019-10-22 15:30:09
   [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_15-30-09.png]]
** Graph Representation and Graph Algorithm Runtimes
*** Representations and runtimes
    - Adjacency-matrix 
      #+DOWNLOADED: screenshot @ 2019-10-22 13:07:58
      [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_13-07-58.png]]
    - Edge Sets
      #+DOWNLOADED: screenshot @ 2019-10-22 13:08:40
      [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_13-08-40.png]]
    - Adjacency lists
      #+DOWNLOADED: screenshot @ 2019-10-22 13:09:43
      [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_13-09-43.png]]
    - Runtime of some basic operations for each representation
      #+DOWNLOADED: screenshot @ 2019-10-22 13:21:33
      [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_13-21-33.png]]
**** Question:                                                    :QUESTIONS:
     - [ ] Adjacency lists 为什么是 $\Theta(V+E)$ 而不是 $\Theta(E)$
*** Bare-Bones Undirected Graph Implementation
    #+begin_src java :classname 
      public class Graph {
          private final int V;  private List<Integer>[] adj;
    
          public Graph(int V) {
              this.V = V;
              adj = (List<Integer>[]) new ArrayList[V];
              for (int v = 0; v < V; v++) {
                  adj[v] = new ArrayList<Integer>();
              }
          } 

          public void addEdge(int v, int w) {
              adj[v].add(w);   adj[w].add(v);
          }

          public Iterable<Integer> adj(int v) {
              return adj[v];
          }
      }
    #+end_src 
    - ~private List<Integer>[] adj~: *declaration* ~adj = (List<Integer>[]) new ArrayList[V]~ + *initiation* ~adj[v] = new ArrayList<Integer>()~ 
** Graph Traversal Implementations and Runtime 
   Common design pattern in graph algorithms: *Decouple type* from *processing algorithm*.
   - Create a *graph object*.
   - Pass the *graph* to a *graph-processing method* (or constructor) in a *client class*.
   - Query the *client class* for information.
*** DepthFirstPaths <<elink14>>
    - Implementation (Recursive)
      #+begin_src java :classname 
        public class DepthFirstPaths {
            private boolean[] marked;
            private int[] edgeTo;
            private int s;
     
            public DepthFirstPaths(Graph G, int s) {
                ...
                dfs(G, s);
            }

            private void dfs(Graph G, int v) {
                marked[v] = true;
                for (int w : G.adj(v)) {
                    if (!marked[w]) {
                        edgeTo[w] = v;
                        dfs(G, w);
                    }            
                } 
            }

            public Iterable<Integer> pathTo(int v) {
                if (!hasPathTo(v)) return null;
                List<Integer> path = new ArrayList<>();
                for (int x = v; x != s; x = edgeTo[x]) {
                    path.add(x);
                }
                path.add(s);
                Collections.reverse(path);
                return path;
            }

            public boolean hasPathTo(int v) {
                return marked[v];
            ...
        }
      #+end_src
      - ~marked[v]~ is ~true~ *iff* ~v~ connected to ~s~
      - ~edgeTo[v]~ is *previous vertex* on path from ~s~ to ~v~
      - Recursive: ~edgeTo[w] = v~ + ~dfs(G, w)~
      - ~Collections.reverse(path)~ 
    - Runtime
      - Adjacency list
        #+DOWNLOADED: screenshot @ 2019-10-22 14:22:08
        [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_14-22-08.png]]
      - Adjacency matrix
        #+DOWNLOADED: screenshot @ 2019-10-22 15:43:53
        [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_15-43-53.png]]
**** Question:                                                    :QUESTIONS:
     - [ ] 上面的 Runtime 分析怎么理解？为什么 ~marked[w]~ 考虑的是边？为什么每条边最多考虑两次？为啥是 ~sum~ ？
*** BreadthFirstPaths <<elink15>>
    - Implementation (*queue* instead of recursion)
      #+DOWNLOADED: screenshot @ 2019-10-22 14:12:31
      [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_14-12-31.png]]
      - ~Queue<Integer> fringe = new Queue<Integer>()~
      - ~while (!fringe.isEmpty())~
      - ~fringe.enqueue(w)~ + ~marked[w] = true~ + ~edgeTo[w] = v~ 
*** Graph Problems
    - Adjacency matrix
      #+DOWNLOADED: screenshot @ 2019-10-22 15:42:11
      [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_15-42-11.png]]
    - Adjacency list
      #+DOWNLOADED: screenshot @ 2019-10-22 15:43:10
      [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_15-43-10.png]]
**** Question:                                                    :QUESTIONS:
     - [ ] 为什么 s-t paths 用 DFP 而 s-t shortest paths 用 BFP ？而且二者的时间复杂度还一样？
** Summary
   #+DOWNLOADED: screenshot @ 2019-10-22 15:27:30
   [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_15-27-30.png]]
   #+DOWNLOADED: screenshot @ 2019-10-22 15:27:53
   [[file:pictures/L24_Graph_Traversals_and_Implementations/screenshot_2019-10-22_15-27-53.png]]
* L25 Shortest Paths
** DFS vs. BFS
   #+DOWNLOADED: screenshot @ 2019-10-22 15:56:34
   [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_15-56-34.png]]
   #+DOWNLOADED: screenshot @ 2019-10-22 15:56:56
   [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_15-56-56.png]]
** Dikstra's Algorithm
   Goal: Find the shortest paths from source vertex s to every other vertex.
*** Bad algorithm 1
    #+DOWNLOADED: screenshot @ 2019-10-22 16:48:05
    [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_16-48-05.png]]
*** Bad algorithm 2
    #+DOWNLOADED: screenshot @ 2019-10-22 16:48:31
    [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_16-48-31.png]]
*** Dijkstra’s Algorithm
    Visit vertices in order of *best-known distance* from source. On visit, *relax* every *edge* from the *visited vertex*.
    #+DOWNLOADED: screenshot @ 2019-10-22 16:49:20
    [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_16-49-20.png]]
*** Demo
    #+DOWNLOADED: screenshot @ 2019-11-13 14:15:04
    [[file:pictures/L25_Shortest_Paths/2019-11-13_14-15-04_screenshot.png]]
** Dijkstra’s Correctness and Runtime
*** Pseudocode 
    #+DOWNLOADED: screenshot @ 2019-10-22 17:33:55
    [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_17-33-55.png]]
*** Guaranteed Optimality
    #+DOWNLOADED: screenshot @ 2019-10-22 17:38:19
    [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_17-38-19.png]]
**** Question:                                                    :QUESTIONS:
     - [ ] 具体怎么证明？直观上贪婪怎么保证最优解（最短路径）？
*** Runtime
    #+DOWNLOADED: screenshot @ 2019-10-22 17:38:55
    [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_17-38-55.png]]
**** Question:                                                    :QUESTIONS:
     - [ ] Overall runtime 怎么分析出来的？主要是 ~changePriority~ 的复杂度和边的关系？
** A*
   Visit vertices in order of $d(source, v) + h(v, goal)$, where $h(v, goal)$ is an *estimate* of the distance from /v/ to /goal/. On visit, *relax* every *edge* from the *visited vertex*.
*** Heuristics and Correctness
    #+DOWNLOADED: screenshot @ 2019-10-22 20:14:33
    [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_20-14-33.png]]
*** Consistency and Admissibility (EXTRA: Beyond Course Scope)
    #+DOWNLOADED: screenshot @ 2019-10-22 20:15:47
    [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_20-15-47.png]]
*** Memory Optimized A*                                               :EXTRA:
    - 3 differences from A*
      - The algorithm starts with *only the start* vertex in the PQ.
      - When relaxing an edge, if the relaxation is successful and the target vertex is not in the PQ, add it.
      - If the algorithm takes longer than some timeout value, it stops running.
    - Algorithm Pseudocode <<elink17>>
      - Create a PQ where each vertex v will have priority p equal to the sum of v’s distance from the source plus the heuristic estimate from v to the goal, i.e. p = distTo[v] + h(v, goal).
      - Insert the source vertex into the PQ.
      - Repeat until the PQ is empty, PQ.getSmallest() is the goal, or timeout is exceeded:
        - p = PQ.removeSmallest()
        - relax all edges outgoing from p
      - relax(e):
        - p = e.from(), q = e.to(), w = e.weight()
        - if distTo[p] + w < distTo[q]:
          - distTo[q] = distTo[p] + w
          - if q is in the PQ: changePriority(q, distTo[q] + h(q, goal))
          - if q is not in PQ: add(q, distTo[q] + h(q, goal))
    - Some interesting consequences of these changes
      - In the lecture version, once a vertex was removed from the PQ, it was gone forever. This meant that each vertex was visited at most one time. In this new version of A*, the algorithm can theoretically revisit the same vertex many times. <<elink11>>
      - Beyond the scope of our course: As a side effect of the consequence above, admissibility is a sufficient condition for correctness for the memory optimized version of A*. For the version in lecture, we needed a stronger criterion for our heuristic called consistency. (CS188)
    - One additional optimization can make <<elink10>>
      Avoid storing the best known distance and edge to every vertex. In this case, rather than “relaxing” edges, we’d blindly add all discovered vertices to our PQ. This is the equivalent of treating every edge relaxation as successful. This requires the addition of an “already visited set” to keep memory from getting out of hand. (CS188)
*** Demo
    - A* 
      #+DOWNLOADED: screenshot @ 2019-11-13 14:11:51
      [[file:pictures/L25_Shortest_Paths/2019-11-13_14-11-51_screenshot.png]]
    - Memory Optimized A*
      #+DOWNLOADED: screenshot @ 2019-11-13 14:30:43
      [[file:pictures/L25_Shortest_Paths/2019-11-13_14-30-43_screenshot.png]]
** Summary
*** Shortest Paths Problems 
    #+DOWNLOADED: screenshot @ 2019-10-22 20:17:08
    [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_20-17-08.png]]
    - At most time vastly more nodes *are visited* than *exist on the shortest path*.
*** Graph Problems
    #+DOWNLOADED: screenshot @ 2019-10-22 20:17:51
    [[file:pictures/L25_Shortest_Paths/screenshot_2019-10-22_20-17-51.png]]
* L26 Minimum Spanning Trees
  <<ilink14>>
  #+DOWNLOADED: screenshot @ 2019-10-26 16:45:44
  [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-26_16-45-44.png]]
  #+DOWNLOADED: screenshot @ 2019-10-26 16:46:04
  [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-26_16-46-04.png]]
** MST, Cut Property, Generic MST Algorithm
*** MST 
    #+DOWNLOADED: screenshot @ 2019-10-26 16:48:04
    [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-26_16-48-04.png]]
    
    - MST vs. SPT
      A SPT depends on the start vertex, while there is no source for a MST
      #+DOWNLOADED: screenshot @ 2019-10-27 09:38:55
      [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_09-38-55.png]]
      #+DOWNLOADED: screenshot @ 2019-10-27 09:40:47
      [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_09-40-47.png]]
*** Cut Property
    - Property
      #+DOWNLOADED: screenshot @ 2019-10-27 09:45:03
      [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_09-45-03.png]]
    - Proof
      #+DOWNLOADED: screenshot @ 2019-10-27 09:48:25
      [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_09-48-25.png]]
*** Generic MST Algorithm
    #+DOWNLOADED: screenshot @ 2019-10-27 09:49:13
    [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_09-49-13.png]]
** Prim’s Algorithm
   #+DOWNLOADED: screenshot @ 2019-10-27 10:02:36
   [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_10-02-36.png]]
*** Implementation 
    #+DOWNLOADED: screenshot @ 2019-10-27 10:14:06
    [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_10-14-06.png]]
    #+DOWNLOADED: screenshot @ 2019-10-27 10:14:26
    [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_10-14-26.png]]
    - Pseudocode
      #+DOWNLOADED: screenshot @ 2019-10-27 10:15:06
      [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_10-15-06.png]]
      #+DOWNLOADED: screenshot @ 2019-10-27 10:15:29
      [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_10-15-29.png]]
*** Runtime
    #+DOWNLOADED: screenshot @ 2019-10-27 10:16:01
    [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_10-16-01.png]]
** Kruskal’s Algorithm
   #+DOWNLOADED: screenshot @ 2019-10-27 10:21:35
   [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_10-21-35.png]]
*** Implementation 
    #+DOWNLOADED: screenshot @ 2019-10-27 10:42:00
    [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_10-42-00.png]]
*** Runtime <<ilink15>>
    #+DOWNLOADED: screenshot @ 2019-10-27 10:43:46
    [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_10-43-46.png]]
** Summary
   #+DOWNLOADED: screenshot @ 2019-10-27 10:45:36
   [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_10-45-36.png]]
   #+DOWNLOADED: screenshot @ 2019-10-27 10:53:56
   [[file:pictures/L26_Minimum_Spanning_Trees/screenshot_2019-10-27_10-53-56.png]]
*** Question:                                                     :QUESTIONS:
    - [ ] Generic MST, Prim, Kruskal 的理解与相互联系？
    - [ ] Summary 里的复杂度分析
** Question:                                                      :QUESTIONS:
   - [ ] Warm-up Problem 里 [[ilink14][复杂度]] 的分析
   - [ ] [[ilink15][bottom-up heapification]] ？
* L27 Reductions and Decomposition
** Topological Sorting
   #+DOWNLOADED: screenshot @ 2019-10-28 22:17:47
   [[file:pictures/L27_Reductions_and_Decomposition/screenshot_2019-10-28_22-17-47.png]]
   - Arrow from v to w indicates that v must happen *before* w.
   - Can think of this process as sorting nodes so they appear in an *order consistent with edges*: arrows *all point rightwards*
     #+DOWNLOADED: screenshot @ 2019-10-28 22:29:45
     [[file:pictures/L27_Reductions_and_Decomposition/screenshot_2019-10-28_22-29-45.png]]
   - *DFS* sometimes means *with restarts*, and somtimes means *without*
     - DFS for *reachability* without restarts
     - DFS for *Topological Sort* with restarts
   - Another better topological sort algorithm: Not need *indegree 0* as start
     - Run DFS from an *arbitrary* vertex.
     - If not all marked, pick an unmarked vertex and do it again.
     - Repeat until done.
   - A topological sort only exists if the graph is a *directed acyclic graph (DAG)*
   - Efficiency
     #+DOWNLOADED: screenshot @ 2019-10-28 22:39:24
     [[file:pictures/L27_Reductions_and_Decomposition/screenshot_2019-10-28_22-39-24.png]]
   - Example
     #+DOWNLOADED: screenshot @ 2019-10-28 22:38:40
     [[file:pictures/L27_Reductions_and_Decomposition/screenshot_2019-10-28_22-38-40.png]]
** Shortest Paths on DAGs
   Visit vertices in *topological order* and relax *all outgoing edges* (works even if there are *negative edges*)
   #+DOWNLOADED: screenshot @ 2019-10-28 23:07:19
   [[file:pictures/L27_Reductions_and_Decomposition/screenshot_2019-10-28_23-07-19.png]]
   #+DOWNLOADED: screenshot @ 2019-10-28 23:07:48
   [[file:pictures/L27_Reductions_and_Decomposition/screenshot_2019-10-28_23-07-48.png]]
** Longest Paths
   #+DOWNLOADED: screenshot @ 2019-10-28 23:28:00
   [[file:pictures/L27_Reductions_and_Decomposition/screenshot_2019-10-28_23-28-00.png]]
   #+DOWNLOADED: screenshot @ 2019-10-28 23:28:59
   [[file:pictures/L27_Reductions_and_Decomposition/screenshot_2019-10-28_23-28-59.png]]
** Summary
   #+DOWNLOADED: screenshot @ 2019-10-28 23:33:38
   [[file:pictures/L27_Reductions_and_Decomposition/screenshot_2019-10-28_23-33-38.png]]
** Reduction                                                        :TOBEORG:
   #+DOWNLOADED: screenshot @ 2019-10-29 15:07:42
   [[file:pictures/L27_Reductions_and_Decomposition/2019-10-29_15-07-42_screenshot.png]]
   #+DOWNLOADED: screenshot @ 2019-10-29 15:08:14
   [[file:pictures/L27_Reductions_and_Decomposition/2019-10-29_15-08-14_screenshot.png]]
   #+DOWNLOADED: screenshot @ 2019-10-29 15:09:11
   [[file:pictures/L27_Reductions_and_Decomposition/2019-10-29_15-09-11_screenshot.png]]
** Question:                                                      :QUESTIONS:<<elink8>>
   - [ ] L23-L27中数据结构以及算法的实现：树 图
* L29 Basic Sorts
** Sorting Definitions
   #+DOWNLOADED: screenshot @ 2019-10-27 11:01:45
   file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_11-01-45.png
   - Java Note: Ordering relations are typically given in the form of ~compareTo~ or ~compare~ methods, not ~eqauls~
   - Another viewpoint: *inversion*
     #+DOWNLOADED: screenshot @ 2019-10-27 11:15:16
     [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_11-15-16.png]]
** Selection Sort, Heapsort
*** Selection Sort 
    #+DOWNLOADED: screenshot @ 2019-10-27 12:04:09
    [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_12-04-09.png]]
*** Heapsort
    #+DOWNLOADED: screenshot @ 2019-10-27 13:44:48
    [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_13-44-48.png]]
    - Naive Heapsort: Leveraging a *Max-Oriented Heap*
      #+DOWNLOADED: screenshot @ 2019-10-27 13:45:52
      [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_13-45-52.png]]
    
      - Runtime and memory usage
        #+DOWNLOADED: screenshot @ 2019-10-27 12:15:46
        [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_12-15-46.png]]
    - In-place Heapsort 
      #+DOWNLOADED: screenshot @ 2019-10-27 13:59:01
      [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_13-59-01.png]]
      #+DOWNLOADED: screenshot @ 2019-10-27 13:59:22
      [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_13-59-22.png]]
      - [[ilink16][Implementation]]
      - Runtime and memory usage
        #+DOWNLOADED: screenshot @ 2019-10-27 12:26:52
        [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_12-26-52.png]]
        #+DOWNLOADED: screenshot @ 2019-10-27 12:28:37
        [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_12-28-37.png]]
**** Question:                                                    :QUESTIONS:
     - [ ] In-place Heapsort 怎么理解？
** Mergesort
   #+DOWNLOADED: screenshot @ 2019-10-27 12:39:59
   [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_12-39-59.png]]
** Insertion Sort <<elink16>>
*** Naive 
    #+DOWNLOADED: screenshot @ 2019-10-27 13:23:49
    [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_13-23-49.png]]
*** In-place
    #+DOWNLOADED: screenshot @ 2019-10-27 13:33:41
    [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_13-33-41.png]]
    - 2 examples
      #+DOWNLOADED: screenshot @ 2019-10-27 13:36:13
      [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_13-36-13.png]]
    - Runtime
      $\Omega(N)$, $O(N^2)$
    - Sweet Spots
      #+DOWNLOADED: screenshot @ 2019-10-27 14:10:44
      [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_14-10-44.png]]
      #+DOWNLOADED: screenshot @ 2019-10-27 14:10:24
      [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_14-10-24.png]]
** Shell’s Sort (Extra)
   #+DOWNLOADED: screenshot @ 2019-10-27 14:19:39
   [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_14-19-39.png]]
   - Example
     #+DOWNLOADED: screenshot @ 2019-10-27 14:21:11
     [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_14-21-11.png]]
   - Generalization and Performance
     #+DOWNLOADED: screenshot @ 2019-10-27 14:24:15
     [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_14-24-15.png]]
** Sorts Performance Summary
   #+DOWNLOADED: screenshot @ 2019-10-27 14:12:07
   [[file:pictures/L29_Basic_Sorts/screenshot_2019-10-27_14-12-07.png]]
*** Question:                                                     :QUESTIONS:
    - [ ] 上图中时间、空间复杂度分析？
* L30 Quick Sort
  #+DOWNLOADED: screenshot @ 2019-10-27 16:47:14
  [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_16-47-14.png]]
** Quicksort
   Quicksorting N items:
   - Partition on leftmost item.
   - Quicksort left half.
   - Quicksort right half.
** Runtime
   #+DOWNLOADED: screenshot @ 2019-10-27 16:56:01
   [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_16-56-01.png]]
   - Intuition + empirical analysis
     - Argument #1: 10% Case
       #+DOWNLOADED: screenshot @ 2019-10-27 17:08:32
       [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_17-08-32.png]]
     - Argument #2: Quicksort is BST Sort
       #+DOWNLOADED: screenshot @ 2019-10-27 17:09:26
       [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_17-09-26.png]]
     - Empirical Quicksort Runtimes
       #+DOWNLOADED: screenshot @ 2019-10-27 17:09:54
       [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_17-09-54.png]]
** Avoiding the Quicksort Worst Case
   #+DOWNLOADED: screenshot @ 2019-10-27 17:54:10
   [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_17-54-10.png]]
   #+DOWNLOADED: screenshot @ 2019-10-27 17:54:37
   [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_17-54-37.png]]
*** 4 philosophies
    - Randomness
      #+DOWNLOADED: screenshot @ 2019-10-27 17:55:31
      file:pictures/L30_Quick_Sort/screenshot_2019-10-27_17-55-31.png
    - Smarter Pivot Selection <<ilink10>>
      - Constant time pivot pick
        #+DOWNLOADED: screenshot @ 2019-10-27 17:57:37
        [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_17-57-37.png]]
      - Linear time pivot pick
        #+DOWNLOADED: screenshot @ 2019-10-27 17:58:38
        [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_17-58-38.png]]
    - Introspection
      #+DOWNLOADED: screenshot @ 2019-10-27 18:00:34
      file:pictures/L30_Quick_Sort/screenshot_2019-10-27_18-00-34.png
*** Quicksort vs. Mergesort
    #+DOWNLOADED: screenshot @ 2019-10-27 18:39:49
    [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_18-39-49.png]]
    - Quicksort L3S
      #+DOWNLOADED: screenshot @ 2019-10-27 18:41:17
      [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_18-41-17.png]]
    - Quicksort LTHS (Hoare Partition)
      #+DOWNLOADED: screenshot @ 2019-10-27 18:54:45
      [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_18-54-45.png]]
      - *Pivot* is different with *pointer L* and *G*: *pivot = a[0] won't update* until *L and G crossing*, L initially points to *a[1]* and moves to right, while G to *a[n-1]* and moves to left
    - Quicksort PickTH: *Exact Median* as Pivot
      - Tips of an algorithm for finding the median of an array <<ilink11>>
        #+DOWNLOADED: screenshot @ 2019-10-27 19:09:03
        [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_19-09-03.png]]
*** Question:                                                     :QUESTIONS:
    - [ ] 上面 [[ilink10][Smarter Pivot]] 里的两种方法怎么理解？
    - [ ] [[ilink11][find the median]] 怎么理解和实现？
** Sorting Summary
   #+DOWNLOADED: screenshot @ 2019-10-27 17:37:17
   [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_17-37-17.png]]
   #+DOWNLOADED: screenshot @ 2019-10-27 18:04:50
   [[file:pictures/L30_Quick_Sort/screenshot_2019-10-27_18-04-50.png]]
*** Question:                                                     :QUESTIONS:
    - [ ] 上图中时间、空间复杂度分析？
    - [ ] Random Quicksort 和 Quicksort 差在哪里？
** Quick Select
   #+DOWNLOADED: screenshot @ 2019-10-28 09:04:48
   [[file:pictures/L30_Quick_Sort/screenshot_2019-10-28_09-04-48.png]]
*** Worst Performance 
    #+DOWNLOADED: screenshot @ 2019-10-28 09:05:14
    [[file:pictures/L30_Quick_Sort/screenshot_2019-10-28_09-05-14.png]]
*** Expected Performance
    #+DOWNLOADED: screenshot @ 2019-10-28 09:05:36
    [[file:pictures/L30_Quick_Sort/screenshot_2019-10-28_09-05-36.png]]
**** Question:                                                    :QUESTIONS:
     - [ ] 为啥 expected performance 是 $\Theta(N)$ ？
** Stability, Adaptiveness, Optimization
*** Stability 
    A sort is said to be *stable* if order of *equivalent* items is *preserved*.
    - Example
      #+DOWNLOADED: screenshot @ 2019-10-28 09:40:16
      [[file:pictures/L30_Quick_Sort/screenshot_2019-10-28_09-40-16.png]]
    - Summary
      #+DOWNLOADED: screenshot @ 2019-10-28 09:40:44
      [[file:pictures/L30_Quick_Sort/screenshot_2019-10-28_09-40-44.png]]
      - Notes for *Mergesort*: Fastest *stable* sort
*** Sorts optimization
     #+DOWNLOADED: screenshot @ 2019-10-28 09:46:28
     [[file:pictures/L30_Quick_Sort/screenshot_2019-10-28_09-46-28.png]]
     - ~Arrays.sort(someArray)~ uses
       - *Mergesort* (specifically the TimSort variant) if someArray consists of *Objects*.
       - *Quicksort* if someArray consists of *primitives*.
**** Question:                                                    :QUESTIONS:
     - [ ] Java 里的 ~Arrays.sort()~ 为什么要这么实现？参考 A level problems 在哪儿？
* L31 Software Engineering I                                        :TOBEORG:
* L32 More Quick Sort, Sorting Summary -> L30
* L33 Sorting and Algorithmic Bounds
** Math Problems out of Nowhere
   Given $log(N!) \in \Omega(NlogN)$ + $NlogN \in \Omega(log(N!))$ -> $log(N!) \in \Theta(NlogN)$ + $NlogN \in \Theta(log(N!))$
** Theoretical Bounds on Sorting
*** Decision Tree 
    #+DOWNLOADED: screenshot @ 2019-10-29 15:36:18
    [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_15-36-18_screenshot.png]]
    #+DOWNLOADED: screenshot @ 2019-10-29 15:37:15
    [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_15-37-15_screenshot.png]]
*** Reduce to Sorts
    #+DOWNLOADED: screenshot @ 2019-10-29 15:38:50
    [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_15-38-50_screenshot.png]]
    - *TUCS* refers to the ~compareTo~ method in Java to make decisions
    - Any *comparison based* sort requires at least order $N log N$ comparisons in its worst case.
    - *Heapsort, Mergesort and Quicksort LTHS* have achieved absolute *asymptotic optimality*, mathematically impossible to sort using fewer comparisons
    - *Randomized quicksort* is only *probabilistically optimal*, but the probability is extremely high for even modest $N$
    - *Not impossible* to sort in $\Theta(N)$ time, just can’t *compare* anything
** Sorting Implementations                                            :EXTRA:
   #+DOWNLOADED: screenshot @ 2019-10-29 15:59:57
   [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_15-59-57_screenshot.png]]
*** [[ilink13][Selection Sort]]
    #+DOWNLOADED: screenshot @ 2019-10-29 16:00:55
    [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_16-00-55_screenshot.png]]
*** Insertion Sort
    #+DOWNLOADED: screenshot @ 2019-10-29 16:01:28
    [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_16-01-28_screenshot.png]]
*** Selection and Insertion Sort Runtimes (Code Analysis)
    #+DOWNLOADED: screenshot @ 2019-10-29 16:02:33
    [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_16-02-33_screenshot.png]]
*** Mergesort
    - Merge Method
      #+DOWNLOADED: screenshot @ 2019-10-29 16:03:23
      [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_16-03-23_screenshot.png]]
    - Mergesort
      #+DOWNLOADED: screenshot @ 2019-10-29 16:03:56
      [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_16-03-56_screenshot.png]]
    - Interview Question
      #+DOWNLOADED: screenshot @ 2019-10-29 16:04:49
      [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_16-04-49_screenshot.png]]
*** Heapsort
    - Heapsort With Separate PQ
      #+DOWNLOADED: screenshot @ 2019-10-29 16:05:54
      [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_16-05-54_screenshot.png]]
    - In-Place Heapsort (with root in position 0). <<ilink16>>
      #+DOWNLOADED: screenshot @ 2019-10-29 16:06:39
      [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_16-06-39_screenshot.png]]
      - ~sink~
        #+DOWNLOADED: screenshot @ 2019-10-29 16:07:09
        [[file:pictures/L33_Sorting_and_Algorithmic_Bounds/2019-10-29_16-07-09_screenshot.png]]
* L34 Software Engineering II                                       :TOBEORG:
* L35 Radix Sorts                                                   :TOBEORG:
** Counting Sort
** LSD Radix Sort
** LSD Radix Sort vs. Comparison Sorting
** MSD Radix Sort
* L36 Sorting and Data Structures Conclusion                        :TOBEORG:
** Question:                                                      :QUESTIONS: <<elink9>>
   - [ ] L29-L36 各种 sort 的代码实现
* L37 Software Engineering III                                      :TOBEORG:
* L38 Compression                                                   :TOBEORG:
* L39 Compression, Complexity, and P=NP?                            :TOBEORG:
* L40 Summary, Fun                                                  :TOBEORG:
