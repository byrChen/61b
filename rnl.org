#+TAGS: QUESTIONS(q) OUTSTANDING(o)

* 1. Introduction to Java
** 1.1 Essentials
*** Hello World 

    #+begin_src java :classname HelloWorld
      public class HelloWorld {
          public static void main(String[] args) {
              System.out.println("Hello world!");
          }
      }
    #+end_src

    #+RESULTS:
    : Hello world!

    *Some key syntactic features*
    - The pg consists of a *class declaration*: ~public class~. In Java, all code lives *inside of classes*.
    - Code is running inside of a *method called main*: ~public static void main(String[] args)~.
    -  ~{~ and ~}~.
    - Semi-colons ~;~.
*** Running a Java Pg 
    *The most common way to execute a Java pg*: Compiler ~javac~ --> Interpreter ~java~

    #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/compilation_figure.svg @ 2019-03-01 10:36:13
    [[file:1.%20Introduction%20to%20Java/compilation_figure_2019-03-01_10-36-13.svg]]

    #+begin_src sh 
      javac HelloWorld.java 
      java HelloWorld
    #+end_src 
    
    #+RESULTS:
    : Hello world!

*** Vars and Loops

    #+begin_src java :classname HelloNumbers
      public class HelloNumbers {
          public static void main(String[] args) {
              int x = 0;
              while (x < 10) {
                  System.out.print(x + " ");
                  x = x + 1;
              }
          }
      }
    #+end_src 

    *Some interesting features of this pg* 
    - Var x *must declared and given a type* before *used*.
    - Loop def in ~{}~, boolean expression in ~()~.
    - ~System.out.print~ instead of ~System.out.println~, no new line.
    
**** Exercise 1.1.2 Modify ~HelloNumbers~ so that it prints out the cumulative sum of the integers from 0 to 9. For example, your output should start with 0 1 3 6 10... and should end with 45. 

     #+begin_src java :classname HelloNumbers
       public class HelloNumbers {
           public static void main(String[] args) {
               int x = 1;
               int sum = 0;
               while (sum < 46) {
                   System.out.print(sum + " ");
                   sum = x + sum;
                   x = x + 1;
               }
           }
       }
     #+end_src 

     #+RESULTS:
     : 0 1 3 6 10 15 21 28 36 45

*** Static Typing
    One of the most important features of Java is that *all vars and expressions* have a so-called ~static type~, the type of a var can *never change*.

    #+begin_src java :classname HelloNumbers
      public class HelloNumbers {
          public static void main(String[] args) {
              int x = 0;
              while (x < 10) {
                  System.out.print(x + " ");
                  x = x + 1;
              }
              x = "horse";
          }
      }
    #+end_src 

    #+RESULTS:

    *Static typing advs*
    - The *compiler* ensures that all *types are compatible*, easier to *debug*.
    - *Compiled* pgs will *never* run into *type errors*.
    - Every var, para, and func has *a declared type*, easier to understand and reason code.

    #+begin_src java :classname test
      public class test {
          public static void main(String[] args) {
              String h = 5 + "horse";
              System.out.print(h);
          }
      }
    #+end_src 

    #+RESULTS:
    : 5horse
    
    #+begin_src python :results output
      print(5+'horse')
    #+end_src 

    #+RESULTS:

    - For java, *stronly typed*, ~String~ can concatenate the elements into a str, while ~int~ can't concatenate a num and a str.
    - For python, type not constrained, ~5+'horse'~ errors. 

*** Def Funcs in Java

    #+begin_src python :results output
      def larger(x, y):
          if x > y:
              return x
          return y

      print(larger(8, 10))
    #+end_src 

    #+RESULTS:
    : 10

    #+begin_src java :classname LargerDemo
      public class LargerDemo {
          public static int larger(int x, int y) {
              if (x > y) {
                  return x;
              }
              return y;
          }

          public static void main(String[] args) {
              System.out.println(larger(8, 10));
          }
      }
    #+end_src 

    #+RESULTS:
    : 10

    - In python, funcs can be declared *anywhere*.
    - In java, java code is *part of a class*, funcs must defed *belong to some class* and called *methods*.
    - ~def~ in python, ~public static~ in java.  
*** Style Guide
** 1.2 Objects
*** Defining and Using Classes
**** Static vs. Non-Static Methods
***** Static Methods
      All code in Java must be *part of a class* (or something similar).

      #+begin_src java :classname Dog
        public class Dog {
            public static void makeNoise() {
                System.out.println("Bark!");
            }
        }
      #+end_src 
       
      #+begin_src java :classname DogLauncher
        public class DogLauncher {
            public static void main(String[] args) {
                Dog.makeNoise();
            }
        }
      #+end_src 

      - No ~main~ method in class ~Dog~. 
      - ~DogLauncher~ is a *client* of ~Dog~.
      - Neither or the two techniques(add ~main~ to ~Dog~ or create ~DogLauncher~) is better.
***** Instance Variables and Object Instantiation
****** Approach 1: create separate classes for each type of ~Dog~.
        
       #+begin_src java :classname TinyDog
         public class TinyDog {
             public static void makeNoise() {
                 System.out.println("yip yip yip yip");
             }
         }
       #+end_src 

       #+begin_src java :classname MalamuteDog
         public class MalamuteDog {
             public static void makeNoise() {
                 System.out.println("arooooooooooooooo!");
             }
         }
       #+end_src 

****** Approach 2: create instances of the ~Dog~ class and make the behavior of the ~Dog~ methods contingent upon the properties of the specific ~Dog~.

       #+begin_src java :classname Dog
         public class Dog {
             public int weightInPounds;

             public void makeNoise() {
                 if (weightInPounds < 10) {
                     System.out.println("yipyipyip!");
                 } else if (weightInPounds < 30) {
                     System.out.println("bark. bark.");
                 } else {
                     System.out.println("woof!");
                 }
             }
         }
       #+end_src 

       #+begin_src java :classname DogLauncher
         public class DogLauncher {
             public static void main(String[] args) {
                 Dog d;
                 d = new Dog();
                 d.weightInPounds = 20;
                 d.makeNoise();
             }
         }
       #+end_src 

****** Some key observations and terminology:
       - ~Object~ in Java is an *instance* of any class.
       - *Instance variables* or *non-static variables*: variables *must* be declared *inside the class* (new variables can be added at runtime in Python or Matlab).
       - *Instance methods* or *non-static methods* (no ~static~ keyword): methods created in class.
       - ~new~ to instantiate a ~class~.
       - *Instantiated object* can be assinged to a *declared* variable of the appropriate type: ~d = new Dog()~ 
***** Constructors in Java

      #+begin_src java :classname Dog
        public class Dog {
            public int weightInPounds;

            public Dog(int w) {
                weightInPounds = w;
            }

            public void makeNoise() {
                if (weightInPounds < 10) {
                    System.out.println("yipyipyip!");
                } else if (weightInPounds < 30) {
                    System.out.println("bark. bark.");
                } else {
                    System.out.println("woof!");
                }    
            }
        }
      #+end_src 

      #+begin_src java :classname DogLauncher
        public class DogLauncher {
            public static void main(String[] args) {
                Dog d = new Dog(20);
                d.makeNoise();
            }
        }
      #+end_src 
       
      - *Constructors* can save the time and messiness of manually typing out potentially many *instance variable assignments*.
      - The *constructor* with signature ~public Dog(int w)~ will be invoked anytime when ~new Dog(n)~.
      - Similar to ~__init__~ in Python.

***** Terminology Summary
***** Array Instantiation, Arrays of Objects
****** Array instantiation

       #+begin_src java :classname ArrayDemo
         public class ArrayDemo {
             public static void main(String[] args) {
                 /* Create an array of five integers. */
                 int[] someArray = new int[5];
                 someArray[0] = 3;
                 someArray[1] = 4;
             }
         }
       #+end_src 

****** Arrays of instantiated objects

       #+begin_src java :classname DogArrayDemo
         public class DogArrayDemo {
             public static void main(String[] args) {
                 /* Create an array of two dogs. */
                 Dog[] dogs = new Dog[2];
                 dogs[0] = new Dog(8);
                 dogs[1] = new Dog(20);

                 /* Yipping will result, since dogs[0] has weight 8. */
                 dogs[0].makeNoise();
             }
         }
       #+end_src 
        
       Two different ~new~:
       1. ~new Dog[2]~ to *create* an *array* that hold 2 ~Dog~ *objects(not instantiated)*.
       2. ~new Dog(8)~ to *instantiate* each ~Dog~ *object*.
**** Class Methods vs. Instance Methods
     Java allows us to define *2 types* of methods:
     1. *Class methods*, a.k.a *static* methods: *Static methods* are actions that are taken by the *class itself*.
     2. *Instance methods*, a.k.a *non-static* methods: *Instance methods* are actions that can be taken only by *a specific instance of a class*.
       
     #+begin_src java :classname Dog
       public class Dog {
           public int weightInPounds;

           public Dog(int w) {
               weightInPounds = w;
           }

           public void makeNoise() {
               if (weightInPounds < 10) {
                   System.out.println("yipyipyip!");
               } else if (weightInPounds < 30) {
                   System.out.println("bark. bark.");
               } else {
                   System.out.println("woof!");
               }
           }

           public static Dog maxDog(Dog d1, Dog d2) {
               if (d1.weightInPounds > d2.weightInPounds) {
                   return d1;
               }
               return d2;
           }

           public Dog maxDog(Dog d2) {
               if (this.weightInPounds > d2.weightInPounds) {
                   return this;
               }
               return d2;
           }

       }
      #+end_src 
       
     #+begin_src java :classname DogLauncher
        public class DogLauncher {
            public static void main(String[] args) {
                Dog d = new Dog(100);
                Dog d2 = new Dog(20);
                d.maxDog(d,d2);
                Dog.maxDog(d,d2);
            }
        }
      #+end_src
       
     - Class method: ~public static Dog maxDog~.
     - Instance method: ~public Dog maxDog~.
***** Exercise 1.2.1: What would the following method do? If you're not sure, try it out.        

      #+begin_src java :classname Dog
        public class Dog {
            public int weightInPounds;

            public Dog(int w) {
                weightInPounds = w;
            }

            public static Dog maxDog(Dog d1, Dog d2) {
                if (weightInPounds > d2.weightInPounds) {
                    return this;
                }
                return d2;
            }
        }
      #+end_src 
       
      ~javac Dog.java~ output: *non-static variable* this *cannot* be referenced from a *static context*.
      
***** Static Variables

      #+begin_src java :classname Dog
        public class Dog {
            public int weightInPounds;
            public static String binomen = "Canis familiaris";
            ...
        }
      #+end_src 

      - *Inherented* to *class it self* rather than the *instance* of class.
      - Usage: ~Dog.binomen~, not ~d.binomen~.
      - Java allows ~d.binomen~, a bad style. 
****** Exercise 1.2.2: Complete this exercise:

       #+begin_src java :classname Dog
         public class Dog {
             public int weightInPounds;

             public Dog(int w) {
                 weightInPounds = w;
             }

             public void makeNoise() {
                 if (weightInPounds < 10) {
                     System.out.println("yipyipyip!");
                 } else if (weightInPounds < 30) {
                     System.out.println("bark. bark.");
                 } else {
                     System.out.println("woof!");
                 }
             }

             public static Dog maxDog(Dog d1, Dog d2) {
                 if (d1.weightInPounds > d2.weightInPounds) {
                     return d1;
                 }
                 return d2;
             }

             public Dog maxDog(Dog d2) {
                 if (this.weightInPounds > d2.weightInPounds) {
                     return this;
                 }
                 return d2;
             }

         }
      #+end_src 
       
       #+begin_src java :classname Dogloop
         public class Dogloop {
             public static void main(String[] args) {
                 Dog smallDog = new Dog(5);
                 Dog mediumDog = new Dog(25);
                 Dog hugeDog = new Dog(150);

                 Dog[] manyDogs = new Dog[4];
                 manyDogs[0] = smallDog;
                 manyDogs[1] = hugeDog;
                 manyDogs[2] = new Dog(130);

                 int i = 0;
                 while (i < manyDogs.length) {
                     Dog.maxDog(manyDogs[i], mediumDog).makeNoise();
                     i = i + 1;
                 }
             }
         }
      #+end_src

******* Env analysis and output

        #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-17 14:43:29
        [[file:1.%20Introduction%20to%20Java/screenshot_2019-03-17_14-43-29.png]]
       
        #+begin_example
          bark. bark.
          woof!
          woof!
          Exception in thread "main" java.lang.NullPointerException
                  at Dog.maxDog(Dog.java:19)
                  at Dogloop.main(Dogloop.java:14)
        #+end_example
        
**** public static void main(String[] args)
     ~public static void main(String[] args)~:
     - ~public~: So far, all of *methods* start with ~public~.
     - ~static~: ~static~ method, not associated with *any particular instance*.
     - ~void~: No return type.
     - ~main~: Method's name.
     - ~String[] args~: A *para* passed to the ~main~ method.
***** Command Line Args
      Since ~main~ is called by the *Java interpreter itself(~javac~) rather than another Java class*, it is the *interpreter's job* to *supply these args*. They refer usually to the *command line arguments*. 

      #+begin_src java :classname 
        public class ArgsDemo {
            public static void main(String[] args) {
                System.out.println(args[0]);
            }
        }
      #+end_src 

      #+begin_src sh 
        java ArgsDemo these are command line args
      #+end_src 

      #+RESULTS:
      : these

      - ~args~ = ~{"these", "are", "command", "line", "args"}~
***** Summing Command Line Arguments
****** Exercise 1.2.3: try to write a program that sums up the command line arguments, assuming they are numbers. For a solution, see the webcast or the code provided on GitHub.

       #+begin_src java :classname argsum
         public class argsum {
             public static void main(String[] args) {
                 int i = 0;
                 int sum = 0;
                 while(i < args.length) {
                     sum += Integer.parseInt(args[i]);
                     i += 1;
                 }
                 System.out.print(sum);
             }
         }
       #+end_src 

       #+begin_src sh 
         java argsum 1 2 3 4 5 6
       #+end_src 

       #+RESULTS:
       : 21
 
       - ~Integer.parseInt(String)~: Convert ~String~ to a *primitive* ~int~ and *return* it.
**** Using Libraries
* 2. Lists
** 2.1 Mystery of the Walrus
*** Lists
    ~List~ could easily change the number of object after the simulation had begun.
**** The Mystery of the Walrus
     
     #+begin_src java :classname PollQuestions
       public class PollQuestions {
           public static void main(String[] args) {
               Walrus a = new Walrus(1000, 8.3);
               Walrus b;
               b = a;
               b.weight = 5;
               System.out.println(a);
               System.out.println(b);      

               int x = 5;
               int y;
               y = x;
               x = 2;
               System.out.println("x is: " + x);
               System.out.println("y is: " + y);      
           }

           public static class Walrus {
               public int weight;
               public double tuskSize;

               public Walrus(int w, double ts) {
                   weight = w;
                   tuskSize = ts;
               }

               public String toString() {
                   return String.format("weight: %d, tusk size: %.2f", weight, tuskSize);
               }
           }
       }
     #+end_src 

***** Env analysis

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-19 23:37:17
      [[file:2.%20Lists/screenshot_2019-03-19_23-37-17.png]]
 
**** Bits
     72 and 'H' both stored as 01001000 *in memory*, interpreter differs them by *type*.
     8 primitive types of Java: byte, short, int, long, float, double, boolean, and char.

     #+begin_src java :classname 
       char c = 'H';
       int x = c;
       System.out.println(c);
       System.out.println(x);
     #+end_src 

     #+begin_example output
       H
       72
     #+end_example

**** Declaring a Variable (Simplified)

     #+begin_src java :classname 
       int x;
       double y;
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-20 00:12:16
     [[file:2.%20Lists/screenshot_2019-03-20_00-12-16.png]]

     #+begin_src java :classname 
       x = -1431195969;
       y = 567213.112;
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-20 00:12:55
     [[file:2.%20Lists/screenshot_2019-03-20_00-12-55.png]]
 
     - When you *declare* a variable of a certain type, Java finds a *contiguous* block with exactly enough bits to hold a thing of that type.
     - In addition to setting aside memory, the Java interpreter also *creates an entry* in an *internal table* that *maps each variable name to the location of the first bit* in the box.
     - the *exact memory address* is *below the level of abstraction accessible* to us in Java
     - Java does not write anything into the *reserved* box when a variable is *declared*. Java compiler *prevents* you from using a variable until after the box has been filled with bits using the = operator.
     - The *top* bits represent -1431195969, and the *bottom* bits represent 567213.112. 

***** Simplified Box Notation

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-20 15:05:29
      [[file:2.%20Lists/screenshot_2019-03-20_15-05-29.png]]
 
**** The Golden Rule of Equals (GRoE)
     In Java, ~=~ for *any* assignment means *interpreter copying bits* from A into B.
**** Reference Types
     - ~primitive type~: ~byte~, ~short~, ~int~, ~long~, ~float~, ~double~, ~boolean~, ~char~.
     - ~reference type~: Everything else, including arrays.  
***** Object Instantiation

      #+begin_src java :classname 
        public static class Walrus {
            public int weight;
            public double tuskSize;

            public Walrus(int w, double ts) {
                weight = w;
                tuskSize = ts;
            }
        }
      #+end_src 
      
      Use ~new Walrus(1000, 8.3)~ 

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:08:50
      [[file:2.%20Lists/screenshot_2019-03-31_23-08-50.png]]
 
      In *real implementations* of the Java programming language, there is actually some *additional overhead* for any object, so a Walrus takes somewhat more than 96 bits. 
***** Reference Variable Declaration
      When a variable of *any reference type declared*, Java allocates *a box of 64 bits* to store the *address(fist bit)* of the variable *in memory*.

      1. ~Walrus someWalrus~: Creating a *box of 64 bits*.
      2. ~someWalrus = new Walrus(1000, 8.3)~: Creating a new ~Walrus~ and return its *address* by the ~new~ operator.
         - If Walrus ~weight~ is stored starting at bit ~5051956592385990207~ and ~tuskSize~ at ~5051956592385990239~ (more 32 bits than ~weight~, which is ~int~):
          
           #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:39:47
           [[file:2.%20Lists/screenshot_2019-03-31_23-39-47.png]]
          
         - Assigning ~null~ to a *reference variable* (such as ~someWalrus~):

           #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:41:47
           [[file:2.%20Lists/screenshot_2019-03-31_23-41-47.png]]
 
***** Box and Pointer Notation
       
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:45:22
      [[file:2.%20Lists/screenshot_2019-03-31_23-45-22.png]]
 
***** Resolving the Mystery of the Walrus

      #+begin_src java :classname 
        Walrus a = new Walrus(1000, 8.3);
        Walrus b;
        b = a;
      #+end_src 

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-04-01 00:28:59
      [[file:2.%20Lists/screenshot_2019-04-01_00-28-59.png]]
 
***** Question:                                                   :QUESTIONS:
      1. ~primitive type~ 变量存的是值而 ~reference type~ 变量存的是地址？
**** Parameter Passing
***** Test Your Understanding
****** Exercise 2.1.1

       #+begin_src java :classname PassByValueFigure
         public class PassByValueFigure {
             public static void main(String[] args) {
                 Walrus walrus = new Walrus(3500, 10.5);
                 int x = 9;

                 doStuff(walrus, x);
                 System.out.println(walrus);
                 System.out.println(x);
             }

             public static void doStuff(Walrus W, int x) {
                 W.weight = W.weight - 100;
                 x = x - 5;
             }
         }
       #+end_src 

       ~doStuff~ has an effect on only ~walrus~, not ~x~.

**** Instantiation of Arrays

      #+begin_src java :classname 
        int[] x; //declaration
        Planet[] planets;
        x = new int[]{0, 1, 2, 95, 4}; //instantiate
      #+end_src 

      - *Declaration* ~type[] x~ (~type~ can be ~primitive~ or ~reference~): creating memory boxes of *64 bits* to store *addresses*.
      - *Instantiation* ~x = new type[]{...}~: creating boxes of 32 bits each and returns the address of the overall object (this list) for assignment to x

**** IntLists

     #+begin_src java :classname 
       public class IntList {
           public int first;
           public IntList rest;        

           public IntList(int f, IntList r) {
               first = f;
               rest = r;
           }
       }
     #+end_src 
     
     to make a list of numbers 5, 10, and 15.

     #+begin_src java :classname 
       // build forwards
       IntList L = new IntList(5, null);
       L.rest = new IntList(10, null);
       L.rest.rest = new IntList(15, null);
       // or backwards
       IntList L = new IntList(15, null);
       L = new IntList(10, L);
       L = new IntList(5, L);
     #+end_src 

     above code is ugly and prone to errors -> adopt the *usual object oriented* programming strategy of *adding helper methods* to class to perform basic tasks
***** size and iterativeSize

     #+begin_src java :classname 
       public int size() {
           if (rest == null) {
               return 1;
           }
           return 1 + this.rest.size();
       }
       //iterative size
       public int iterativeSize() {
           IntList p = this;
           int totalSize = 0;
           while (p != null) {
               totalSize += 1;
               p = p.rest;
           }
           return totalSize;
       }
     #+end_src 
 
     - ~if (this == null) return 0;~ leads to ~NullPointer error~
     - use ~p~ for ~pointer~ in ~iterativeSize~ as ~this~ *can't be reassigned* in Java.    
***** get

      #+begin_src java :classname 
        public class IntList {
            public int first;
            public IntList rest;

            public IntList(int f, IntList r) {
                first = f;
                rest = r;
            }

            public int get(int i) {
                if (i == 0) {
                    return first;
                }
                return rest.get(i - 1);
            }
        }
      #+end_src 

***** Question:                                                   :QUESTIONS:
      1. 如果获取函数 ~get(-1)~ 该怎么处理
* 3. Testing
** 3.1 A New Way
* 4. Inheritance, Implements



* 1. Intro, Hello World Java
* 2. Defining and Using Classes

