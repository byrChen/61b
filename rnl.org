#+TAGS: QUESTIONS(q) OUTSTANDING(o)

* 1. Introduction to Java
** 1.1 Essentials
*** Hello World 

    #+begin_src java :classname HelloWorld
      public class HelloWorld {
          public static void main(String[] args) {
              System.out.println("Hello world!");
          }
      }
    #+end_src

    #+RESULTS:
    : Hello world!

    *Some key syntactic features*
    - The pg consists of a *class declaration*: ~public class~. In Java, all code lives *inside of classes*.
    - Code is running inside of a *method called main*: ~public static void main(String[] args)~.
    -  ~{~ and ~}~.
    - Semi-colons ~;~.
*** Running a Java Pg 
    *The most common way to execute a Java pg*: Compiler ~javac~ --> Interpreter ~java~

    #+DOWNLOADED: https://joshhug.gitbooks.io/hug61b/content/assets/compilation_figure.svg @ 2019-03-01 10:36:13
    [[file:1.%20Introduction%20to%20Java/compilation_figure_2019-03-01_10-36-13.svg]]

    #+begin_src sh 
      javac HelloWorld.java 
      java HelloWorld
    #+end_src 
    
    #+RESULTS:
    : Hello world!

*** Vars and Loops

    #+begin_src java :classname HelloNumbers
      public class HelloNumbers {
          public static void main(String[] args) {
              int x = 0;
              while (x < 10) {
                  System.out.print(x + " ");
                  x = x + 1;
              }
          }
      }
    #+end_src 

    *Some interesting features of this pg* 
    - Var x *must declared and given a type* before *used*.
    - Loop def in ~{}~, boolean expression in ~()~.
    - ~System.out.print~ instead of ~System.out.println~, no new line.
    
**** Exercise 1.1.2 Modify ~HelloNumbers~ so that it prints out the cumulative sum of the integers from 0 to 9. For example, your output should start with 0 1 3 6 10... and should end with 45. 

     #+begin_src java :classname HelloNumbers
       public class HelloNumbers {
           public static void main(String[] args) {
               int x = 1;
               int sum = 0;
               while (sum < 46) {
                   System.out.print(sum + " ");
                   sum = x + sum;
                   x = x + 1;
               }
           }
       }
     #+end_src 

     #+RESULTS:
     : 0 1 3 6 10 15 21 28 36 45

*** Static Typing
    One of the most important features of Java is that *all vars and expressions* have a so-called ~static type~, the type of a var can *never change*.
    #+begin_src java :classname HelloNumbers
      public class HelloNumbers {
          public static void main(String[] args) {
              int x = 0;
              while (x < 10) {
                  System.out.print(x + " ");
                  x = x + 1;
              }
              x = "horse";
          }
      }
    #+end_src 
    - *Static typing advs*
      - The *compiler* ensures that all *types are compatible*, easier to *debug*.
      - *Compiled* programs will *never* run into *type errors*.
      - Every var, para, and func has *a declared type*, easier to understand and reason code.
    #+begin_src java :classname test
      public class test {
          public static void main(String[] args) {
              String h = 5 + "horse";
              System.out.print(h);
          }
      }
    #+end_src 
    #+begin_src python :results output
      print(5+'horse')
    #+end_src 
    - For java, *stronly typed*, ~String~ can concatenate the elements into a str, while ~int~ can't concatenate a num and a str.
    - For python, type not constrained, ~5+'horse'~ errors. 
*** Def Funcs in Java
    #+begin_src python :results output
      def larger(x, y):
          if x > y:
              return x
          return y

      print(larger(8, 10))
    #+end_src 
    #+begin_src java :classname LargerDemo
      public class LargerDemo {
          public static int larger(int x, int y) {
              if (x > y) {
                  return x;
              }
              return y;
          }

          public static void main(String[] args) {
              System.out.println(larger(8, 10));
          }
      }
    #+end_src 
    - In python, funcs can be declared *anywhere*.
    - In java, java code is *part of a class*, funcs must defed *belong to some class* and called *methods*.
    - ~def~ in python, ~public static~ in java.  
*** Style Guide
** 1.2 Objects
*** Defining and Using Classes
**** Static vs. Non-Static Methods
***** Static Methods
      All code in Java must be *part of a class* (or something similar).
      #+begin_src java :classname Dog
        public class Dog {
            public static void makeNoise() {
                System.out.println("Bark!");
            }
        }
      #+end_src 
      #+begin_src java :classname DogLauncher
        public class DogLauncher {
            public static void main(String[] args) {
                Dog.makeNoise();
            }
        }
      #+end_src 
      - No ~main~ method in class ~Dog~. 
      - ~DogLauncher~ is a *client* of ~Dog~.
      - Neither or the two techniques(add ~main~ to ~Dog~ or create ~DogLauncher~) is better.
***** Instance Variables and Object Instantiation
****** Approach 1: create separate classes for each type of ~Dog~.
       #+begin_src java :classname TinyDog
         public class TinyDog {
             public static void makeNoise() {
                 System.out.println("yip yip yip yip");
             }
         }
       #+end_src 
       #+begin_src java :classname MalamuteDog
         public class MalamuteDog {
             public static void makeNoise() {
                 System.out.println("arooooooooooooooo!");
             }
         }
       #+end_src 
****** Approach 2: create instances of the ~Dog~ class and make the behavior of the ~Dog~ methods contingent upon the properties of the specific ~Dog~.
       #+begin_src java :classname Dog
         public class Dog {
             public int weightInPounds;

             public void makeNoise() {
                 if (weightInPounds < 10) {
                     System.out.println("yipyipyip!");
                 } else if (weightInPounds < 30) {
                     System.out.println("bark. bark.");
                 } else {
                     System.out.println("woof!");
                 }
             }
         }
       #+end_src 
       #+begin_src java :classname DogLauncher
         public class DogLauncher {
             public static void main(String[] args) {
                 Dog d;
                 d = new Dog();
                 d.weightInPounds = 20;
                 d.makeNoise();
             }
         }
       #+end_src 
****** Some key observations and terminology:
       - ~Object~ in Java is an *instance* of any class.
       - *Instance variables* or *non-static variables*: variables *must* be declared *inside the class* (new variables can be added at runtime in Python or Matlab).
       - *Instance methods* or *non-static methods* (no ~static~ keyword): methods created in class.
       - ~new~ to instantiate a ~class~.
       - *Instantiated object* can be assinged to a *declared* variable of the appropriate type: ~d = new Dog()~ 
***** Constructors in Java
      #+begin_src java :classname Dog
        public class Dog {
            public int weightInPounds;

            public Dog(int w) {
                weightInPounds = w;
            }

            public void makeNoise() {
                if (weightInPounds < 10) {
                    System.out.println("yipyipyip!");
                } else if (weightInPounds < 30) {
                    System.out.println("bark. bark.");
                } else {
                    System.out.println("woof!");
                }    
            }
        }
      #+end_src 
      #+begin_src java :classname DogLauncher
        public class DogLauncher {
            public static void main(String[] args) {
                Dog d = new Dog(20);
                d.makeNoise();
            }
        }
      #+end_src 
      - *Constructors* can save the time and messiness of manually typing out potentially many *instance variable assignments*.
      - The *constructor* with signature ~public Dog(int w)~ will be invoked anytime when ~new Dog(n)~.
      - Similar to ~__init__~ in Python.
***** Terminology Summary
***** Array Instantiation, Arrays of Objects
****** Array instantiation
       #+begin_src java :classname ArrayDemo
         public class ArrayDemo {
             public static void main(String[] args) {
                 /* Create an array of five integers. */
                 int[] someArray = new int[5];
                 someArray[0] = 3;
                 someArray[1] = 4;
             }
         }
       #+end_src 
****** Arrays of instantiated objects
       #+begin_src java :classname DogArrayDemo
         public class DogArrayDemo {
             public static void main(String[] args) {
                 /* Create an array of two dogs. */
                 Dog[] dogs = new Dog[2];
                 dogs[0] = new Dog(8);
                 dogs[1] = new Dog(20);

                 /* Yipping will result, since dogs[0] has weight 8. */
                 dogs[0].makeNoise();
             }
         }
       #+end_src 
       - ~class[] var = new class[n]~ for lists
       - Two different ~new~:
         1. ~new Dog[2]~ to *create* an *array* that hold 2 ~Dog~ *objects(not instantiated)*.
         2. ~new Dog(8)~ to *instantiate* each ~Dog~ *object*.
**** Class Methods vs. Instance Methods
     Java allows us to define *2 types* of methods:
     1. *Class methods*, a.k.a *static* methods: *Static methods* are actions that are taken by the *class itself*.
     2. *Instance methods*, a.k.a *non-static* methods: *Instance methods* are actions that can be taken only by *a specific instance of a class*.
     #+begin_src java :classname Dog
       public class Dog {
           public int weightInPounds;

           public Dog(int w) {
               weightInPounds = w;
           }

           public void makeNoise() {
               if (weightInPounds < 10) {
                   System.out.println("yipyipyip!");
               } else if (weightInPounds < 30) {
                   System.out.println("bark. bark.");
               } else {
                   System.out.println("woof!");
               }
           }

           public static Dog maxDog(Dog d1, Dog d2) {
               if (d1.weightInPounds > d2.weightInPounds) {
                   return d1;
               }
               return d2;
           }

           public Dog maxDog(Dog d2) {
               if (this.weightInPounds > d2.weightInPounds) {
                   return this;
               }
               return d2;
           }

       }
      #+end_src 
       
     #+begin_src java :classname DogLauncher
        public class DogLauncher {
            public static void main(String[] args) {
                Dog d = new Dog(100);
                Dog d2 = new Dog(20);
                d.maxDog(d,d2);
                Dog.maxDog(d,d2);
            }
        }
      #+end_src
       
     - Class method: ~public static Dog maxDog~.
     - Instance method: ~public Dog maxDog~.
***** Exercise 1.2.1: What would the following method do? If you're not sure, try it out.        

      #+begin_src java :classname Dog
        public class Dog {
            public int weightInPounds;

            public Dog(int w) {
                weightInPounds = w;
            }

            public static Dog maxDog(Dog d1, Dog d2) {
                if (weightInPounds > d2.weightInPounds) {
                    return this;
                }
                return d2;
            }
        }
      #+end_src 
       
      ~javac Dog.java~ output: *non-static variable* this *cannot* be referenced from a *static context*.
      
***** Static Variables

      #+begin_src java :classname Dog
        public class Dog {
            public int weightInPounds;
            public static String binomen = "Canis familiaris";
            ...
        }
      #+end_src 

      - *Inherented* to *class itself* rather than the *instance* of class.
      - Usage: ~Dog.binomen~, not ~d.binomen~.
      - Java allows ~d.binomen~, a bad style. 
****** Exercise 1.2.2: Complete this exercise:

       #+begin_src java :classname Dog
         public class Dog {
             public int weightInPounds;

             public Dog(int w) {
                 weightInPounds = w;
             }

             public void makeNoise() {
                 if (weightInPounds < 10) {
                     System.out.println("yipyipyip!");
                 } else if (weightInPounds < 30) {
                     System.out.println("bark. bark.");
                 } else {
                     System.out.println("woof!");
                 }
             }

             public static Dog maxDog(Dog d1, Dog d2) {
                 if (d1.weightInPounds > d2.weightInPounds) {
                     return d1;
                 }
                 return d2;
             }

             public Dog maxDog(Dog d2) {
                 if (this.weightInPounds > d2.weightInPounds) {
                     return this;
                 }
                 return d2;
             }

         }
      #+end_src 
       
       #+begin_src java :classname Dogloop
         public class Dogloop {
             public static void main(String[] args) {
                 Dog smallDog = new Dog(5);
                 Dog mediumDog = new Dog(25);
                 Dog hugeDog = new Dog(150);

                 Dog[] manyDogs = new Dog[4];
                 manyDogs[0] = smallDog;
                 manyDogs[1] = hugeDog;
                 manyDogs[2] = new Dog(130);

                 int i = 0;
                 while (i < manyDogs.length) {
                     Dog.maxDog(manyDogs[i], mediumDog).makeNoise();
                     i = i + 1;
                 }
             }
         }
      #+end_src

******* Env analysis and output

        #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-17 14:43:29
        [[file:1.%20Introduction%20to%20Java/screenshot_2019-03-17_14-43-29.png]]
       
        #+begin_example
          bark. bark.
          woof!
          woof!
          Exception in thread "main" java.lang.NullPointerException
                  at Dog.maxDog(Dog.java:19)
                  at Dogloop.main(Dogloop.java:14)
        #+end_example
        
**** public static void main(String[] args)
     ~public static void main(String[] args)~:
     - ~public~: So far, all of *methods* start with ~public~.
     - ~static~: ~static~ method, not associated with *any particular instance*.
     - ~void~: No return type.
     - ~main~: Method's name.
     - ~String[] args~: A *para* passed to the ~main~ method.
***** Command Line Args
      Since ~main~ is called by the *Java interpreter itself(~javac~) rather than another Java class*, it is the *interpreter's job* to *supply these args*. They refer usually to the *command line arguments*. 

      #+begin_src java :classname 
        public class ArgsDemo {
            public static void main(String[] args) {
                System.out.println(args[0]);
            }
        }
      #+end_src 

      #+begin_src sh 
        java ArgsDemo these are command line args
      #+end_src 

      #+RESULTS:
      : these

      - ~args~ = ~{"these", "are", "command", "line", "args"}~
***** Summing Command Line Arguments
****** Exercise 1.2.3: try to write a program that sums up the command line arguments, assuming they are numbers. For a solution, see the webcast or the code provided on GitHub.

       #+begin_src java :classname argsum
         public class argsum {
             public static void main(String[] args) {
                 int i = 0;
                 int sum = 0;
                 while(i < args.length) {
                     sum += Integer.parseInt(args[i]);
                     i += 1;
                 }
                 System.out.print(sum);
             }
         }
       #+end_src 

       #+begin_src sh 
         java argsum 1 2 3 4 5 6
       #+end_src 

       #+RESULTS:
       : 21
 
       - ~Integer.parseInt(String)~: Convert ~String~ to a *primitive* ~int~ and *return* it.
**** Using Libraries
* 2. Lists
** 2.1 Mystery of the Walrus
*** Lists
    ~List~ could easily change the number of object after the simulation had begun.
**** The Mystery of the Walrus
     
     #+begin_src java :classname PollQuestions
       public class PollQuestions {
           public static void main(String[] args) {
               Walrus a = new Walrus(1000, 8.3);
               Walrus b;
               b = a;
               b.weight = 5;
               System.out.println(a);
               System.out.println(b);      

               int x = 5;
               int y;
               y = x;
               x = 2;
               System.out.println("x is: " + x);
               System.out.println("y is: " + y);      
           }

           public static class Walrus {
               public int weight;
               public double tuskSize;

               public Walrus(int w, double ts) {
                   weight = w;
                   tuskSize = ts;
               }

               public String toString() {
                   return String.format("weight: %d, tusk size: %.2f", weight, tuskSize);
               }
           }
       }
     #+end_src 

***** Env analysis

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-19 23:37:17
      [[file:2.%20Lists/screenshot_2019-03-19_23-37-17.png]]
 
**** Bits
     72 and 'H' both stored as 01001000 *in memory*, interpreter differs them by *type*.
     8 primitive types of Java: byte, short, int, long, float, double, boolean, and char.

     #+begin_src java :classname 
       char c = 'H';
       int x = c;
       System.out.println(c);
       System.out.println(x);
     #+end_src 

     #+begin_example output
       H
       72
     #+end_example

**** Declaring a Variable (Simplified)

     #+begin_src java :classname 
       int x;
       double y;
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-20 00:12:16
     [[file:2.%20Lists/screenshot_2019-03-20_00-12-16.png]]

     #+begin_src java :classname 
       x = -1431195969;
       y = 567213.112;
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-20 00:12:55
     [[file:2.%20Lists/screenshot_2019-03-20_00-12-55.png]]
 
     - When you *declare* a variable of a certain type, Java finds a *contiguous* block with exactly enough bits to hold a thing of that type.
     - In addition to setting aside memory, the Java interpreter also *creates an entry* in an *internal table* that *maps each variable name to the location of the first bit* in the box.
     - the *exact memory address* is *below the level of abstraction accessible* to us in Java
     - Java does not write anything into the *reserved* box when a variable is *declared*. Java compiler *prevents* you from using a variable until after the box has been filled with bits using the = operator.
     - The *top* bits represent -1431195969, and the *bottom* bits represent 567213.112. 

***** Simplified Box Notation

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-20 15:05:29
      [[file:2.%20Lists/screenshot_2019-03-20_15-05-29.png]]
 
**** The Golden Rule of Equals (GRoE)
     In Java, ~=~ for *any* assignment means *interpreter copying bits* from A into B.
**** Reference Types
     - ~primitive type~: ~byte~, ~short~, ~int~, ~long~, ~float~, ~double~, ~boolean~, ~char~.
     - ~reference type~: Everything else, including arrays.  
***** Object Instantiation

      #+begin_src java :classname 
        public static class Walrus {
            public int weight;
            public double tuskSize;

            public Walrus(int w, double ts) {
                weight = w;
                tuskSize = ts;
            }
        }
      #+end_src 
      
      Use ~new Walrus(1000, 8.3)~ 

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:08:50
      [[file:2.%20Lists/screenshot_2019-03-31_23-08-50.png]]
 
      In *real implementations* of the Java programming language, there is actually some *additional overhead* for any object, so a Walrus takes somewhat more than 96 bits. 
***** Reference Variable Declaration
      When a variable of *any reference type declared*, Java allocates *a box of 64 bits* to store the *address(fist bit)* of the variable *in memory*.

      1. ~Walrus someWalrus~: Creating a *box of 64 bits*.
      2. ~someWalrus = new Walrus(1000, 8.3)~: Creating a new ~Walrus~ and return its *address* by the ~new~ operator.
         - If Walrus ~weight~ is stored starting at bit ~5051956592385990207~ and ~tuskSize~ at ~5051956592385990239~ (more 32 bits than ~weight~, which is ~int~):
          
           #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:39:47
           [[file:2.%20Lists/screenshot_2019-03-31_23-39-47.png]]
          
         - Assigning ~null~ to a *reference variable* (such as ~someWalrus~):

           #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:41:47
           [[file:2.%20Lists/screenshot_2019-03-31_23-41-47.png]]
 
***** Box and Pointer Notation
       
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-03-31 23:45:22
      [[file:2.%20Lists/screenshot_2019-03-31_23-45-22.png]]
 
***** Resolving the Mystery of the Walrus

      #+begin_src java :classname 
        Walrus a = new Walrus(1000, 8.3);
        Walrus b;
        b = a;
      #+end_src 

      #+DOWNLOADED: /tmp/screenshot.png @ 2019-04-01 00:28:59
      [[file:2.%20Lists/screenshot_2019-04-01_00-28-59.png]]
 
***** Question:                                                   :QUESTIONS:
      1. ~primitive type~ 变量存的是值而 ~reference type~ 变量存的是地址？
**** Parameter Passing
***** Test Your Understanding
****** Exercise 2.1.1

       #+begin_src java :classname PassByValueFigure
         public class PassByValueFigure {
             public static void main(String[] args) {
                 Walrus walrus = new Walrus(3500, 10.5);
                 int x = 9;

                 doStuff(walrus, x);
                 System.out.println(walrus);
                 System.out.println(x);
             }

             public static void doStuff(Walrus W, int x) {
                 W.weight = W.weight - 100;
                 x = x - 5;
             }
         }
       #+end_src 

       ~doStuff~ has an effect on only ~walrus~, not ~x~.

**** Instantiation of Arrays

      #+begin_src java :classname 
        int[] x; //declaration
        Planet[] planets;
        x = new int[]{0, 1, 2, 95, 4}; //instantiate
      #+end_src 

      - *Declaration* ~type[] x~ (~type~ can be ~primitive~ or ~reference~): creating memory boxes of *64 bits* to store *addresses*.
      - *Instantiation* ~x = new type[]{...}~: creating boxes of 32 bits each and returns the address of the overall object (this list) for assignment to x

**** IntLists

     #+begin_src java :classname 
       public class IntList {
           public int first;
           public IntList rest;        

           public IntList(int f, IntList r) {
               first = f;
               rest = r;
           }
       }
     #+end_src 
     
     to make a list of numbers 5, 10, and 15.

     #+begin_src java :classname 
       // build forwards
       IntList L = new IntList(5, null);
       L.rest = new IntList(10, null);
       L.rest.rest = new IntList(15, null);
       // or backwards
       IntList L = new IntList(15, null);
       L = new IntList(10, L);
       L = new IntList(5, L);
     #+end_src 

     above code is ugly and prone to errors -> adopt the *usual object oriented* programming strategy of *adding helper methods* to class to perform basic tasks
***** size and iterativeSize (helper methods)

     #+begin_src java :classname 
       public int size() {
           if (rest == null) {
               return 1;
           }
           return 1 + this.rest.size();
       }
       //iterative size
       public int iterativeSize() {
           IntList p = this;
           int totalSize = 0;
           while (p != null) {
               totalSize += 1;
               p = p.rest;
           }
           return totalSize;
       }
     #+end_src 
 
     - ~if (this == null) return 0;~ leads to ~NullPointer error~
     - use ~p~ for ~pointer~ in ~iterativeSize~ as ~this~ *can't be reassigned* in Java.    
***** get

      #+begin_src java :classname 
        public class IntList {
            public int first;
            public IntList rest;

            public IntList(int f, IntList r) {
                first = f;
                rest = r;
            }

            public int get(int i) {
                if (i == 0) {
                    return first;
                }
                return rest.get(i - 1);
            }
        }
      #+end_src 

***** Question:                                                   :QUESTIONS:
      1. 如果获取函数 ~get(-1)~ 该怎么处理
** 2.2 The SLList
*** SLLists
    ~IntList~ is a *naked recursive* data structure 
**** Improvement #1: Rebranding

     #+begin_src java :classname 
       public class IntNode {
           public int item;
           public IntNode next;

           public IntNode(int i, IntNode n) {
               item = i;
               next = n;
           }
       }
     #+end_src 

**** Improvement #2: Bureaucracy

     #+begin_src java :classname 
       public class SLList {
           public IntNode first;

           public SLList(int x) {
               first = new IntNode(x, null);
           }
       }
     #+end_src 

     #+begin_src java :classname 
       IntList L1 = new IntList(5, null);
       SLList L2  = new SLList(5);
     #+end_src 
     
     ~SLList~ *hides* the detail that there exists a *null link* from the user 
**** addFirst and getFirst

     #+begin_src java :classname 
       public class SLList {
           public IntNode first;

           public SLList(int x) {
               first = new IntNode(x, null);
           }

           /** Adds an item to the front of the list. */
           public void addFirst(int x) {
               first = new IntNode(x, first);
           }

           public int getFirst() {
               return first.item;
           }
       }
     #+end_src 

     #+begin_src java :classname 
       // IntList
       IntList L = new IntList(15, null);
       L = new IntList(10, L);
       L = new IntList(5, L);
       int x = L.first;
       // SLList 
       SLList L = new SLList(15);
       L.addFirst(10);
       L.addFirst(5);
       int x = L.getFirst()
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-05-30 23:43:42
     [[file:2._Lists/screenshot_2019-05-30_23-43-42.png]]

     - ~SLList~ class acts as a *middleman* between the *list user* and the *naked recursive data structure*
     - ~IntList~ user may have a potentially *undesireable* possibility to have *extra* variables that point to the middle of the ~IntList~
      
       #+begin_src java :classname 
         IntList L = new IntList(15, null);
         L2 = new IntList(10, L);
         L1 = new IntList(5, L2);
       #+end_src 

***** Exercise 2.2.1: Try to write an ~addFirst~ method to the ~IntList~ class (tricky as well as inefficient)
      
      #+begin_src java :classname 
        public class IntList {
            public int first;
            public IntList rest;        

            public IntList(int f, IntList r) {
                first = f;
                rest = r;
            }

            public void addFirst(int x, IntList L) {
                rest = L;
                first = x;
            }
        }
      #+end_src 

      #+begin_src java :classname 
        L = new IntList(15, null);
        L.addFirst(10, L);
        L.addFirst(5, L);
        int x = L.first
      #+end_src 

**** Improvement #3: Public vs. Private
     ~SLList~ can be *bypassed* and the *raw power* of *naked data structure* (with all its dangers) can be accessed. A programmer can easily modify the list *directly*, without going through the *kid-tested*, *mother-approved* ~addFirst~ method, for example:
     #+begin_src java :classname 
       SLList L = new SLList(15);
       L.addFirst(10);
       L.first.next.next = L.first.next;
     #+end_src 

     #+DOWNLOADED: /tmp/screenshot.png @ 2019-05-31 00:15:38
     [[file:2._Lists/screenshot_2019-05-31_00-15-38.png]]
 
     - This results in a malformed list with an infinite loop -> to deal with, change ~public IntNode first~ to ~private IntNode first~
     - ~Private~ *variables and methods* can only be accessed by code inside the *same* ~.java~ file
**** Improvement #4: Nested Classes
     #+begin_src java :classname 
       public class SLList {
           public static class IntNode {
               public int item;
               public IntNode next;
               public IntNode(int i, IntNode n) {
                   item = i;
                   next = n;
               }
           }

           private IntNode first;
           ...
     #+end_src 
     - ~static~ means that *methods* inside the ~static~ class can not access any of the *members* of the *enclosing class*
***** Exercise 2.2.2
      
      #+begin_src java :classname 
        /** A rather contrived exercise to test your understanding of when
            nested classes may be made static. This is NOT an example of good
            class design, even after you fix the bug.

            The challenge with this file is to delete the keyword static the
            minimum number of times so that the code compiles.

            Guess before TRYING to compile, otherwise the compiler will spoil
            the problem.*/
        public class Government {
          private int treasury = 5;

          private void spend() {
            treasury -= 1;
          }

          private void tax() {
            treasury += 1;
          }

          public void report() {
            System.out.println(treasury);
          }

          public static Government greaterTreasury(Government a, Government b) {
            if (a.treasury > b.treasury) {
              return a;
            }
            return b;
          }

          public static class Peasant {
            public void doStuff() {
              System.out.println("hello");			
            }
          }

          public static class King { 
            public void doStuff() {
              spend();			
            }
          }

          public static class Mayor {
            public void doStuff() {
              tax();			
            }
          }

          public static class Accountant {
            public void doStuff() {
              report();			
            }
          }

          public static class Thief {
            public void doStuff() {
              treasury = 0;			
            }
          }

          public static class Explorer {
            public void doStuff(Government a, Government b) {
              Government favorite = Government.greaterTreasury(a, b);
              System.out.println("The best government has treasury " + favorite.treasury);			
            }
          }
        }
      #+end_src 
      
      - Extra ~static class~: ~King~, ~Mayor~, ~Accountant~, ~Thief~
      - ~Explorer~ is ok because it accesses ~greaterTreasury~ and ~treasury~ through ~Government favorite~, instead of *directly*.    

**** addLast() and size()
     - ~addLast~ 
       #+begin_src java :classname 
         /** Adds an item to the end of the list. */
         public void addLast(int x) {
             IntNode p = first;

             /* Advance p to the end of the list. */
             while (p.next != null) {
                 p = p.next;
             }
             p.next = new IntNode(x, null);
         }
       #+end_src 
     - ~private static int size(IntNode p)~: Returns the size of the list *starting* at ~IntNode p~
       #+begin_src java :classname 
         /** Returns the size of the list starting at IntNode p. */
         private static int size(IntNode p) {
             if (p.next == null) {
                 return 1;
             }

             return 1 + size(p.next);
         }
       #+end_src
       - A *private helper* (~SLList~) method that interacts with the underlying *naked recursive* data structure (~IntNode~) 
       - *Recursive*: ~return 1 + size(p.next)~
       - ~private~: variables and methods can only be accessed by code inside the *same* ~.java~ file
       - ~static~: variables and methods *inherented to class itself* rather than *instances of class* 
     - ~public int size()~: Returns the size of the *whole* list (starting at ~first~)  
       #+begin_src java :classname 
         public int size() {
             return size(first);
         }
       #+end_src
       - ~size()~ and ~size(IntNode p)~: *overloaded* with the same name but *different signatures*  

**** Improvement #5: Caching
     add a ~size~ variable to the ~SLList~ class that tracks the current size. This practice of *saving important data to speed up retrieval* is sometimes known as *caching*.
     #+begin_src java :classname 
       public class SLList {
           ... /* IntNode declaration omitted. */
           private IntNode first;
           private int size;

           public SLList(int x) {
               first = new IntNode(x, null);
               size = 1;
           }

           public void addFirst(int x) {
               first = new IntNode(x, first);
               size += 1;
           }

           public int size() {
               return size;
           }
           ...
       }
     #+end_src 
     - make ~size()~ incredibly fast no matter how large the list
     - slow down ~addFirst~ and ~addLast~ method
     - increase memory of usage of ~SLList~ class 

**** Improvement #6: The Empty List
     #+begin_src java :classname 
       public class SLList {
           ...
           public SLList() {
               first = null;
               size = 0;
           }

           public SLList(int x) {
               first = new IntNode(x, null);
               size = 1;
           }

           /** Adds an item to the end of the list. */
           public void addLast(int x) {
               size += 1
               if (first == Null) {
                   first = new IntNode(x, Null);
                   return;
               }
               IntNode p = first;

               /* Advance p to the end of the list. */
               while (p.next != null) {
                   p = p.next;
               }
               p.next = new IntNode(x, null);
           }

           /** Crashes when you call addLast on an empty SLList. Fix it. */
           public static void main(String[] args) {
               SLList x = new SLList();
               x.addLast(5);
           }
       }
     #+end_src 
     - ~SLList(int x)~ and ~SLList~ *overloaded*
     - ~addLast~ crashes on *empty* SLList
***** Question:                                                   :QUESTIONS:
      1. java里的 ~this~ 怎么用？可以来解决 ~addLast~ ？  
**** Improvement #6b: Sentinel Nodes
     make all ~SLLists~ to use the *same methods* -> create a special ~IntNode~ node: *sentinel node*  
     #+begin_src java :classname 
       public void addLast(int x) {
           size += 1;
           IntNode p = sentinel;
           while (p.next != null) {
               p = p.next;
           }

           p.next = new IntNode(x, null);
       }
     #+end_src 
     - Empty list created by ~SLList L = new SLList()~
       #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-06 00:18:33
       [[file:2._Lists/screenshot_2019-06-06_00-18-33.png]]
     - a ~SLList~ with 5, 10, 15
       #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-06 00:19:26
       [[file:2._Lists/screenshot_2019-06-06_00-19-26.png]]
     - ~sentinel = new IntNode(random, Null)~
***** Question:                                                   :QUESTIONS:
      1.在哪里定义 ~sentinel~ ？ ~sentinel~ 与 ~first~ 和 ~addFirst~ 怎么串联起来？   
**** Invariants
     An *invariant* is a *fact* about a *data structure* that is guaranteed to be *true* (assuming there are no bugs in your code)
     A ~SLList~ with a *sentinel node* has at least the following invariants:
     - The ~sentinel~ reference always points to a *sentinel node*.
     - The *front item* (if it exists), is always at ~sentinel.next.item~.
     - The ~size~ variable is always the total number of items that have been added.

** 2.3 The DLList
*** DLList
**** addLast
     Previous ~addLast~ is *slow* for long lists -> adding a ~last~ variable 
     #+begin_src java :classname 
       public class SLList {
           private IntNode sentinel;
           private IntNode last;
           private int size;    

           public void addLast(int x) {
               last.next = new IntNode(x, null);
               last = last.next;
               size += 1;
           }
           ...
       }
     #+end_src 
***** Exercise 2.3.1
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-09 22:14:35
      [[file:2._Lists/screenshot_2019-06-09_22-14-35.png]]
      ~addLast~ and ~getLast~ *rapid*, ~removeLast~ slow   
**** SecondToLast
     Adding a ~secondToLast~ 
**** Improvement #7: Looking Back
     Adding a previous pointer to each ~IntNode~ 
     #+begin_src java :classname 
       public class IntNode {
           public IntNode prev;
           public int item;
           public IntNode next;
       }
     #+end_src 
      
     #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-09 22:51:21
     [[file:2._Lists/screenshot_2019-06-09_22-51-21.png]]
**** Improvement #8: Sentinel Upgrade
     ~last~ sometimes points at the ~sentinel~ node, and sometimes at a real node ->
     - Adding a *second sentinel* node to the back of the list
       #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-09 23:08:50
       [[file:2._Lists/screenshot_2019-06-09_23-08-50.png]]
     - Implementing the list so that it is *circular*, with the *front and back* pointers sharing the *same sentinel* node
       #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-09 23:09:34
       [[file:2._Lists/screenshot_2019-06-09_23-09-34.png]]
**** Generic DLLists
     :PROPERTIES:
     :ID:       bb911b87-f2ab-4583-bd38-debebff91afb
     :END:
     Creating data structures that hold any ~reference~ type 
     - Adding ~<>~ to define generic ~DLList~ 
       #+begin_src java :classname 
         public class DLList<BleepBlorp> {
             private IntNode sentinel;
             private int size;

             public class IntNode {
                 public IntNode prev;
                 public BleepBlorp item;
                 public IntNode next;
                 ...
             }
             ...
         }
       #+end_src
     - Instantiate generic ~DLList~ 
       #+begin_src java :classname 
         DLList<String> d2 = new DLList<>("hello");
         d2.addLast("world");
       #+end_src 
     - Generics only work with ~reference~ types -> using the ~reference~ version of the ~primitive~ type
       #+begin_src java :classname 
         DLList<Integer> d1 = new DLList<>(5);
         d1.insertFront(10);
       #+end_src 

** 2.4 Arrays
*** Array Basics
**** Array Creation
     Three valid notations for array creation
     #+begin_src java :classname 
       x = new int[3];
       y = new int[]{1, 2, 3, 4, 5};
       int[] z = {9, 10, 11, 12, 13};
     #+end_src 
**** Array Access and Modification
     #+begin_src java :classname 
       public class ClassNameHere {
           public static void main(String[] args) {
               int[] z = null;
               int[] x, y;

               x = new int[]{1, 2, 3, 4, 5};
               y = x;
               x = new int[]{-1, 2, 5, 4, 99};
               y = new int[3];
               z = new int[0];
               int xL = x.length;

               String[] s = new String[6];
               s[4] = "ketchup";
               s[x[3] - x[1]] = "muffins";

               int[] b = {9, 10, 11};
               System.arraycopy(b, 0, x, 3, 2);
           }
       }
     #+end_src 
     #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-11 21:03:11
     [[file:2._Lists/screenshot_2019-06-11_21-03-11.png]]
     - ~System.arraycopy(b, 0, x, 3, 2)~ = ~x[3:5] = b[0:2]~ in python
       - ~b~: The array to use as a source
       - ~0~: Where to start in the source array
       - ~x~: The array to use as a destination
       - ~3~: Where to start in the destination array
       - ~2~: How many items to copy 
**** 2D Arrays in Java
     2D array in Java is actually just an *array of arrays*
     #+begin_src java :classname 
       public class ArrayBasics2 {
           public static void main(String[] args) {
               int[][] pascalsTriangle;
               pascalsTriangle = new int[4][];
               int[] rowZero = pascalsTriangle[0];
		
               pascalsTriangle[0] = new int[]{1};
               pascalsTriangle[1] = new int[]{1, 1};
               pascalsTriangle[2] = new int[]{1, 2, 1};
               pascalsTriangle[3] = new int[]{1, 3, 3, 1};
               int[] rowTwo = pascalsTriangle[2];
               rowTwo[1] = -5;

               int[][] matrix;
               matrix = new int[4][];
               matrix = new int[4][4]; 

               int[][] pascalAgain = new int[][]{{1}, {1, 1}, 
                                                 {1, 2, 1}, {1, 3, 3, 1}};
           }
       } 
     #+end_src 
     #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-11 21:26:52
     [[file:2._Lists/screenshot_2019-06-11_21-26-52.png]]
***** Exercise 2.4.1
      #+begin_src java :classname 
        public class ArrayDanger {

            public static void main(String[] args) {
                int[][] x = {{1, 2, 3}, {4, 5, 6}, {7, 8, 9}};

                int[][] z = new int[3][];
                z[0] = x[0];
                z[1] = x[1];
                z[2] = x[2];
                z[0][0] = -z[0][0];

                int[][] w = new int[3][3];
                System.arraycopy(x[0], 0, w[0], 0, 3);
                System.arraycopy(x[1], 0, w[1], 0, 3);
                System.arraycopy(x[2], 0, w[2], 0, 3);
                w[0][0] = -w[0][0];
                System.out.println("x[0][0]: " + x[0][0] + ", w[0][0]: " + w[0][0]);
            }
        } 
      #+end_src 
      #+DOWNLOADED: /tmp/screenshot.png @ 2019-06-11 21:31:26
      [[file:2._Lists/screenshot_2019-06-11_21-31-26.png]]
      - ~z[i] = x[i]~ will make ~z[i]~ and ~x[i]~ point to the same array (the *same memory box*), so any operations on the one will have the *same effect* on the other
      - ~System.arraycopy~ will *create new memory box* and just copy the *value* from *src array to des array*. 
**** Arrays vs. Classes
     Both ~arrays~ and ~classes~ can be used to organize a *bunch of memory boxes*. In both cases, the number of memory boxes is *fixed*
     - Key differences between memory boxes in ~arrays~ and ~classes~
       - ~Array~ boxes are *numbered* and accessed using ~[]~ notation, and ~class~ boxes are *named* and accessed using dot notation ~.~
       - ~Array~ boxes must all be the *same* type. ~Class~ boxes can be *different* types
     - One particularly notable *impact of these difference* is that ~[]~ notation allows us to specify which index we'd like *at runtime*
       #+begin_src java :classname 
         int indexOfInterest = askUserForInteger();
         int[] x = {100, 101, 102, 103};
         int k = x[indexOfInterest];
         System.out.println(k);

         $ javac arrayDemo
         $ java arrayDemo
         What index do you want? 2
         102
       #+end_src
       - By contrast, *specifying fields* in a class is not something we do at runtime
         #+begin_src java :classname 
           String fieldOfInterest = "mass";
           Planet p = new Planet(6e24, "earth");
           double mass = p[fieldOfInterest];

           $ javac classDemo
           FieldDemo.java:5: error: array required, but Planet found
                   double mass = earth[fieldOfInterest];        
                                          ^
  
           String fieldOfInterest = "mass";
           Planet p = new Planet(6e24, "earth");
           double mass = p.fieldOfInterest;

           $ javac classDemo
           FieldDemo.java:5: error: cannot find symbol
                   double mass = earth.fieldOfInterest;        
                                      ^
             symbol:   variable fieldOfInterest
              location: variable earth of type Planet
         #+end_src
         - ~reflection~: A way to specify desired fields in a class at runtime, which is considered very *bad* coding style for *typical* programs
***** Question:                                                   :QUESTIONS:
      1. 那两个运行时定义类成员的例子是什么意思？
      2. 运行时定义 ~array~ 值也是不好的风格？ 
**** Appendix: Java Arrays vs. Other Languages
     - Have no special syntax for *"slicing"* (such as in Python).
     - Cannot be *shrunk or expanded* (such as in Ruby).
     - Do not have *member methods* (such as in Javascript).
     - Must contain values only of the *same type* (unlike Python).
* 3. Testing
** 3.1 A New Way
* 4. Inheritance, Implements









* 1. Intro, Hello World Java
* 2. Defining and Using Classes

