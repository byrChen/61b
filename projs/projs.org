* Proj 0 NBody
** Writing the Body Class
*** calcDistance
    #+begin_src java :classname 
      public double calcDistance(Body b ) {
          double d = Math.sqrt(Math.pow(xxPos - b.xxPos, 2) + Math.pow(yyPos - b.yyPos, 2));
          return d;
      }
    #+end_src 
    - ~Math.sqrt(a)~ and ~Math.pow(b, n)~ 
*** calcNetForceExertedByX and calcNetForceExertedByY
    #+begin_src java :classname 
      public double calcNetForceExertedByX(Body[] b) {
          double NetForceByX = 0.0;
          for (Body body : b) {
              if (!this.equals(body)) {
                  NetForceByX += this.calcForceExertedByX(body);
              }
          }
          return NetForceByX;
      }
    #+end_src 
    - ~calcForceExertedByX(Body[] b)~
    - ~for (Body body : b) {}~
    - ~if (!this.equals(body))~ 
** (Optional) Testing Your Body Class
  #+begin_src java :classname 
    public class TestBody {

        public static void main(String[] args) {
            checkBody();
        }

        private static void checkEquals(double expected, double actual, String label, double eps){
            if (Double.isNaN(actual) || Double.isInfinite(actual)) {
                System.out.println("FAIL: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            } else if (expected == actual) {
                System.out.println("PASS: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            } else {
                System.out.println("FAIL: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            }
        }

        private static void checkBody(){
            Body b1 = new Body(1.0, 1.0, 3.0, 4.0, 5.0, "jupiter.gif");
            Body b2 = new Body(2.0, 1.0, 3.0, 4.0, 4e11, "jupiter.gif");
            checkEquals(133.4, b1.calcForceExertedBy(b2), "Pairwise Force", 0.01);
        }
    }
  #+end_src 
  - ~private static void~
  - ~Double.isNaN~ and ~Double.isInfinite~ first to guarantee ~==~ working
  - ~": Expected " + expected~ returns ~String~, ~int~ can be converted to ~String~
  - ~eps~ for ~==~ 
** Getting Started with the Simulator (NBody.java)
*** readBodies
    #+begin_src java :classname 
      public static Body[] readBodies(String filePath) {
          In in = new In(filePath);
          int firstItemInFile = in.readInt();
          double radius = in.readDouble();
          int N = 25;
          Body[] b = new Body[N];
          for (int i = 0; i < N; i++) {
              double xxPos = in.readDouble();
              double yyPos = in.readDouble();
              double xxVel = in.readDouble();
              double yyVel = in.readDouble();
              double mass = in.readDouble();
              String imgFileName = "./images/" + in.readString();
              b[i] = new Body(xxPos, yyPos, xxVel, yyVel, mass, imgFileName);
          }
          return b;
      }
    #+end_src 
    - ~public static Body[] readBodies~
    - ~Body[] b = new Body[5]~
    - ~b[i] = new Body(xxPos, yyPos, xxVel, yyVel, mass, imgFileName)~ 
** Drawing the Initial Universe State (main)
   #+begin_src java :classname 
     public static void main(String[] args) {
         double T = Double.parseDouble(args[0]);
         double dt = Double.parseDouble(args[1]);
         String filename = args[2];
         double radius = readRadius(filename);
         Body[] bodies = readBodies(filename);
         String backgroud = "./images/starfield.jpg";
         StdDraw.setScale(-radius, radius);
         StdDraw.enableDoubleBuffering();
         int N = 25;
         Double[] xForces = new Double[N];
         Double[] yForces = new Double[N];
         for (double i = 0; i < T; i = i + dt) {
             StdDraw.clear();
             for (int j = 0; j < N; j++) {
                 xForces[j] = bodies[j].calcNetForceExertedByX(bodies);
                 yForces[j] = bodies[j].calcNetForceExertedByY(bodies);
             }
             for (int j = 0; j < N; j++) {
                 bodies[j].update(dt, xForces[j], yForces[j]);
             }
             StdDraw.picture(0, 0, backgroud);
             for (Body b : bodies) {
                 b.draw();
             }
             StdDraw.show();
             StdDraw.pause(20);
         }
     }

     StdOut.printf("%d\n", bodies.length);
     StdOut.printf("%.2e\n", radius);
     for (int i = 0; i < bodies.length; i++) {
         StdOut.printf("%11.4e %11.4e %11.4e %11.4e %11.4e %12s\n",
                       bodies[i].xxPos, bodies[i].yyPos, bodies[i].xxVel,
                       bodies[i].yyVel, bodies[i].mass, bodies[i].imgFileName);
     }
   #+end_src 
   - ~Double.parseDouble(String)~ 
   - ~Class[] var = new Class[N]~
   - ~StdDraw~ and ~StdOut~
   - ~StdOut.printf()~
*** Question:                                                     :QUESTIONS:
    1. ~StdOut~ 和 ~System.out~ 异同？对比c++里的 ~cout~ 和 ~stdout~ 
   
** Extra for Experts                                                  :EXTRA:
*** Adding Audio                                                :OUTSTANDING:
*** Gold Points                                                 :OUTSTANDING:
** Gradescope
   #+begin_src java :classname 
     public class Body {
         ...
         private static final double G = 6.67e-11;
         ...
     }
   #+end_src 
   - ~public class Body~
   - ~private static final~ 
* Proj 1A Data Structures
** LinkedListDeque 
   #+begin_src java :classname 
     import java.io.NotActiveException;

     public class LinkedListDeque<T> {

         private Node<T> sentinel;
         private int size;

         public class Node<T> {
             public Node<T> prev;
             public Node<T> next;
             public T item;

             public Node(T ITEM, Node PREV, Node NEXT) {
                 item = ITEM;
                 prev = PREV;
                 next = NEXT;
             }
         }

         public LinkedListDeque() {
             sentinel = new Node(0, null, null);
             size = 0;
         }

         public  LinkedListDeque(LinkedListDeque other) {
             Node<T> p = other.sentinel;
             LinkedListDeque<T> copyLLD = new LinkedListDeque<>();
             while (p.next != null) {
                 copyLLD.addLast(p.next.item);
                 p = p.next;
             }
             sentinel = copyLLD.sentinel;
         }

         public T getRecursive(int index) {
             LinkedListDeque<T> copyLLD = new LinkedListDeque<>(this);
             Node<T> p = copyLLD.sentinel;
             if (p == null) {
                 return null;
             }
             if (index == 0) {
                 return p.next.item;
             }
             copyLLD.removeFirst();
             return copyLLD.getRecursive(index - 1);
         }

         public void addFirst(T item) {
             Node<T> node = new Node<>(item, null, null);
             if (isEmpty()) {
                 size = size + 1;
                 sentinel.next = node;
                 node.prev = sentinel;
                 sentinel.prev = node;
                 node.next = sentinel;
                 return;
             }
             size = size + 1;
             node.next = sentinel.next;
             sentinel.next.prev = node;
             node.prev = sentinel;
             sentinel.next = node;
         }

         public void addLast(T item) {
             Node<T> node = new Node<>(item, null, null);
             if (isEmpty()) {
                 sentinel.next = node;
                 node.prev = sentinel;
                 sentinel.prev = node;
                 node.next = sentinel;
                 size = size + 1;
                 return;
             }
             node.prev = sentinel.prev;
             sentinel.prev.next = node;
             node.next = sentinel;
             sentinel.prev = node;
             size = size + 1;
         }

         public boolean isEmpty() {
             return size == 0;
         }

         public int size() {
             return size;
         }

         public void printDeque() {
             Node p = sentinel;
             for (int i = 0; i < size; i++) {
                 System.out.print(p.next.item + " ");
                 p = p.next;
             }

             System.out.println();
         }

         public T removeFirst() {
             if (isEmpty()) {
                 return null;
             }
             Node<T> first = sentinel.next;
             sentinel.next = first.next;
             first.next.prev = sentinel;
             size = size - 1;
             return first.item;
         }

         public T removeLast() {
             if (isEmpty()) {
                 return null;
             }
             Node<T> last = sentinel.prev;
             sentinel.prev = last.prev;
             last.prev.next = sentinel;
             size = size - 1;
             return last.item;
         }

         public T get(int index) {
             if (isEmpty()) {
                 return null;
             }
             Node<T> p = sentinel;
             for (int i = 0; i < index; i++) {
                 p = p.next;
             }
             return p.item;
         }
     }
   #+end_src 

** ArrayDeque
   #+begin_src java :classname 
     public class ArrayDeque<T> {

         private T[] Items;
         private int size;
         private int nextFirst;
         private int nextLast;
         private double ratio;


         public ArrayDeque() {
             size = 0;
             Items = (T[]) new Object[8];
             nextFirst = 0;
             nextLast = 1;
             ratio = 0.25;
         }

         public ArrayDeque(ArrayDeque other) {
             Items = (T[]) new Object[other.Items.length];
             System.arraycopy(other.Items, 0, Items, 0, other.Items.length);
             size = other.size;
             nextFirst = other.nextFirst;
             nextLast = other.nextLast;
             ratio = 0.25;
         }


         public void addFirst(T item) {
             if (isFull()) {
                 this.resize(size * 2);
             }
             Items[nextFirst] = item;
             nextFirst = minusOne(nextFirst);
             size += 1;
         }

         public void addLast(T item) {
             if (isFull()) {
                 this.resize(size * 2);
             }
             Items[nextLast] = item;
             nextLast = plusOne(nextLast);
             size += 1;
         }

         public int size() {
             return size;
         }

         public void printDeque() {
             for (int index = plusOne(nextFirst); index != minusOne(nextLast); index = plusOne(index)) {
                 System.out.print(Items[index] + " ");
             }
             System.out.println();
         }

         public T removeFirst() {
             if (isEmpty()) {
                 return null;
             }
             int index = plusOne(nextFirst);
             T x = Items[index];
             Items[index] = null;
             nextFirst = plusOne(nextFirst);
             size -= 1;
             if (isWaste()) {
                 resize(Items.length / 2);
             }
             return x;
         }

         public T removeLast() {
             if (isEmpty()) {
                 return null;
             }
             int index = minusOne(nextFirst);
             T x = Items[index];
             Items[index] = null;
             nextLast = minusOne(nextLast);
             size -= 1;
             if (isWaste()) {
                 resize(Items.length / 2);
             }
             return x;
         }

         public T get(int index) {
             return Items[index];
         }

         public void resize(int capacity) {
             T[] newItems = (T []) new Object[capacity];
             if (nextFirst >= nextLast) {
                 int firstEnd = minusOne(nextLast);
                 int secondStart = plusOne(nextFirst);
                 System.arraycopy(Items, 0, newItems, 0, firstEnd + 1);
                 System.arraycopy(Items, secondStart, newItems, firstEnd + 1, Items.length - secondStart);
             } else {
                 System.arraycopy(Items, 0, newItems, 0, size);
             }
             nextFirst = capacity - 1;
             nextLast = size;
             Items = newItems;
         }

         public int minusOne(int Index) {
             return (Index + Items.length - 1) % Items.length;
         }

         public int plusOne(int Index) {
             return (Index + 1) % Items.length;
         }

         public boolean isEmpty() {
             return size == 0;
         }

         public boolean isFull() {
             return size == Items.length;
         }

         public boolean isWaste() {
             return Items.length >= 16 && size / Items.length < ratio;
         }

     }
   #+end_src 

