#+TAGS: UNRESOLVED(u) QUESTIONS(q) EXTRA(e) REQUIRED(r) TOBEORG(t)

* Proj 0 NBody
** Writing the Body Class
*** calcDistance
    #+begin_src java :classname 
      public double calcDistance(Body b ) {
          double d = Math.sqrt(Math.pow(xxPos - b.xxPos, 2) + Math.pow(yyPos - b.yyPos, 2));
          return d;
      }
    #+end_src 
    - ~Math.sqrt(a)~ and ~Math.pow(b, n)~ 
*** calcNetForceExertedByX and calcNetForceExertedByY
    #+begin_src java :classname 
      public double calcNetForceExertedByX(Body[] b) {
          double NetForceByX = 0.0;
          for (Body body : b) {
              if (!this.equals(body)) {
                  NetForceByX += this.calcForceExertedByX(body);
              }
          }
          return NetForceByX;
      }
    #+end_src 
    - ~calcForceExertedByX(Body[] b)~
    - ~for (Body body : b) {}~
    - ~if (!this.equals(body))~ 
** (Optional) Testing Your Body Class
  #+begin_src java :classname 
    public class TestBody {

        public static void main(String[] args) {
            checkBody();
        }

        private static void checkEquals(double expected, double actual, String label, double eps){
            if (Double.isNaN(actual) || Double.isInfinite(actual)) {
                System.out.println("FAIL: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            } else if (expected == actual) {
                System.out.println("PASS: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            } else {
                System.out.println("FAIL: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            }
        }

        private static void checkBody(){
            Body b1 = new Body(1.0, 1.0, 3.0, 4.0, 5.0, "jupiter.gif");
            Body b2 = new Body(2.0, 1.0, 3.0, 4.0, 4e11, "jupiter.gif");
            checkEquals(133.4, b1.calcForceExertedBy(b2), "Pairwise Force", 0.01);
        }
    }
  #+end_src 
  - ~private static void~
  - ~Double.isNaN~ and ~Double.isInfinite~ first to guarantee ~==~ working
  - ~": Expected " + expected~ returns ~String~, ~int~ can be converted to ~String~
  - ~eps~ for ~==~ 
** Getting Started with the Simulator (NBody.java)
*** readBodies
    #+begin_src java :classname 
      public static Body[] readBodies(String filePath) {
          In in = new In(filePath);
          int N = in.readInt();
          double radius = in.readDouble();
          Body[] b = new Body[N];
          for (int i = 0; i < N; i++) {
              double xxPos = in.readDouble();
              double yyPos = in.readDouble();
              double xxVel = in.readDouble();
              double yyVel = in.readDouble();
              double mass = in.readDouble();
              String imgFileName = "./images/" + in.readString();
              b[i] = new Body(xxPos, yyPos, xxVel, yyVel, mass, imgFileName);
          }
          return b;
      }
    #+end_src 
    - ~public static Body[] readBodies~
    - ~Body[] b = new Body[5]~
    - ~b[i] = new Body(xxPos, yyPos, xxVel, yyVel, mass, imgFileName)~ 
** Drawing the Initial Universe State (main)
   #+begin_src java :classname 
     public static void main(String[] args) {
         double T = Double.parseDouble(args[0]);
         double dt = Double.parseDouble(args[1]);
         String filename = args[2];
         double radius = readRadius(filename);
         Body[] bodies = readBodies(filename);
         String backgroud = "./images/starfield.jpg";
         StdDraw.setScale(-radius, radius);
         StdDraw.enableDoubleBuffering();
         int N = 25;
         Double[] xForces = new Double[N];
         Double[] yForces = new Double[N];
         for (double i = 0; i < T; i = i + dt) {
             StdDraw.clear();
             for (int j = 0; j < N; j++) {
                 xForces[j] = bodies[j].calcNetForceExertedByX(bodies);
                 yForces[j] = bodies[j].calcNetForceExertedByY(bodies);
             }
             for (int j = 0; j < N; j++) {
                 bodies[j].update(dt, xForces[j], yForces[j]);
             }
             StdDraw.picture(0, 0, backgroud);
             for (Body b : bodies) {
                 b.draw();
             }
             StdDraw.show();
             StdDraw.pause(20);
         }
     }

     StdOut.printf("%d\n", bodies.length);
     StdOut.printf("%.2e\n", radius);
     for (int i = 0; i < bodies.length; i++) {
         StdOut.printf("%11.4e %11.4e %11.4e %11.4e %11.4e %12s\n",
                       bodies[i].xxPos, bodies[i].yyPos, bodies[i].xxVel,
                       bodies[i].yyVel, bodies[i].mass, bodies[i].imgFileName);
     }
   #+end_src 
   - ~Double.parseDouble(String)~ 
   - ~Class[] var = new Class[N]~
   - ~StdDraw~ and ~StdOut~
   - ~StdOut.printf()~
*** Question:                                                     :QUESTIONS:
    1. ~StdOut~ 和 ~System.out~ 异同？对比c++里的 ~cout~ 和 ~stdout~ 
   
** Extra for Experts                                                  :EXTRA:
*** Adding Audio                                                :UNRESOLVED:
*** Gold Points                                                 :UNRESOLVED:
* Proj 1A Data Structures                                           :TOBEORG:
** LinkedListDeque 
   #+begin_src java :classname 
     import java.io.NotActiveException;

     public class LinkedListDeque<T> {

         private Node<T> sentinel;
         private int size;

         private class Node<T> {
             private Node<T> prev;
             private Node<T> next;
             private T item;

             public Node(T iteM, Node preV, Node nexT) {
                 item = iteM;
                 prev = preV;
                 next = nexT;
             }
         }

         public LinkedListDeque() {
             sentinel = new Node(0, null, null);
             size = 0;
         }

         public  LinkedListDeque(LinkedListDeque other) {
             sentinel = new Node(0, null, null);
             size = 0;
             Node<T> p = other.sentinel.next;
     //        LinkedListDeque<T> popyLLD = new LinkedListDeque<>();
             for (int i = 0; i < other.size; i++) {
                 this.addLast(p.item);
                 p = p.next;
             }
         }

         public T getRecursive(int index) {
             LinkedListDeque<T> copyLLD = new LinkedListDeque<>(this);
             Node<T> p = copyLLD.sentinel;
             if (p == null || index >= size) {
                 return null;
             }
             if (index == 0) {
                 return p.next.item;
             }
             copyLLD.removeFirst();
             return copyLLD.getRecursive(index - 1);
         }

         public void addFirst(T item) {
             Node<T> node = new Node<>(item, null, null);
             if (isEmpty()) {
                 size = size + 1;
                 sentinel.next = node;
                 node.prev = sentinel;
                 sentinel.prev = node;
                 node.next = sentinel;
                 return;
             }
             size = size + 1;
             node.next = sentinel.next;
             sentinel.next.prev = node;
             node.prev = sentinel;
             sentinel.next = node;
         }

         public void addLast(T item) {
             Node<T> node = new Node<>(item, null, null);
             if (isEmpty()) {
                 sentinel.next = node;
                 node.prev = sentinel;
                 sentinel.prev = node;
                 node.next = sentinel;
                 size = size + 1;
                 return;
             }
             node.prev = sentinel.prev;
             sentinel.prev.next = node;
             node.next = sentinel;
             sentinel.prev = node;
             size = size + 1;
         }

         public boolean isEmpty() {
             return size == 0;
         }

         public int size() {
             return size;
         }

         public void printDeque() {
             Node p = sentinel;
             for (int i = 0; i < size; i++) {
                 System.out.print(p.next.item + " ");
                 p = p.next;
             }

             System.out.println();
         }

         public T removeFirst() {
             if (isEmpty()) {
                 return null;
             }
             Node<T> first = sentinel.next;
             sentinel.next = first.next;
             first.next.prev = sentinel;
             size = size - 1;
             return first.item;
         }

         public T removeLast() {
             if (isEmpty()) {
                 return null;
             }
             Node<T> last = sentinel.prev;
             sentinel.prev = last.prev;
             last.prev.next = sentinel;
             size = size - 1;
             return last.item;
         }

         public T get(int index) {
             if (isEmpty() || index < 0) {
                 return null;
             }
             Node<T> p = sentinel;
             for (int i = 0; i < index + 1; i++) {
                 p = p.next;
             }
             return p.item;
         }
     }
   #+end_src 
** LLDTest
   #+begin_src java :classname 
     import org.junit.Test;
     import static org.junit.Assert.*;

     public class LLDTest {

         @Test
         public void getTest() {
             LinkedListDeque<Integer> llD = new LinkedListDeque<>();
             llD.addFirst(0);
             llD.addLast(1);
             assertEquals(1, (long) llD.removeLast());
             assertEquals(0, (long) llD.removeLast());
             llD.addLast(5);
             assertEquals(5, (long) llD.get(0));
         }

         @Test
         public void getRecursiveTest() {
             LinkedListDeque<Integer> llD = new LinkedListDeque<>();
             assertNull(llD.getRecursive(0));
             assertNull(llD.getRecursive(1));
             llD.addLast(0);
             assertEquals(0, (long) llD.getRecursive(0));
             llD.removeLast();
             assertNull(llD.getRecursive(0));
             llD.addFirst(1);
             assertEquals(1, (long) llD.getRecursive(0));
             llD.removeFirst();
             assertNull(llD.getRecursive(0));
         }
     }
   #+end_src 
** ArrayDeque
   #+begin_src java :classname 
     import java.util.TreeMap;

     public class ArrayDeque<T> {

         private T[] items;
         private int size;
         private int nextFirst;
         private int nextLast;
         private double ratio;

         public ArrayDeque() {
             size = 0;
             items = (T[]) new Object[8]; 
             nextFirst = 7;
             nextLast = 0;
             ratio = 0.25;
         }

         public ArrayDeque(ArrayDeque other) {
             items = (T[]) new Object[other.items.length];
             System.arraycopy(other.items, 0, items, 0, other.items.length);
             size = other.size;
             nextFirst = other.nextFirst;
             nextLast = other.nextLast;
             ratio = 0.25;
         }

         public void addFirst(T item) {
             items[nextFirst] = item;
             nextFirst = minusOne(nextFirst);
             size += 1;

             if (isFull()) {
                 this.resize(size * 2);
             }
         }

         public void addLast(T item) {
             items[nextLast] = item;
             nextLast = plusOne(nextLast);
             size += 1;

             if (isFull()) {
                 this.resize(size * 2);
             }
         }

         public int size() {
             return size;
         }

         public void printDeque() {
             for (int i = 0; i < size; i++) {
                 System.out.print(get(i) + " ");
             }
             System.out.println();
         }

         public T removeFirst() {
             if (isEmpty()) {
                 return null;
             }
             int index = plusOne(nextFirst);
             T x = items[index];
             items[index] = null;
             nextFirst = index;
             size -= 1;
             if (isWaste()) {
                 resize(items.length / 2);
             }
             return x;
         }

         public T removeLast() {
             if (isEmpty()) {
                 return null;
             }
             int index = minusOne(nextLast);
             T x = items[index];
             items[index] = null;
             nextLast = index;
             size -= 1;
             if (isWaste()) {
                 resize(items.length / 2);
             }
             return x;
         }

         public T get(int index) {
             if (index < 0 || index >= size) {
                 return  null;
             }
             return items[plusOne(index + nextFirst)];
         }

         private void resize(int capacity) {

             T[] newItems = (T []) new Object[capacity];
             int firstSize = items.length - nextFirst - 1;
             int start = plusOne(nextFirst);
             int secondSize = nextLast;

             if (isFull()) {
                 if (nextFirst == nextLast - 1) {
                     System.arraycopy(items, start, newItems, 0, firstSize);
                     System.arraycopy(items, 0, newItems, firstSize, secondSize);
                 } else {
                     System.arraycopy(items, start, newItems, 0, size);
                 }
             }

             if (isWaste()) {
                 if (nextLast > nextFirst) {
                     System.arraycopy(items, start, newItems, 0, size);
                 } else {
                     System.arraycopy(items, start, newItems, 0, firstSize);
                     System.arraycopy(items, 0, newItems, firstSize, secondSize);
                 }
             }

             nextFirst = capacity - 1;
             nextLast = size;
             items = newItems;
         }

         public Object[] items() {
             return items;
         }

         public int nextFirst() {
             return nextFirst;
         }

         public int nextLast() {
             return nextLast;
         }

         public int itemsLength() {
             return items.length;
         }

         private int minusOne(int index) {
             return (index + items.length - 1) % items.length;
         }

         private int plusOne(int index) {
             return (index + 1) % items.length;
         }

         public boolean isEmpty() {
             return size == 0;
         }

         private boolean isFull() {
             return size == items.length;
         }

         private boolean isWaste() {
             return items.length >= 16 && (float) size / items.length < ratio;
         }
     }
   #+end_src 
** ADTest
   #+begin_src java :classname 
     import org.junit.Test;
     import static org.junit.Assert.*;

     public class ADTest {
         @Test
         public void constructorTest() {
             ArrayDeque<String> aD = new ArrayDeque<>();
             assertEquals(8,  aD.itemsLength());
             assertEquals(7, aD.nextFirst());
             assertEquals(0, aD.nextLast());
             ArrayDeque<String> newaD = new ArrayDeque<>(aD);
             assertEquals(aD.itemsLength(), newaD.itemsLength());
             assertEquals(aD.nextFirst(), newaD.nextFirst());
             assertEquals(aD.nextLast(), newaD.nextLast());
             assertArrayEquals(aD.items(), newaD.items());
             assertNotEquals(aD, newaD);
         }
         @Test
         public void addTest() {
             ArrayDeque<Integer> aD = new ArrayDeque<>();
             assertNull(aD.get(0));
             aD.addFirst(1);
             aD.addFirst(0);
             aD.addLast(2);
             Integer[] expect = {2, null, null, null, null, null, 0, 1};
             assertArrayEquals(expect, aD.items());
             assertEquals(5, aD.nextFirst());
             assertEquals(1, aD.nextLast());
             assertEquals(3, aD.size());
         }
         @Test
         public void removeTest() {
             ArrayDeque<Integer> aD = new ArrayDeque<>();
             assertNull(aD.removeFirst());
             assertNull(aD.removeLast());
             for (int i = 0; i < 7; i++) {
                 aD.addLast(i);
             }
             assertEquals(0, (long) aD.removeFirst());
             assertEquals(6, (long) aD.removeLast());
             Integer[] expect = {null, 1, 2, 3, 4, 5, null, null};
             assertArrayEquals(expect, aD.items());
             assertEquals(0, aD.nextFirst());
             assertEquals(6, aD.nextLast());
             assertEquals(5, aD.size());
         }
         @Test
         public void resizeTestF() {

             /* always addLast to full */
             ArrayDeque<Integer> aD1 = new ArrayDeque<>();
             for (int i = 0; i < 8; i++) {
                 aD1.addLast(i);
             }
             Integer[] expectF = {0, 1, 2, 3, 4, 5, 6, 7, null, null,
                     null, null, null, null, null, null};
             assertArrayEquals(expectF, aD1.items());
             aD1.addLast(8);
             expectF[8] = 8;
             assertArrayEquals(expectF, aD1.items());
             assertEquals(15, aD1.nextFirst());
             assertEquals(9, aD1.nextLast());
             assertEquals(9, aD1.size());

             /* always addFirst to full */
             ArrayDeque<Integer> aD2 = new ArrayDeque<>();
             for (int i = 7; i >= 0; i--) {
                 aD2.addFirst(i);
             }
             aD2.addLast(8);
             assertArrayEquals(aD1.items(), aD2.items());
             assertEquals(aD1.nextFirst(), aD2.nextFirst());
             assertEquals(aD1.nextLast(), aD2.nextLast());
             assertEquals(aD1.size(), aD2.size());

             /* addLast and addFirst (nextFirst = nextLast - 1) to full */
             ArrayDeque<Integer> aD3 = new ArrayDeque<>();
             for (int i = 3; i >= 0; i--) {
                 aD3.addFirst(i);
             }
             for (int i = 4; i < 8; i++) {
                 aD3.addLast(i);
             }
             aD3.addLast(8);
             assertArrayEquals(aD1.items(), aD3.items());
             assertEquals(aD1.nextFirst(), aD3.nextFirst());
             assertEquals(aD1.nextLast(), aD3.nextLast());
             assertEquals(aD1.size(), aD3.size());
         }

         @Test
         public void resizeTestW() {

             Integer[] expectF = {0, 1, 2, 3, 4, 5, 6, 7, 8, null,
                     null, null, null, null, null, null};
             ArrayDeque<Integer> aD3 = new ArrayDeque<>();
             for (int i = 0; i < 9; i++) {
                 aD3.addLast(i);
             }

             /* nextFirst = 15 to waste, copy left */
             Integer[] expectW = {0, 1, 2, null, null, null, null, null};
             ArrayDeque<Integer> aD4 = new ArrayDeque<>(aD3);
             for (int i = 0; i < 6; i++) {
                 aD4.removeLast();
             }
             assertArrayEquals(expectW, aD4.items());
             assertEquals(3, aD4.size());
             assertEquals(3, aD4.nextLast());
             assertEquals(7, aD4.nextFirst());

             /* nextLast = 0 to waste, copy right */
             ArrayDeque<Integer> aD5 = new ArrayDeque<>(aD3);
             for (int i = 0; i < 3; i++) {
                 aD5.addFirst(2 - i);
                 expectF[15 - i] = 2 - i;
             }
             assertArrayEquals(expectF, aD5.items());
             for (int i = 0; i < 9; i++) {
                 aD5.removeLast();
             }
             assertArrayEquals(expectW, aD5.items());
             assertEquals(3, aD5.size());
             assertEquals(3, aD5.nextLast());
             assertEquals(7, aD5.nextFirst());

             /* nextLast != 0 and nextFirst !=0
             and nextFirst > nextLast, copy two sides */
             ArrayDeque<Integer> aD6 = new ArrayDeque<>(aD3);
             for (int i = 0; i < 2; i++) {
                 aD6.addFirst(1 - i);
                 expectF[15 - i] = 1 - i;
             }
             expectF[13] = null;
             assertArrayEquals(expectF, aD6.items());
             for (int i = 0; i < 8; i++) {
                 aD6.removeLast();
             }
             expectW[2] = 0;
             assertArrayEquals(expectW, aD6.items());
             assertEquals(3, aD6.size());
             assertEquals(3, aD6.nextLast());
             assertEquals(7, aD6.nextFirst());

             /* nextLast != 0 and nextFirst !=0
             and nextFirst < nextLast, copy middle */
             ArrayDeque<Integer> aD7 = new ArrayDeque<>(aD3);
             for (int i = 0; i < 6; i++) {
                 aD7.removeFirst();
             }
             expectW[0] = 6;
             expectW[1] = 7;
             expectW[2] = 8;
             assertArrayEquals(expectW, aD7.items());
             assertEquals(3, aD7.size());
             assertEquals(3, aD7.nextLast());
             assertEquals(7, aD7.nextFirst());
         }
     }
   #+end_src 
* Project 1B Applying and Testing Data Structures version 1.0       :TOBEORG:
** Deque Interface 
   #+begin_src java :classname 
     interface Deque<T> {

         void addFirst(T item);

         void addLast(T item);

         default boolean isEmpty() {
             return size() == 0;
         }

         int size();

         void printDeque();

         T removeFirst();

         T removeLast();

         T get(int index);
     }
   #+end_src 
** wordToDeque
   #+begin_src java :classname 
     public class Palindrome {

         public Deque<Character> wordToDeque(String word) {

             Deque<Character> deQue = new LinkedListDeque<>();
             for (int i = word.length() - 1; i >= 0; i--) {
                 deQue.addFirst(word.charAt(i));
             }
             return deQue;
         }

         ...
     }
   #+end_src 
** isPalindrome
   #+begin_src java :classname 
     public boolean isPalindrome(String word) {
         if (word.length() == 1 || word.length() == 0) {
             return true;
         }

         for (int i = 0; i < (word.length() / 2); i++) {
             if (word.charAt(i) != word.charAt(word.length() - i - 1)) {
                 return false;
             }
         }

         return true;

         // use wordToDeque
         //        Deque<Character> d = wordToDeque(word);
         //        String reverse = "";
         //        for (int i = 0; i < word.length(); i++) {
         //            reverse += d.removeLast();
         //        }
         //        return reverse.equals(word);
     }
   #+end_src 
** Generalized Palindrome and OffByOne
*** OffByOne
    #+begin_src java :classname 
      /** This interface defines a method for determining equality of characters. */
      public interface CharacterComparator {
          /** Returns true if characters are equal by the rules of the implementing class. */
          boolean equalChars(char x, char y);
      }
    #+end_src 
    #+begin_src java :classname 
      public class OffByOne implements CharacterComparator {
          @Override
          public boolean equalChars(char x, char y) {
              int diff = (x - y < 0) ? (y - x) : (x - y);
              return diff == 1;
          }
      }
    #+end_src 
*** Generalized Palindrome
    #+begin_src java :classname 
      public boolean isPalindrome(String s, CharacterComparator cc) {

          if (s.length() == 0 || s.length() == 1) {
              return true;
          }

          for (int i = 0; i < s.length() / 2; i++) {
              if (!cc.equalChars(s.charAt(i), s.charAt(s.length() - i - 1))) {
                  return false;
              }
          }

          return true;
      }
    #+end_src 
** OffByN
   #+begin_src java :classname 
     public class OffByN implements CharacterComparator {

         private int expect;
         public OffByN(int N) {
             expect = N;
         }
         @Override
         public boolean equalChars(char x, char y) {
             int diff = (x - y) < 0 ? (y - x) : (x - y);
             return diff == expect;
         }
     }
   #+end_src 
** Tests
*** isPalindrome Testing
    #+begin_src java :classname 
      import org.junit.Test;
      import static org.junit.Assert.*;

      public class TestPalindrome {
          // You must use this palindrome, and not instantiate
          // new Palindromes, or the autograder might be upset.
          static Palindrome palindrome = new Palindrome();

          @Test
          public void testWordToDeque() {
              Deque d = palindrome.wordToDeque("persiflage");
              String actual = "";
              for (int i = 0; i < "persiflage".length(); i++) {
                  actual += d.removeFirst();
              }
              assertEquals("persiflage", actual);
          }
          @Test
          public void testisPalindrome() {
              assertTrue(palindrome.isPalindrome("a"));
              assertTrue(palindrome.isPalindrome(""));
              assertTrue(palindrome.isPalindrome("aka"));
              assertFalse(palindrome.isPalindrome("akd"));
          }
      }
    #+end_src 
* Project 1 Gold
  #+begin_src java :classname 
    import static org.junit.Assert.*;
    import org.junit.Test;

    public class TestArrayDequeGold {

        private StudentArrayDeque<Integer> stu = new StudentArrayDeque<>();
        private ArrayDequeSolution<Integer> sol = new ArrayDequeSolution<>();
        private String msg = "\n";
        private int size = 0;

        @Test
        public void testDeque() {
            // test addFirst
            for (int i = 0; i < 100; i++) {
                int flag = StdRandom.uniform(4);
                int random = StdRandom.uniform(10);
                switch (flag) {
                    case 0:
                        size += 1;
                        sol.addFirst(random);
                        stu.addFirst(random);
                        msg = msg + "addFirst(" + random +")\n";
    //                    assertEquals(msg, sol.get(0), stu.get(0));
                        break;
                    case 1:
                        size += 1;
                        sol.addLast(random);
                        stu.addLast(random);
                        msg = msg + "addLast(" + random +")\n";
    //                    assertEquals(msg, (Integer) random, stu.get(size - 1));
    //                    assertEquals(msg, (Integer) random, sol.get(size - 1));
    //                    assertEquals(msg, sol.get(size - 1), stu.get(size - 1));
                        break;
                    case 2:
                        if (size == 0) {
                            break;
                        }
                        size -= 1;
                        msg = msg + "removeFirst()\n";
                        assertEquals(msg, sol.removeFirst(), stu.removeFirst());
                        break;
                    case 3:
                        if (size == 0) {
                            break;
                        }
                        size -= 1;
                        msg = msg + "removeLast()\n";
                        assertEquals(msg, sol.removeLast(), stu.removeLast());
                        break;
                }
            }
        }
    }
  #+end_src 
  - Only use ~addFirst~, ~addLast~, ~removeFirst~ and ~removeLast~, as actually there is a bug in ~addLast~ or ~get~
  - ~private String msg~ and ~private int size~ to trace
  - ~StdRandom.uniform(n)~ and ~StdRandom.uniform(a, b)~
  - ~switch~ and ~case~
  - ~assertEquals(String msg, expect, actual)~ 
* Project 2A Extrinsic MinPQ
** ~ArrayHeapMinPQ~ 
*** ~class PNode<T>~ 
    #+begin_src java :classname 
      public class ArrayHeapMinPQ<T> implements ExtrinsicMinPQ<T> {

          private class PNode<T> {
              T item;
              double priority;

              PNode(T item, double priority) {
                  this.item = item;
                  this.priority = priority;
              }
          }

          private ArrayList<PNode<T>> minHeap;
          private int size;
          private HashMap<T, Integer> items;

          public ArrayHeapMinPQ() {
              minHeap = new ArrayList<>();
              minHeap.add(null);
              items = new HashMap<>();
              size = 0;
          }
          ...
      }
    #+end_src 
    - ~ArrayList<PNode<T>> minHeap = new ArrayList<>()~ and ~HashMap<T, Integer> items = new HashMap<>()~
    - ~minHeap.addd(null)~
*** ~add~ 
    #+begin_src java :classname 
      @Override
      public void add(T item, double priority) {
          if (item == null || contains(item)) {
              throw new IllegalArgumentException("Items can't be null or duplicated.");
          }
          minHeap.add(new PNode(item, priority));
          size += 1;
          items.put(item, size);
          swim(size);
      }

      private void swim(int index) { <<elink1>>
          if (index == 1) return;
          if (lessThanParent(index)) {
              swap(index, index / 2);
              swim(index / 2);
          }
      }

      private boolean lessThanParent(int child) {
          if (child == 1) return false;
          return minHeap.get(child).priority < minHeap.get(child/2).priority;
      }

      private void swap(int x, int y) {
          items.replace(minHeap.get(x).item, y);
          items.replace(minHeap.get(y).item, x);
          PNode<T> temp = minHeap.get(x);
          minHeap.set(x, minHeap.get(y));
          minHeap.set(y, temp);
      }
    #+end_src 
    - ~add~: ~minHeap.add(new PNode(item, priority))~, ~items.put(item, size)~ and ~swim(size)~
    - ~swim~: ~swap(index, index / 2)~, recursive ~if (index == 1) return~ + ~swim(index / 2)~
    - ~lessThanParent~: ~if (child == 1) return false~ to avoid ~minHeap.get(child/2).priority~
    - ~swap~:
      - *Update* ~index~ of ~item~ first: ~items.replace(minHeap.get(x).item, y)~ and ~items.replace(minHeap.get(y).item, x)~
      - Then *swap* ~PNode<T>~: ~minHeap.set(x, minHeap.get(y))~ and ~minHeap.set(y, temp)~ 
*** ~getSmallest~ 
    #+begin_src java :classname 
      @Override
      public T getSmallest() {
          if (size == 0) return null;
          return minHeap.get(1).item;
      }
    #+end_src 
    - ~minHeap.get(1).item~ 
*** ~removeSmallest~ 
    #+begin_src java :classname 
      @Override
      public T removeSmallest() {
          if (size == 0) throw new IllegalArgumentException("Queue is empty.");
          T min = minHeap.get(1).item;
          minHeap.set(1, minHeap.get(size));
          items.replace(minHeap.get(1).item, 1);
          sink(1);
          minHeap.remove(size);
          size -= 1;
          items.remove(min);
          return min;
      }

      private void sink(int index) { <<elink2>>
          if (2 * index > size) return;
          int child = smallerChild(index);
          if (lessThanParent(child)) {
              swap(index, child);
              sink(child);
          }
      }

      private int smallerChild(int parent) {
          int left = 2 * parent;
          int right = 2 * parent + 1;
          if (left == size) return left;
          return minHeap.get(left).priority <= minHeap.get(right).priority ? left : right;
      }
    #+end_src 
    - ~removeSmallest~: ~minHeap.set(1, minHeap.get(size))~ --> ~items.replace(minHeap.get(1).item, 1)~ --> ~sink(1)~ --> ~minHeap.remove(size)~ and ~items.remove(min)~
    - ~sink~: ~swap(index, child)~, recursive ~if (2 * index > size) return~ and ~sink(child)~
    - ~smallerChild~: 
      - ~if (left == size) return left~ to avoid ~minHeap.get(right).priority~
      - ~minHeap.get(left).priority <= minHeap.get(right).priority ? left : right~ 
*** ~changePriority~ <<ilink1>>
    #+begin_src java :classname 
      @Override
      public void changePriority(T item, double priority) {
          if (!contains(item)) return;
          int index = items.get(item);
          minHeap.set(index, new PNode<T>(item, priority));
          if (lessThanParent(index)) swim(index);
          else sink(index);
      }
    #+end_src 
    - Update ~priority~ first: ~int index = items.get(item)~ and ~minHeap.set(index, new PNode<T>(item, priority))~
    - Then ~swim(index)~ or ~sink(index)~ 
*** Question:                                                     :QUESTIONS:
    - [ ] 如果不用 ~HashMap<T, Integer> items~ 记录，该怎么实现 ~contains~ 以及记录 ~item~ 和 ~index~ 的对应关系？如果没有 ~item~ 和 ~index~ 的关系又如何实现 [[ilink1][changePriority]] ？
    - [ ] 不用 ~ArrayList~, 直接用 ~PNode<T>[]~ 实现试试？包括 ~resize~ 的实现？
    - [ ] 关于运行时间分析：
      - [ ] 要求： ~getSmallest~, ~contains~, ~size~ and ~changePriority~ run in $O(log(n))$ time, ~add~ and ~removeSmallest~ run in $O(log(n))$ *average* time
      - [ ] 实际：？ [[ilink2][Runtime testing]]
** Tests
*** ~ArrayHeapMinPQTest~  
    #+begin_src java :classname 
      @Test
      public void sanityGenericTest() {
          try {
              ArrayHeapMinPQ<String> a = new ArrayHeapMinPQ<String>();
              ArrayHeapMinPQ<String> b = new ArrayHeapMinPQ<String>();
              ArrayHeapMinPQ<Integer> c = new ArrayHeapMinPQ<Integer>();
              ArrayHeapMinPQ<Boolean> e = new ArrayHeapMinPQ<Boolean>();
          } catch (Exception e) {
              fail();
          }
      }

      @Test
      public void sanityAddTest() {
          ArrayHeapMinPQ<String> a = new ArrayHeapMinPQ<>();
          try {
              a.add(null, 0.8);
              fail("No exception thrown.");
          } catch (Exception e) {
              assertTrue(e.getMessage().contains("Items can't be null or duplicated."));
          }
          assertEquals(0, a.size());
          assertNull(a.getSmallest());
          for (int i = 0; i < 455; i++) {
              a.add("a" + i, 455 - i);
              assertEquals("a" + i, a.getSmallest());
              assertEquals(i + 1, a.size());
          }
          try {
              a.add("a0", 0.8);
              fail("No exception thrown.");
          } catch (Exception e) {
              assertTrue(e.getMessage().contains("Items can't be null or duplicated."));
          }
      }

      @Test
      public void sanatyContainsTest() {
          ArrayHeapMinPQ<String> a = new ArrayHeapMinPQ<>();
          assertFalse(a.contains("a"));
          for (int i = 0; i < 455; i++) {
              a.add("a" + i, i);
              assertTrue(a.contains("a" + i));
          }
      }

      @Test
      public void sanityRemoveSamllestTest() {
          ArrayHeapMinPQ<String> a = new ArrayHeapMinPQ<>();
          try {
              a.removeSmallest();
              fail();
          } catch (Exception e) {
              e.getMessage().contains("Queue is empty.");
          }

          for (int i = 0; i < 455; i++) {
              a.add("a" + i, i);
          }
          for (int i = 0; i < 455; i++) {
              assertEquals("a" + i, a.removeSmallest());
              assertFalse(a.contains("a" + i));
              assertEquals(454 - i, a.size());
          }

          try {
              a.removeSmallest();
              fail();
          } catch (Exception e) {
              e.getMessage().contains("Queue is empty.");
          }
      }

      @Test
      public void sanityChangePriorityTest() {
          ArrayHeapMinPQ<String> a = new ArrayHeapMinPQ<>();
          ArrayHeapMinPQ<String> b = new ArrayHeapMinPQ<>();
          for (int i = 0; i < 455; i++) {
              a.add("a" + i, i);
              b.add("b" + i, i);
          }
          b.changePriority("b0", 455);
          for (int i = 0; i < 455; i++) {
              a.changePriority("a" + (454 - i), -1);
              assertEquals("a" + (454 - i), a.removeSmallest());
              if (i == 454) assertEquals("b0", b.removeSmallest());
              else assertEquals("b" + (i + 1), b.removeSmallest());
          }
      }
    #+end_src 
    - ~try {fail("No exception thrown.")} cache (Exception e) {e.getMessage().contains()}~
    - Use ~for~ to write tests
**** Question:                                                    :QUESTIONS:
     - [ ] 写测试时 ~try{} catch () {}~ 怎么捕捉多个异常并对不同异常分开测试？
*** Randomized testing                                     :UNRESOLVED:EXTRA:
*** Runtime testing <<ilink2>>                             :UNRESOLVED:EXTRA:
* Project 2B K-d Tree
** ~KDTree~ 
*** ~class Node~ 
    #+begin_src java :classname 
      public class KDTree implements PointSet {

          class Node {
              Point p;
              Node left, right;
              boolean compareX = true;

              Node(Point p, Node left, Node right) {
                  this.p = p; this.left = left; this.right = right;
              }
          }

          private Node root;

          Comparator<Node> nodeComparator = (child, parent) -> {
              if (parent.compareX) {
                  child.compareX = false;
                  return Double.compare(child.p.getX(), parent.p.getX());
              } else {
                  child.compareX = true;
                  return Double.compare(child.p.getY(), parent.p.getY());
              }
          };

          public KDTree(List<Point> points) {
              if (points.size() < 1) throw new IllegalArgumentException();
              root = new Node(points.get(0), null, null);
              for (int i = 1; i < points.size(); i++) {
                  put(new Node(points.get(i), null, null));
              }
          }
          ...
      }
    #+end_src 
    - ~boolean compareX~
    - ~Comparator<Node> nodeComparator = (child, parent) -> {};~
    - ~Double.compare~ 
    - ~root = new Node(points.get(0), null, null)~ and ~put(new Node(points.get(i), null, null))~
*** ~put~ 
    #+begin_src java :classname 
      public void put(Node n) {
          if (n == null) throw new IllegalArgumentException("calls put() with a null Node");
          root = put(root, n);
      }

      private Node put(Node parent, Node child) { <<ilink3>>
          if (parent == null) return child;
          int cmp = nodeComparator.compare(child, parent);
          if (cmp < 0) parent.left = put(parent.left, child);
          else         parent.right = put(parent.right, child);
          return parent;
      }
    #+end_src 
    - ~public void put(Node n)~: ~root = put(root, n)~
    - ~private Node put(Node parent, Node child)~:
      - ~int cmp = nodeComparator.compare(child, parent)~
      - Recursive: ~parent.left = put(parent.left, child)~ and ~parent.right = put(parent.right, child)~ 
*** ~nearest~ 
    #+begin_src java :classname 
      @Override
      public Point nearest(double x, double y) {
          Node goal = new Node(new Point(x, y), null, null);
          return nearest(root, goal, root).p;
      }

      private Node nearest(Node n, Node goal, Node best) { <<ilink4>>
          if (n == null) return best;
          int cmp = Double.compare(disBetween(n, goal), disBetween(best, goal));
          if (cmp < 0) best = n;
          cmp = nodeComparator.compare(goal, n);
          Node goodSide, badSide;
          goodSide = cmp < 0 ? n.left : n.right;
          badSide= cmp < 0 ? n.right : n.left;
          best = nearest(goodSide, goal, best);
          if (needBad(n, goal, disBetween(best, goal))) {
              best = nearest(badSide, goal, best);
          }
          return best;
      }

      private boolean needBad (Node n, Node goal, double min) { <<ilink5>>
          Double d;
          if (n.compareX) d = Math.pow(n.p.getX() - goal.p.getX(), 2);
          else d = Math.pow(n.p.getY() - goal.p.getY(), 2);
          int cmp = Double.compare(d, min);
          return cmp < 0 ? true : false;
      }

      private static double disBetween(Node n1, Node goal) {
          return Point.distance(n1.p, goal.p);
      }
    #+end_src 
    - ~public Point nearest(double x, double y)~: ~return nearest(root, goal, root).p~
    - ~private Node nearest(Node n, Node goal, Node best)~
      - ~Double.compare(disBetween(n, goal), disBetween(best, goal))~
      - ~cmp = nodeComparator.compare(goal, n)~ --> ~goodSide = cmp < 0 ? n.left : n.right~ and ~badSide= cmp < 0 ? n.right : n.left~
      - Recursive: ~best = nearest(goodSide, goal, best)~ and ~best = nearest(badSide, goal, best)~
    - ~private boolean needBad (Node n, Node goal, double min)~ 
      - ~d = Math.pow(n.p.getX() - goal.p.getX(), 2)~ and ~d = Math.pow(n.p.getY() - goal.p.getY(), 2)~
      - ~cmp < 0 ? true : false~ 
*** Question:                                                     :QUESTIONS:
    - [ ] 关于 recursive 的思考：有无返回值，需要传入什么样的参数，怎样的返回条件
      - [ ] 无返回， ~ArrayHeapMinPQ~ 的 [[file:61b_projs.org::<<elink1>>][swim]] 和 [[file:61b_projs.org::<<elink2>>][sink]]
      - [ ] 有返回值， ~BSTMap~ 的 [[file:61b_labs.org::<<elink4>>][put]], [[file:61b_labs.org::<<elink5>>][updateBST]], [[file:61b_labs.org::<<elink6>>][get]]; ~KDTree~ 的 [[ilink3][put]], [[ilink4][nearest]] 等
    - [ ] 有关模仿 ~BSTMap~ 的更多操作的实现，特别是 ~remove~ 
    - [ ] 关于 [[ilink5][needBad]] 的准确准则及实现，并用 randomized tests 验证速度
    - [ ] 如果数据的维数更多，又该怎么去实现？
** Tests
*** ~KDTreeTest~ 
    #+begin_src java :classname 
      public class KDTreeTest {

          private LinkedList<Point> l;
          private KDTree t;

          public KDTreeTest() {
              l = new LinkedList<>();
              l.add(new Point(2, 3));
              l.add(new Point(4, 2));
              l.add(new Point(4, 5));
              l.add(new Point(3, 3));
              l.add(new Point(1, 5));
              l.add(new Point(4, 4));
              t = new KDTree(l);
          }

          @Test
          public void sanityPutTest() {
              KDTree.Node n = t.getRoot();
              assertEquals(n.p, new Point(2, 3));
              assertEquals(n.right.p, new Point(4, 2));
              assertEquals(n.left.p, new Point(1, 5));
              assertEquals(n.right.right.p, new Point(4, 5));
              assertEquals(n.right.right.left.p, new Point(3, 3));
              assertEquals(n.right.right.right.p, new Point(4, 4));
          }

          @Test
          public void sanitySimpleNearestTest() {
              KDTree.Node n = t.getRoot();
              assertEquals(n.p, t.nearest(2, 3));
              assertEquals(n.right.p, t.nearest(4, 2));
              assertEquals(n.left.p, t.nearest(1, 5));
              assertEquals(n.right.right.p, t.nearest(4, 5));
              assertEquals(n.right.right.left.p, t.nearest(3, 3));
              assertEquals(n.right.right.right.p, t.nearest(4, 4));
          }

          @Test
          public void sanityRandomNearestTest() {
              Random r = new Random();
              for (int i = 0; i < 100; i++) {
                  l.add(new Point(r.nextDouble() * 100, r.nextDouble() * 100));
              }
              t = new KDTree(l);
              NaivePointSet s = new NaivePointSet(l);

              double x, y;
              for (int i = 0; i < 455; i++) {
                  x = r.nextDouble() * 100; y = r.nextDouble() * 100;
                  Point pt = t.nearest(x, y);
                  Point ps = s.nearest(x, y);
                  assertEquals(pt, ps);
              }
          }
      }
    #+end_src 
    - ~Random r = new Random()~ and ~r.nextDouble()~ 
