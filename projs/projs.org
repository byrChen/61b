#+TAGS: UNRESOLVED(u) QUESTIONS(q) EXTRA(e) REQUIRED(r) TOBEORG(t)

* Proj 0 NBody
** Writing the Body Class
*** calcDistance
    #+begin_src java :classname 
      public double calcDistance(Body b ) {
          double d = Math.sqrt(Math.pow(xxPos - b.xxPos, 2) + Math.pow(yyPos - b.yyPos, 2));
          return d;
      }
    #+end_src 
    - ~Math.sqrt(a)~ and ~Math.pow(b, n)~ 
*** calcNetForceExertedByX and calcNetForceExertedByY
    #+begin_src java :classname 
      public double calcNetForceExertedByX(Body[] b) {
          double NetForceByX = 0.0;
          for (Body body : b) {
              if (!this.equals(body)) {
                  NetForceByX += this.calcForceExertedByX(body);
              }
          }
          return NetForceByX;
      }
    #+end_src 
    - ~calcForceExertedByX(Body[] b)~
    - ~for (Body body : b) {}~
    - ~if (!this.equals(body))~ 
** (Optional) Testing Your Body Class
  #+begin_src java :classname 
    public class TestBody {

        public static void main(String[] args) {
            checkBody();
        }

        private static void checkEquals(double expected, double actual, String label, double eps){
            if (Double.isNaN(actual) || Double.isInfinite(actual)) {
                System.out.println("FAIL: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            } else if (expected == actual) {
                System.out.println("PASS: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            } else {
                System.out.println("FAIL: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            }
        }

        private static void checkBody(){
            Body b1 = new Body(1.0, 1.0, 3.0, 4.0, 5.0, "jupiter.gif");
            Body b2 = new Body(2.0, 1.0, 3.0, 4.0, 4e11, "jupiter.gif");
            checkEquals(133.4, b1.calcForceExertedBy(b2), "Pairwise Force", 0.01);
        }
    }
  #+end_src 
  - ~private static void~
  - ~Double.isNaN~ and ~Double.isInfinite~ first to guarantee ~==~ working
  - ~": Expected " + expected~ returns ~String~, ~int~ can be converted to ~String~
  - ~eps~ for ~==~ 
** Getting Started with the Simulator (NBody.java)
*** readBodies
    #+begin_src java :classname 
      public static Body[] readBodies(String filePath) {
          In in = new In(filePath);
          int N = in.readInt();
          double radius = in.readDouble();
          Body[] b = new Body[N];
          for (int i = 0; i < N; i++) {
              double xxPos = in.readDouble();
              double yyPos = in.readDouble();
              double xxVel = in.readDouble();
              double yyVel = in.readDouble();
              double mass = in.readDouble();
              String imgFileName = "./images/" + in.readString();
              b[i] = new Body(xxPos, yyPos, xxVel, yyVel, mass, imgFileName);
          }
          return b;
      }
    #+end_src 
    - ~public static Body[] readBodies~
    - ~Body[] b = new Body[5]~
    - ~b[i] = new Body(xxPos, yyPos, xxVel, yyVel, mass, imgFileName)~ 
** Drawing the Initial Universe State (main)
   #+begin_src java :classname 
     public static void main(String[] args) {
         double T = Double.parseDouble(args[0]);
         double dt = Double.parseDouble(args[1]);
         String filename = args[2];
         double radius = readRadius(filename);
         Body[] bodies = readBodies(filename);
         String backgroud = "./images/starfield.jpg";
         StdDraw.setScale(-radius, radius);
         StdDraw.enableDoubleBuffering();
         int N = 25;
         Double[] xForces = new Double[N];
         Double[] yForces = new Double[N];
         for (double i = 0; i < T; i = i + dt) {
             StdDraw.clear();
             for (int j = 0; j < N; j++) {
                 xForces[j] = bodies[j].calcNetForceExertedByX(bodies);
                 yForces[j] = bodies[j].calcNetForceExertedByY(bodies);
             }
             for (int j = 0; j < N; j++) {
                 bodies[j].update(dt, xForces[j], yForces[j]);
             }
             StdDraw.picture(0, 0, backgroud);
             for (Body b : bodies) {
                 b.draw();
             }
             StdDraw.show();
             StdDraw.pause(20);
         }
     }

     StdOut.printf("%d\n", bodies.length);
     StdOut.printf("%.2e\n", radius);
     for (int i = 0; i < bodies.length; i++) {
         StdOut.printf("%11.4e %11.4e %11.4e %11.4e %11.4e %12s\n",
                       bodies[i].xxPos, bodies[i].yyPos, bodies[i].xxVel,
                       bodies[i].yyVel, bodies[i].mass, bodies[i].imgFileName);
     }
   #+end_src 
   - ~Double.parseDouble(String)~ 
   - ~Class[] var = new Class[N]~
   - ~StdDraw~ and ~StdOut~
   - ~StdOut.printf()~
*** Question:                                                     :QUESTIONS:
    1. ~StdOut~ 和 ~System.out~ 异同？对比c++里的 ~cout~ 和 ~stdout~ 
   
** Extra for Experts                                                  :EXTRA:
*** Adding Audio                                                :UNRESOLVED:
*** Gold Points                                                 :UNRESOLVED:
* Proj 1A Data Structures                                           :TOBEORG:
** ~LinkedListDeque.java~ 
   #+begin_src java :classname 
     import java.io.NotActiveException;

     public class LinkedListDeque<T> {

         private Node<T> sentinel;
         private int size;

         private class Node<T> {
             private Node<T> prev;
             private Node<T> next;
             private T item;

             public Node(T iteM, Node preV, Node nexT) {
                 item = iteM;
                 prev = preV;
                 next = nexT;
             }
         }

         public LinkedListDeque() {
             sentinel = new Node(0, null, null);
             size = 0;
         }

         public  LinkedListDeque(LinkedListDeque other) {
             sentinel = new Node(0, null, null);
             size = 0;
             Node<T> p = other.sentinel.next;
     //        LinkedListDeque<T> popyLLD = new LinkedListDeque<>();
             for (int i = 0; i < other.size; i++) {
                 this.addLast(p.item);
                 p = p.next;
             }
         }

         public T getRecursive(int index) {
             LinkedListDeque<T> copyLLD = new LinkedListDeque<>(this);
             Node<T> p = copyLLD.sentinel;
             if (p == null || index >= size) {
                 return null;
             }
             if (index == 0) {
                 return p.next.item;
             }
             copyLLD.removeFirst();
             return copyLLD.getRecursive(index - 1);
         }

         public void addFirst(T item) {
             Node<T> node = new Node<>(item, null, null);
             if (isEmpty()) {
                 size = size + 1;
                 sentinel.next = node;
                 node.prev = sentinel;
                 sentinel.prev = node;
                 node.next = sentinel;
                 return;
             }
             size = size + 1;
             node.next = sentinel.next;
             sentinel.next.prev = node;
             node.prev = sentinel;
             sentinel.next = node;
         }

         public void addLast(T item) {
             Node<T> node = new Node<>(item, null, null);
             if (isEmpty()) {
                 sentinel.next = node;
                 node.prev = sentinel;
                 sentinel.prev = node;
                 node.next = sentinel;
                 size = size + 1;
                 return;
             }
             node.prev = sentinel.prev;
             sentinel.prev.next = node;
             node.next = sentinel;
             sentinel.prev = node;
             size = size + 1;
         }

         public boolean isEmpty() {
             return size == 0;
         }

         public int size() {
             return size;
         }

         public void printDeque() {
             Node p = sentinel;
             for (int i = 0; i < size; i++) {
                 System.out.print(p.next.item + " ");
                 p = p.next;
             }

             System.out.println();
         }

         public T removeFirst() {
             if (isEmpty()) {
                 return null;
             }
             Node<T> first = sentinel.next;
             sentinel.next = first.next;
             first.next.prev = sentinel;
             size = size - 1;
             return first.item;
         }

         public T removeLast() {
             if (isEmpty()) {
                 return null;
             }
             Node<T> last = sentinel.prev;
             sentinel.prev = last.prev;
             last.prev.next = sentinel;
             size = size - 1;
             return last.item;
         }

         public T get(int index) {
             if (isEmpty() || index < 0) {
                 return null;
             }
             Node<T> p = sentinel;
             for (int i = 0; i < index + 1; i++) {
                 p = p.next;
             }
             return p.item;
         }
     }
   #+end_src 
** ~ArrayDeque.java~
   #+begin_src java :classname 
     import java.util.TreeMap;

     public class ArrayDeque<T> {

         private T[] items;
         private int size;
         private int nextFirst;
         private int nextLast;
         private double ratio;

         public ArrayDeque() {
             size = 0;
             items = (T[]) new Object[8]; 
             nextFirst = 7;
             nextLast = 0;
             ratio = 0.25;
         }

         public ArrayDeque(ArrayDeque other) {
             items = (T[]) new Object[other.items.length];
             System.arraycopy(other.items, 0, items, 0, other.items.length);
             size = other.size;
             nextFirst = other.nextFirst;
             nextLast = other.nextLast;
             ratio = 0.25;
         }

         public void addFirst(T item) {
             items[nextFirst] = item;
             nextFirst = minusOne(nextFirst);
             size += 1;

             if (isFull()) {
                 this.resize(size * 2);
             }
         }

         public void addLast(T item) {
             items[nextLast] = item;
             nextLast = plusOne(nextLast);
             size += 1;

             if (isFull()) {
                 this.resize(size * 2);
             }
         }

         public int size() {
             return size;
         }

         public void printDeque() {
             for (int i = 0; i < size; i++) {
                 System.out.print(get(i) + " ");
             }
             System.out.println();
         }

         public T removeFirst() {
             if (isEmpty()) {
                 return null;
             }
             int index = plusOne(nextFirst);
             T x = items[index];
             items[index] = null;
             nextFirst = index;
             size -= 1;
             if (isWaste()) {
                 resize(items.length / 2);
             }
             return x;
         }

         public T removeLast() {
             if (isEmpty()) {
                 return null;
             }
             int index = minusOne(nextLast);
             T x = items[index];
             items[index] = null;
             nextLast = index;
             size -= 1;
             if (isWaste()) {
                 resize(items.length / 2);
             }
             return x;
         }

         public T get(int index) {
             if (index < 0 || index >= size) {
                 return  null;
             }
             return items[plusOne(index + nextFirst)];
         }

         private void resize(int capacity) {

             T[] newItems = (T []) new Object[capacity];
             int firstSize = items.length - nextFirst - 1;
             int start = plusOne(nextFirst);
             int secondSize = nextLast;

             if (isFull()) {
                 if (nextFirst == nextLast - 1) {
                     System.arraycopy(items, start, newItems, 0, firstSize);
                     System.arraycopy(items, 0, newItems, firstSize, secondSize);
                 } else {
                     System.arraycopy(items, start, newItems, 0, size);
                 }
             }

             if (isWaste()) {
                 if (nextLast > nextFirst) {
                     System.arraycopy(items, start, newItems, 0, size);
                 } else {
                     System.arraycopy(items, start, newItems, 0, firstSize);
                     System.arraycopy(items, 0, newItems, firstSize, secondSize);
                 }
             }

             nextFirst = capacity - 1;
             nextLast = size;
             items = newItems;
         }

         public Object[] items() {
             return items;
         }

         public int nextFirst() {
             return nextFirst;
         }

         public int nextLast() {
             return nextLast;
         }

         public int itemsLength() {
             return items.length;
         }

         private int minusOne(int index) {
             return (index + items.length - 1) % items.length;
         }

         private int plusOne(int index) {
             return (index + 1) % items.length;
         }

         public boolean isEmpty() {
             return size == 0;
         }

         private boolean isFull() {
             return size == items.length;
         }

         private boolean isWaste() {
             return items.length >= 16 && (float) size / items.length < ratio;
         }
     }
   #+end_src 

** Tests
*** ~LLDTest.java~
    #+begin_src java :classname 
      import org.junit.Test;
      import static org.junit.Assert.*;

      public class LLDTest {

          @Test
          public void getTest() {
              LinkedListDeque<Integer> llD = new LinkedListDeque<>();
              llD.addFirst(0);
              llD.addLast(1);
              assertEquals(1, (long) llD.removeLast());
              assertEquals(0, (long) llD.removeLast());
              llD.addLast(5);
              assertEquals(5, (long) llD.get(0));
          }

          @Test
          public void getRecursiveTest() {
              LinkedListDeque<Integer> llD = new LinkedListDeque<>();
              assertNull(llD.getRecursive(0));
              assertNull(llD.getRecursive(1));
              llD.addLast(0);
              assertEquals(0, (long) llD.getRecursive(0));
              llD.removeLast();
              assertNull(llD.getRecursive(0));
              llD.addFirst(1);
              assertEquals(1, (long) llD.getRecursive(0));
              llD.removeFirst();
              assertNull(llD.getRecursive(0));
          }
      }
    #+end_src 
*** ~ADTest.java~
    #+begin_src java :classname 
      import org.junit.Test;
      import static org.junit.Assert.*;

      public class ADTest {
          @Test
          public void constructorTest() {
              ArrayDeque<String> aD = new ArrayDeque<>();
              assertEquals(8,  aD.itemsLength());
              assertEquals(7, aD.nextFirst());
              assertEquals(0, aD.nextLast());
              ArrayDeque<String> newaD = new ArrayDeque<>(aD);
              assertEquals(aD.itemsLength(), newaD.itemsLength());
              assertEquals(aD.nextFirst(), newaD.nextFirst());
              assertEquals(aD.nextLast(), newaD.nextLast());
              assertArrayEquals(aD.items(), newaD.items());
              assertNotEquals(aD, newaD);
          }
          @Test
          public void addTest() {
              ArrayDeque<Integer> aD = new ArrayDeque<>();
              assertNull(aD.get(0));
              aD.addFirst(1);
              aD.addFirst(0);
              aD.addLast(2);
              Integer[] expect = {2, null, null, null, null, null, 0, 1};
              assertArrayEquals(expect, aD.items());
              assertEquals(5, aD.nextFirst());
              assertEquals(1, aD.nextLast());
              assertEquals(3, aD.size());
          }
          @Test
          public void removeTest() {
              ArrayDeque<Integer> aD = new ArrayDeque<>();
              assertNull(aD.removeFirst());
              assertNull(aD.removeLast());
              for (int i = 0; i < 7; i++) {
                  aD.addLast(i);
              }
              assertEquals(0, (long) aD.removeFirst());
              assertEquals(6, (long) aD.removeLast());
              Integer[] expect = {null, 1, 2, 3, 4, 5, null, null};
              assertArrayEquals(expect, aD.items());
              assertEquals(0, aD.nextFirst());
              assertEquals(6, aD.nextLast());
              assertEquals(5, aD.size());
          }
          @Test
          public void resizeTestF() {

              /* always addLast to full */
              ArrayDeque<Integer> aD1 = new ArrayDeque<>();
              for (int i = 0; i < 8; i++) {
                  aD1.addLast(i);
              }
              Integer[] expectF = {0, 1, 2, 3, 4, 5, 6, 7, null, null,
                      null, null, null, null, null, null};
              assertArrayEquals(expectF, aD1.items());
              aD1.addLast(8);
              expectF[8] = 8;
              assertArrayEquals(expectF, aD1.items());
              assertEquals(15, aD1.nextFirst());
              assertEquals(9, aD1.nextLast());
              assertEquals(9, aD1.size());

              /* always addFirst to full */
              ArrayDeque<Integer> aD2 = new ArrayDeque<>();
              for (int i = 7; i >= 0; i--) {
                  aD2.addFirst(i);
              }
              aD2.addLast(8);
              assertArrayEquals(aD1.items(), aD2.items());
              assertEquals(aD1.nextFirst(), aD2.nextFirst());
              assertEquals(aD1.nextLast(), aD2.nextLast());
              assertEquals(aD1.size(), aD2.size());

              /* addLast and addFirst (nextFirst = nextLast - 1) to full */
              ArrayDeque<Integer> aD3 = new ArrayDeque<>();
              for (int i = 3; i >= 0; i--) {
                  aD3.addFirst(i);
              }
              for (int i = 4; i < 8; i++) {
                  aD3.addLast(i);
              }
              aD3.addLast(8);
              assertArrayEquals(aD1.items(), aD3.items());
              assertEquals(aD1.nextFirst(), aD3.nextFirst());
              assertEquals(aD1.nextLast(), aD3.nextLast());
              assertEquals(aD1.size(), aD3.size());
          }

          @Test
          public void resizeTestW() {

              Integer[] expectF = {0, 1, 2, 3, 4, 5, 6, 7, 8, null,
                      null, null, null, null, null, null};
              ArrayDeque<Integer> aD3 = new ArrayDeque<>();
              for (int i = 0; i < 9; i++) {
                  aD3.addLast(i);
              }

              /* nextFirst = 15 to waste, copy left */
              Integer[] expectW = {0, 1, 2, null, null, null, null, null};
              ArrayDeque<Integer> aD4 = new ArrayDeque<>(aD3);
              for (int i = 0; i < 6; i++) {
                  aD4.removeLast();
              }
              assertArrayEquals(expectW, aD4.items());
              assertEquals(3, aD4.size());
              assertEquals(3, aD4.nextLast());
              assertEquals(7, aD4.nextFirst());

              /* nextLast = 0 to waste, copy right */
              ArrayDeque<Integer> aD5 = new ArrayDeque<>(aD3);
              for (int i = 0; i < 3; i++) {
                  aD5.addFirst(2 - i);
                  expectF[15 - i] = 2 - i;
              }
              assertArrayEquals(expectF, aD5.items());
              for (int i = 0; i < 9; i++) {
                  aD5.removeLast();
              }
              assertArrayEquals(expectW, aD5.items());
              assertEquals(3, aD5.size());
              assertEquals(3, aD5.nextLast());
              assertEquals(7, aD5.nextFirst());

              /* nextLast != 0 and nextFirst !=0
              and nextFirst > nextLast, copy two sides */
              ArrayDeque<Integer> aD6 = new ArrayDeque<>(aD3);
              for (int i = 0; i < 2; i++) {
                  aD6.addFirst(1 - i);
                  expectF[15 - i] = 1 - i;
              }
              expectF[13] = null;
              assertArrayEquals(expectF, aD6.items());
              for (int i = 0; i < 8; i++) {
                  aD6.removeLast();
              }
              expectW[2] = 0;
              assertArrayEquals(expectW, aD6.items());
              assertEquals(3, aD6.size());
              assertEquals(3, aD6.nextLast());
              assertEquals(7, aD6.nextFirst());

              /* nextLast != 0 and nextFirst !=0
              and nextFirst < nextLast, copy middle */
              ArrayDeque<Integer> aD7 = new ArrayDeque<>(aD3);
              for (int i = 0; i < 6; i++) {
                  aD7.removeFirst();
              }
              expectW[0] = 6;
              expectW[1] = 7;
              expectW[2] = 8;
              assertArrayEquals(expectW, aD7.items());
              assertEquals(3, aD7.size());
              assertEquals(3, aD7.nextLast());
              assertEquals(7, aD7.nextFirst());
          }
      }
    #+end_src 
* Project 1B Applying and Testing Data Structures version 1.0       :TOBEORG:
** ~Deque.java~
   #+begin_src java :classname 
     interface Deque<T> {

         void addFirst(T item);

         void addLast(T item);

         default boolean isEmpty() {
             return size() == 0;
         }

         int size();

         void printDeque();

         T removeFirst();

         T removeLast();

         T get(int index);
     }
   #+end_src 
** ~wordToDeque~
   #+begin_src java :classname 
     public class Palindrome {

         public Deque<Character> wordToDeque(String word) {

             Deque<Character> deQue = new LinkedListDeque<>();
             for (int i = word.length() - 1; i >= 0; i--) {
                 deQue.addFirst(word.charAt(i));
             }
             return deQue;
         }

         ...
     }
   #+end_src 
** ~isPalindrome~
   #+begin_src java :classname 
     public boolean isPalindrome(String word) {
         if (word.length() == 1 || word.length() == 0) {
             return true;
         }

         for (int i = 0; i < (word.length() / 2); i++) {
             if (word.charAt(i) != word.charAt(word.length() - i - 1)) {
                 return false;
             }
         }

         return true;

         // use wordToDeque
         //        Deque<Character> d = wordToDeque(word);
         //        String reverse = "";
         //        for (int i = 0; i < word.length(); i++) {
         //            reverse += d.removeLast();
         //        }
         //        return reverse.equals(word);
     }
   #+end_src 
** Generalized Palindrome and OffByOne
*** ~OffByOne~
    #+begin_src java :classname 
      /** This interface defines a method for determining equality of characters. */
      public interface CharacterComparator {
          /** Returns true if characters are equal by the rules of the implementing class. */
          boolean equalChars(char x, char y);
      }
    #+end_src 
    #+begin_src java :classname 
      public class OffByOne implements CharacterComparator {
          @Override
          public boolean equalChars(char x, char y) {
              int diff = (x - y < 0) ? (y - x) : (x - y);
              return diff == 1;
          }
      }
    #+end_src 
*** Generalized ~isPalindrome~
    #+begin_src java :classname 
      public boolean isPalindrome(String s, CharacterComparator cc) {

          if (s.length() == 0 || s.length() == 1) {
              return true;
          }

          for (int i = 0; i < s.length() / 2; i++) {
              if (!cc.equalChars(s.charAt(i), s.charAt(s.length() - i - 1))) {
                  return false;
              }
          }

          return true;
      }
    #+end_src 
** ~OffByN.java~
   #+begin_src java :classname 
     public class OffByN implements CharacterComparator {

         private int expect;
         public OffByN(int N) {
             expect = N;
         }
         @Override
         public boolean equalChars(char x, char y) {
             int diff = (x - y) < 0 ? (y - x) : (x - y);
             return diff == expect;
         }
     }
   #+end_src 
** Tests
*** isPalindrome Testing
    #+begin_src java :classname 
      import org.junit.Test;
      import static org.junit.Assert.*;

      public class TestPalindrome {
          // You must use this palindrome, and not instantiate
          // new Palindromes, or the autograder might be upset.
          static Palindrome palindrome = new Palindrome();

          @Test
          public void testWordToDeque() {
              Deque d = palindrome.wordToDeque("persiflage");
              String actual = "";
              for (int i = 0; i < "persiflage".length(); i++) {
                  actual += d.removeFirst();
              }
              assertEquals("persiflage", actual);
          }
          @Test
          public void testisPalindrome() {
              assertTrue(palindrome.isPalindrome("a"));
              assertTrue(palindrome.isPalindrome(""));
              assertTrue(palindrome.isPalindrome("aka"));
              assertFalse(palindrome.isPalindrome("akd"));
          }
      }
    #+end_src 
* Project 1 Gold
  #+begin_src java :classname 
    import static org.junit.Assert.*;
    import org.junit.Test;

    public class TestArrayDequeGold {

        private StudentArrayDeque<Integer> stu = new StudentArrayDeque<>();
        private ArrayDequeSolution<Integer> sol = new ArrayDequeSolution<>();
        private String msg = "\n";
        private int size = 0;

        @Test
        public void testDeque() {
            // test addFirst
            for (int i = 0; i < 100; i++) {
                int flag = StdRandom.uniform(4);
                int random = StdRandom.uniform(10);
                switch (flag) {
                    case 0:
                        size += 1;
                        sol.addFirst(random);
                        stu.addFirst(random);
                        msg = msg + "addFirst(" + random +")\n";
    //                    assertEquals(msg, sol.get(0), stu.get(0));
                        break;
                    case 1:
                        size += 1;
                        sol.addLast(random);
                        stu.addLast(random);
                        msg = msg + "addLast(" + random +")\n";
    //                    assertEquals(msg, (Integer) random, stu.get(size - 1));
    //                    assertEquals(msg, (Integer) random, sol.get(size - 1));
    //                    assertEquals(msg, sol.get(size - 1), stu.get(size - 1));
                        break;
                    case 2:
                        if (size == 0) {
                            break;
                        }
                        size -= 1;
                        msg = msg + "removeFirst()\n";
                        assertEquals(msg, sol.removeFirst(), stu.removeFirst());
                        break;
                    case 3:
                        if (size == 0) {
                            break;
                        }
                        size -= 1;
                        msg = msg + "removeLast()\n";
                        assertEquals(msg, sol.removeLast(), stu.removeLast());
                        break;
                }
            }
        }
    }
  #+end_src 
  - Only use ~addFirst~, ~addLast~, ~removeFirst~ and ~removeLast~, as actually there is a bug in ~addLast~ or ~get~
  - ~private String msg~ and ~private int size~ to trace
  - ~StdRandom.uniform(n)~ and ~StdRandom.uniform(a, b)~
  - ~switch~ and ~case~
  - ~assertEquals(String msg, expect, actual)~ 
* Project 2A Extrinsic MinPQ
** ~ArrayHeapMinPQ.java~ 
*** ~class PNode<T>~ 
    #+begin_src java :classname 
      public class ArrayHeapMinPQ<T> implements ExtrinsicMinPQ<T> {

          private class PNode<T> {
              T item;
              double priority;

              PNode(T item, double priority) {
                  this.item = item;
                  this.priority = priority;
              }
          }

          private ArrayList<PNode<T>> minHeap;
          private int size;
          private HashMap<T, Integer> items;

          public ArrayHeapMinPQ() {
              minHeap = new ArrayList<>();
              minHeap.add(null);
              items = new HashMap<>();
              size = 0;
          }
          ...
      }
    #+end_src 
    - ~ArrayList<PNode<T>> minHeap = new ArrayList<>()~ and ~HashMap<T, Integer> items = new HashMap<>()~
    - ~minHeap.addd(null)~
*** ~add~ 
    #+begin_src java :classname 
      @Override
      public void add(T item, double priority) {
          if (item == null || contains(item)) {
              throw new IllegalArgumentException("Items can't be null or duplicated.");
          }
          minHeap.add(new PNode(item, priority));
          size += 1;
          items.put(item, size);
          swim(size);
      }

      private void swim(int index) { <<elink1>>
          if (index == 1) return;
          if (lessThanParent(index)) {
              swap(index, index / 2);
              swim(index / 2);
          }
      }

      private boolean lessThanParent(int child) {
          if (child == 1) return false;
          return minHeap.get(child).priority < minHeap.get(child/2).priority;
      }

      private void swap(int x, int y) {
          items.replace(minHeap.get(x).item, y);
          items.replace(minHeap.get(y).item, x);
          PNode<T> temp = minHeap.get(x);
          minHeap.set(x, minHeap.get(y));
          minHeap.set(y, temp);
      }
    #+end_src 
    - ~add~: ~minHeap.add(new PNode(item, priority))~, ~items.put(item, size)~ and ~swim(size)~
    - ~swim~: ~swap(index, index / 2)~, recursive ~if (index == 1) return~ + ~swim(index / 2)~
    - ~lessThanParent~: ~if (child == 1) return false~ to avoid ~minHeap.get(child/2).priority~
    - ~swap~:
      - *Update* ~index~ of ~item~ first: ~items.replace(minHeap.get(x).item, y)~ and ~items.replace(minHeap.get(y).item, x)~
      - Then *swap* ~PNode<T>~: ~minHeap.set(x, minHeap.get(y))~ and ~minHeap.set(y, temp)~ 
*** ~getSmallest~ 
    #+begin_src java :classname 
      @Override
      public T getSmallest() {
          if (size == 0) return null;
          return minHeap.get(1).item;
      }
    #+end_src 
    - ~minHeap.get(1).item~ 
*** ~removeSmallest~ 
    #+begin_src java :classname 
      @Override
      public T removeSmallest() {
          if (size == 0) throw new IllegalArgumentException("Queue is empty.");
          T min = minHeap.get(1).item;
          minHeap.set(1, minHeap.get(size));
          items.replace(minHeap.get(1).item, 1);
          sink(1);
          minHeap.remove(size);
          size -= 1;
          items.remove(min);
          return min;
      }

      private void sink(int index) { <<elink2>>
          if (2 * index > size) return;
          int child = smallerChild(index);
          if (lessThanParent(child)) {
              swap(index, child);
              sink(child);
          }
      }

      private int smallerChild(int parent) {
          int left = 2 * parent;
          int right = 2 * parent + 1;
          if (left == size) return left;
          return minHeap.get(left).priority <= minHeap.get(right).priority ? left : right;
      }
    #+end_src 
    - ~removeSmallest~: ~minHeap.set(1, minHeap.get(size))~ --> ~items.replace(minHeap.get(1).item, 1)~ --> ~sink(1)~ --> ~minHeap.remove(size)~ and ~items.remove(min)~
    - ~sink~: ~swap(index, child)~, recursive ~if (2 * index > size) return~ and ~sink(child)~
    - ~smallerChild~: 
      - ~if (left == size) return left~ to avoid ~minHeap.get(right).priority~
      - ~minHeap.get(left).priority <= minHeap.get(right).priority ? left : right~ 
*** ~changePriority~ <<ilink1>>
    #+begin_src java :classname 
      @Override
      public void changePriority(T item, double priority) {
          if (!contains(item)) return;
          int index = items.get(item);
          minHeap.set(index, new PNode<T>(item, priority));
          if (lessThanParent(index)) swim(index);
          else sink(index);
      }
    #+end_src 
    - Update ~priority~ first: ~int index = items.get(item)~ and ~minHeap.set(index, new PNode<T>(item, priority))~
    - Then ~swim(index)~ or ~sink(index)~ 
*** Question:                                                     :QUESTIONS:
    - [ ] 如果不用 ~HashMap<T, Integer> items~ 记录，该怎么实现 ~contains~ 以及记录 ~item~ 和 ~index~ 的对应关系？如果没有 ~item~ 和 ~index~ 的关系又如何实现 [[ilink1][changePriority]] ？
    - [ ] 不用 ~ArrayList~, 直接用 ~PNode<T>[]~ 实现试试？包括 ~resize~ 的实现？
    - [ ] 关于运行时间分析：
      - [ ] 要求： ~getSmallest~, ~contains~, ~size~ and ~changePriority~ run in $O(log(n))$ time, ~add~ and ~removeSmallest~ run in $O(log(n))$ *average* time
      - [ ] 实际：？ [[ilink2][Runtime testing]]
** Tests
*** ~ArrayHeapMinPQTest.java~  
    #+begin_src java :classname 
      @Test
      public void sanityGenericTest() {
          try {
              ArrayHeapMinPQ<String> a = new ArrayHeapMinPQ<String>();
              ArrayHeapMinPQ<String> b = new ArrayHeapMinPQ<String>();
              ArrayHeapMinPQ<Integer> c = new ArrayHeapMinPQ<Integer>();
              ArrayHeapMinPQ<Boolean> e = new ArrayHeapMinPQ<Boolean>();
          } catch (Exception e) {
              fail();
          }
      }

      @Test
      public void sanityAddTest() {
          ArrayHeapMinPQ<String> a = new ArrayHeapMinPQ<>();
          try {
              a.add(null, 0.8);
              fail("No exception thrown.");
          } catch (Exception e) {
              assertTrue(e.getMessage().contains("Items can't be null or duplicated."));
          }
          assertEquals(0, a.size());
          assertNull(a.getSmallest());
          for (int i = 0; i < 455; i++) {
              a.add("a" + i, 455 - i);
              assertEquals("a" + i, a.getSmallest());
              assertEquals(i + 1, a.size());
          }
          try {
              a.add("a0", 0.8);
              fail("No exception thrown.");
          } catch (Exception e) {
              assertTrue(e.getMessage().contains("Items can't be null or duplicated."));
          }
      }

      @Test
      public void sanatyContainsTest() {
          ArrayHeapMinPQ<String> a = new ArrayHeapMinPQ<>();
          assertFalse(a.contains("a"));
          for (int i = 0; i < 455; i++) {
              a.add("a" + i, i);
              assertTrue(a.contains("a" + i));
          }
      }

      @Test
      public void sanityRemoveSamllestTest() {
          ArrayHeapMinPQ<String> a = new ArrayHeapMinPQ<>();
          try {
              a.removeSmallest();
              fail();
          } catch (Exception e) {
              e.getMessage().contains("Queue is empty.");
          }

          for (int i = 0; i < 455; i++) {
              a.add("a" + i, i);
          }
          for (int i = 0; i < 455; i++) {
              assertEquals("a" + i, a.removeSmallest());
              assertFalse(a.contains("a" + i));
              assertEquals(454 - i, a.size());
          }

          try {
              a.removeSmallest();
              fail();
          } catch (Exception e) {
              e.getMessage().contains("Queue is empty.");
          }
      }

      @Test
      public void sanityChangePriorityTest() {
          ArrayHeapMinPQ<String> a = new ArrayHeapMinPQ<>();
          ArrayHeapMinPQ<String> b = new ArrayHeapMinPQ<>();
          for (int i = 0; i < 455; i++) {
              a.add("a" + i, i);
              b.add("b" + i, i);
          }
          b.changePriority("b0", 455);
          for (int i = 0; i < 455; i++) {
              a.changePriority("a" + (454 - i), -1);
              assertEquals("a" + (454 - i), a.removeSmallest());
              if (i == 454) assertEquals("b0", b.removeSmallest());
              else assertEquals("b" + (i + 1), b.removeSmallest());
          }
      }
    #+end_src 
    - ~try {fail("No exception thrown.")} cache (Exception e) {e.getMessage().contains()}~
    - Use ~for~ to write tests
**** Question:                                                    :QUESTIONS:
     - [ ] 写测试时 ~try{} catch () {}~ 怎么捕捉多个异常并对不同异常分开测试？
*** Randomized testing                                     :UNRESOLVED:EXTRA:
*** Runtime testing <<ilink2>>                             :UNRESOLVED:EXTRA:
* Project 2B K-d Tree
** ~KDTree.java~ 
*** ~class Node~ 
    #+begin_src java :classname 
      public class KDTree implements PointSet {

          class Node {
              Point p;
              Node left, right;
              boolean compareX = true;

              Node(Point p, Node left, Node right) {
                  this.p = p; this.left = left; this.right = right;
              }
          }

          private Node root;

          Comparator<Node> nodeComparator = (child, parent) -> {
              if (parent.compareX) {
                  child.compareX = false;
                  return Double.compare(child.p.getX(), parent.p.getX());
              } else {
                  child.compareX = true;
                  return Double.compare(child.p.getY(), parent.p.getY());
              }
          };

          public KDTree(List<Point> points) {
              if (points.size() < 1) throw new IllegalArgumentException();
              root = new Node(points.get(0), null, null);
              for (int i = 1; i < points.size(); i++) {
                  put(new Node(points.get(i), null, null));
              }
          }
          ...
      }
    #+end_src 
    - ~boolean compareX~
    - ~Comparator<Node> nodeComparator = (child, parent) -> {};~
    - ~Double.compare~ 
    - ~root = new Node(points.get(0), null, null)~ and ~put(new Node(points.get(i), null, null))~
*** ~put~ 
    #+begin_src java :classname 
      public void put(Node n) {
          if (n == null) throw new IllegalArgumentException("calls put() with a null Node");
          root = put(root, n);
      }

      private Node put(Node parent, Node child) { <<ilink3>>
          if (parent == null) return child;
          int cmp = nodeComparator.compare(child, parent);
          if (cmp < 0) parent.left = put(parent.left, child);
          else         parent.right = put(parent.right, child);
          return parent;
      }
    #+end_src 
    - ~public void put(Node n)~: ~root = put(root, n)~
    - ~private Node put(Node parent, Node child)~:
      - ~int cmp = nodeComparator.compare(child, parent)~
      - Recursive: ~parent.left = put(parent.left, child)~ and ~parent.right = put(parent.right, child)~ 
*** ~nearest~ 
    #+begin_src java :classname 
      @Override
      public Point nearest(double x, double y) {
          Node goal = new Node(new Point(x, y), null, null);
          return nearest(root, goal, root).p;
      }

      private Node nearest(Node n, Node goal, Node best) { <<ilink4>>
          if (n == null) return best;
          int cmp = Double.compare(disBetween(n, goal), disBetween(best, goal));
          if (cmp < 0) best = n;
          cmp = nodeComparator.compare(goal, n);
          Node goodSide, badSide;
          goodSide = cmp < 0 ? n.left : n.right;
          badSide= cmp < 0 ? n.right : n.left;
          best = nearest(goodSide, goal, best);
          if (needBad(n, goal, disBetween(best, goal))) {
              best = nearest(badSide, goal, best);
          }
          return best;
      }

      private boolean needBad (Node n, Node goal, double min) { <<ilink5>>
          Double d;
          if (n.compareX) d = Math.pow(n.p.getX() - goal.p.getX(), 2);
          else d = Math.pow(n.p.getY() - goal.p.getY(), 2);
          int cmp = Double.compare(d, min);
          return cmp < 0 ? true : false;
      }

      private static double disBetween(Node n1, Node goal) {
          return Point.distance(n1.p, goal.p);
      }
    #+end_src 
    - ~public Point nearest(double x, double y)~: ~return nearest(root, goal, root).p~
    - ~private Node nearest(Node n, Node goal, Node best)~
      - ~Double.compare(disBetween(n, goal), disBetween(best, goal))~
      - ~cmp = nodeComparator.compare(goal, n)~ --> ~goodSide = cmp < 0 ? n.left : n.right~ and ~badSide= cmp < 0 ? n.right : n.left~
      - Recursive: ~best = nearest(goodSide, goal, best)~ and ~best = nearest(badSide, goal, best)~
    - ~private boolean needBad (Node n, Node goal, double min)~ 
      - ~d = Math.pow(n.p.getX() - goal.p.getX(), 2)~ and ~d = Math.pow(n.p.getY() - goal.p.getY(), 2)~
      - ~cmp < 0 ? true : false~ 
*** Question:                                                     :QUESTIONS:
    - [ ] 关于 recursive 的思考：有无返回值，需要传入什么样的参数，怎样的返回条件
      - [ ] 无返回， ~ArrayHeapMinPQ~ 的 [[file:61b_projs.org::<<elink1>>][swim]] 和 [[file:61b_projs.org::<<elink2>>][sink]]
      - [ ] 有返回值， ~BSTMap~ 的 [[file:61b_labs.org::<<elink4>>][put]], [[file:61b_labs.org::<<elink5>>][updateBST]], [[file:61b_labs.org::<<elink6>>][get]]; ~KDTree~ 的 [[ilink3][put]], [[ilink4][nearest]] 等
    - [ ] 有关模仿 ~BSTMap~ 的更多操作的实现，特别是 ~remove~ 
    - [ ] 关于 [[ilink5][needBad]] 的准确准则及实现，并用 randomized tests 验证速度
    - [ ] 如果数据的维数更多，又该怎么去实现？
** Tests
*** ~KDTreeTest.java~ 
    #+begin_src java :classname 
      public class KDTreeTest {

          private LinkedList<Point> l;
          private KDTree t;

          public KDTreeTest() {
              l = new LinkedList<>();
              l.add(new Point(2, 3));
              l.add(new Point(4, 2));
              l.add(new Point(4, 5));
              l.add(new Point(3, 3));
              l.add(new Point(1, 5));
              l.add(new Point(4, 4));
              t = new KDTree(l);
          }

          @Test
          public void sanityPutTest() {
              KDTree.Node n = t.getRoot();
              assertEquals(n.p, new Point(2, 3));
              assertEquals(n.right.p, new Point(4, 2));
              assertEquals(n.left.p, new Point(1, 5));
              assertEquals(n.right.right.p, new Point(4, 5));
              assertEquals(n.right.right.left.p, new Point(3, 3));
              assertEquals(n.right.right.right.p, new Point(4, 4));
          }

          @Test
          public void sanitySimpleNearestTest() {
              KDTree.Node n = t.getRoot();
              assertEquals(n.p, t.nearest(2, 3));
              assertEquals(n.right.p, t.nearest(4, 2));
              assertEquals(n.left.p, t.nearest(1, 5));
              assertEquals(n.right.right.p, t.nearest(4, 5));
              assertEquals(n.right.right.left.p, t.nearest(3, 3));
              assertEquals(n.right.right.right.p, t.nearest(4, 4));
          }

          @Test
          public void sanityRandomNearestTest() {
              Random r = new Random();
              for (int i = 0; i < 100; i++) {
                  l.add(new Point(r.nextDouble() * 100, r.nextDouble() * 100));
              }
              t = new KDTree(l);
              NaivePointSet s = new NaivePointSet(l);

              double x, y;
              for (int i = 0; i < 455; i++) {
                  x = r.nextDouble() * 100; y = r.nextDouble() * 100;
                  Point pt = t.nearest(x, y);
                  Point ps = s.nearest(x, y);
                  assertEquals(pt, ps);
              }
          }
      }
    #+end_src 
    - ~Random r = new Random()~ and ~r.nextDouble()~ 
* Project 2C Bear Maps                                              :TOBEORG:
** ~RasterAPIHandler.java~ 
*** ~processRequest~ 
    #+begin_src java :classname 
      public Map<String, Object> processRequest(Map<String, Double> requestParams, Response response) {
          Map<String, Object> results = new HashMap<>();
          results.put("query_success", false);
          double width = requestParams.get("w"), ullon = requestParams.get("ullon"),
                  ullat = requestParams.get("ullat"), lrlon = requestParams.get("lrlon"),
                  lrlat = requestParams.get("lrlat");
          int cmp1 = Double.compare(ullon, lrlon), cmp2 = Double.compare(ullat, lrlat);
          if (cmp1 > 0 || cmp2 < 0) return results;
          double requestLonDPP = (lrlon - ullon) / width,
                  initLonDPP = (ROOT_LRLON - ROOT_ULLON) / TILE_SIZE,
                  initLatDPP = (ROOT_ULLAT - ROOT_LRLAT) / TILE_SIZE;
          int depth = (int) Math.ceil(Math.log(initLonDPP / requestLonDPP) / Math.log(2));
          depth = depth < 0 ? 0 : depth;
          depth = depth > 7 ? 7 : depth;
          int blocks = (int) Math.pow(2, depth);
          double iLonDPP = initLonDPP / blocks, iLatDPP = initLatDPP / blocks;

          int xl = (int) Math.floor((ullon - ROOT_ULLON) / (iLonDPP * TILE_SIZE));
          int xr = (int) Math.floor((lrlon - ROOT_ULLON) / (iLonDPP * TILE_SIZE));
          int yu = (int) Math.floor((ROOT_ULLAT - ullat) / (iLatDPP * TILE_SIZE));
          int yd = (int) Math.floor((ROOT_ULLAT - lrlat) / (iLatDPP * TILE_SIZE));
          if (xl > blocks - 1 || xr < 0 || yu > blocks - 1 || yd < 0) return results;
          xl = xl < 0 ? 0 : xl;
          xr = xr > blocks - 1 ? blocks - 1 : xr;
          yu = yu < 0 ? 0 : yu;
          yd = yd > blocks - 1 ? blocks - 1 : yd;
          int y = yd - yu + 1, x = xr - xl + 1;
          String[][] grid = new String[y][x];
          for (int j = 0; j < y; j++) {
              for (int k = 0; k < x; k++) {
                  grid[j][k] = "d" + depth + "_x" + (k + xl) + "_y" + (j + yu) + ".png";
              }
          }
          double ul_lon = ROOT_ULLON + xl * (ROOT_LRLON - ROOT_ULLON) / blocks;
          double ul_lat = ROOT_ULLAT + yu * (ROOT_LRLAT - ROOT_ULLAT) / blocks;
          double lr_lon = ROOT_ULLON + (xr + 1) * (ROOT_LRLON - ROOT_ULLON) / blocks;
          double lr_lat = ROOT_ULLAT + (yd + 1) * (ROOT_LRLAT - ROOT_ULLAT) / blocks;
          results.put("render_grid", grid);
          results.put("raster_ul_lon", ul_lon);
          results.put("raster_ul_lat", ul_lat);
          results.put("raster_lr_lon", lr_lon);
          results.put("raster_lr_lat", lr_lat);
          results.put("depth", depth);
          results.put("query_success", true);

          return results;
      }
    #+end_src 
**** Question:                                                    :QUESTIONS:
     - [ ] ~processRequest~ 有没有更优雅的实现？
     - [ ] 以上对 ~double~ 的各种运算怎么保证精度？
** ~AugmentedStreetMapGraph.java~ 
*** ~AugmentedStreetMapGraph~ 
    #+begin_src java :classname 
      public class AugmentedStreetMapGraph extends StreetMapGraph {

          private HashMap<Point, Node> pToNode = new HashMap<>();
          private HashMap<String, List<Node>> nToNodes = new HashMap<>(); <<ilink6>>
          private HashMap<String, List<String>> clToNames = new HashMap<>();
          private KDTree kt;
          private MyTrieSet trie = new MyTrieSet();

          public AugmentedStreetMapGraph(String dbPath) {
              super(dbPath);
              // You might find it helpful to uncomment the line below:
              List<Node> nodes = this.getNodes();
              for (Node n : nodes) {
                  if (neighbors(n.id()).size() != 0) {
                      pToNode.put(new Point(n.lon(), n.lat()), n);
                  }
                  if (n.name() != null && !n.name().isEmpty()) {
                      String clean = cleanString(n.name());
                      if (!trie.collect().contains(clean)) {
                          trie.add(clean);
                      }
                      if (!clToNames.containsKey(clean)) {
                          clToNames.put(clean, new ArrayList<>());
                      }
                      if (!clToNames.get(clean).contains(n.name())) {
                          clToNames.get(clean).add(n.name());
                      }
                      if (!nToNodes.containsKey(n.name())) {
                          nToNodes.put(n.name(), new ArrayList<>());
                      }
                      nToNodes.get(n.name()).add(n);
                  }
              }
              List<Point> points = new ArrayList<>(pToNode.keySet());
              kt = new KDTree(points);
          }
          ...
      }
    #+end_src 
*** ~closest~ 
    #+begin_src java :classname 
      public long closest(double lon, double lat) {
          return pToNode.get(kt.nearest(lon, lat)).id();
      }
    #+end_src 
*** ~getLocationByPrefix~ <<ilink7>>                                  :EXTRA:
    #+begin_src java :classname 
      public List<String> getLocationsByPrefix(String prefix) {
          List<String> names = new ArrayList<>();
          for (String cl : trie.keysWithPrefix(cleanString(prefix))) {
              names.addAll(clToNames.get(cl));
          }
          return names;
      }
    #+end_src 
*** ~getLocations~ <<ilink8>>                                         :EXTRA:
    #+begin_src java :classname 
      public List<Map<String, Object>> getLocations(String locationName) {
          List<Map<String, Object>> locations = new ArrayList<>();
          for (String name : clToNames.get(cleanString(locationName))) {
              for (Node n : nToNodes.get(name)) {
                  HashMap<String, Object> map = new HashMap<>();
                  map.put("lat", n.lat());
                  map.put("lon", n.lon());
                  map.put("name", n.name());
                  map.put("id", n.id());
                  locations.add(map);
              }
          }

          return locations;
      }
    #+end_src 
*** ~cleanString~ <<ilink9>>
    #+begin_src java :classname 
      private static String cleanString(String s) {
          return s.replaceAll("[^a-zA-Z ]", "").toLowerCase();
      }
    #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] [[ilink6][nToNodes 和 clToNames]] 是必要的吗？ [[ilink7][getLocationsByPrefix]] 和 [[ilink8][getLocations]] 能否有更优雅的实现？
    - [ ] 为什么搜索的时候先要用 [[ilink9][cleanString]] 处理？输入字符与输出结果之间需要怎样的逻辑处理？
** ~Router.java~  
*** ~routeDirections~                                                 :EXTRA:
** Tests
*** ~TestRasterAPIHandler.java~
    #+begin_src java :classname 
      public class TestRasterAPIHandler {
          private static final double DOUBLE_THRESHOLD = 0.000000001;
          private static DecimalFormat df2 = new DecimalFormat(".#########");
          private static final String PARAMS_FILE = "../../library-sp19/data/proj2c_test_inputs/raster_params.txt";
          private static final String RESULTS_FILE = "../../library-sp19/data/proj2c_test_inputs/raster_results.txt";
          private static final int NUM_TESTS = 8;
          private static RasterAPIHandler rasterer;


          @Before
          public void setUp() throws Exception {
              rasterer = new RasterAPIHandler();
          }

          @Test
          public void testProcessRequests() throws Exception {
              List<Map<String, Double>> testParams = paramsFromFile();
              List<Map<String, Object>> expectedResults = resultsFromFile();

              for (int i = 0; i < NUM_TESTS; i++) {
                  System.out.println(String.format("Running test: %d", i));
                  Map<String, Double> params = testParams.get(i);
                  Map<String, Object> actual = rasterer.processRequest(params, null);
                  Map<String, Object> expected = expectedResults.get(i);
                  String msg = "Your results did not match the expected results for input "
                               + mapToString(params) + ".\n";
                  checkParamsMap(msg, expected, actual);
              }
          }

          private List<Map<String, Double>> paramsFromFile() throws Exception {
              List<String> lines = Files.readAllLines(Paths.get(PARAMS_FILE), Charset.defaultCharset());
              List<Map<String, Double>> testParams = new ArrayList<>();
              int lineIdx = 2; // ignore comment lines
              for (int i = 0; i < NUM_TESTS; i++) {
                  Map<String, Double> params = new HashMap<>();
                  params.put("ullon", Double.parseDouble(lines.get(lineIdx)));
                  params.put("ullat", Double.parseDouble(lines.get(lineIdx + 1)));
                  params.put("lrlon", Double.parseDouble(lines.get(lineIdx + 2)));
                  params.put("lrlat", Double.parseDouble(lines.get(lineIdx + 3)));
                  params.put("w", Double.parseDouble(lines.get(lineIdx + 4)));
                  params.put("h", Double.parseDouble(lines.get(lineIdx + 5)));
                  testParams.add(params);
                  lineIdx += 6;
              }
              return testParams;
          }

          private List<Map<String, Object>> resultsFromFile() throws Exception {
              List<String> lines = Files.readAllLines(Paths.get(RESULTS_FILE), Charset.defaultCharset());
              List<Map<String, Object>> expected = new ArrayList<>();
              int lineIdx = 4; // ignore comment lines
              for (int i = 0; i < NUM_TESTS; i++) {
                  Map<String, Object> results = new HashMap<>();
                  results.put("raster_ul_lon", Double.parseDouble(lines.get(lineIdx)));
                  results.put("raster_ul_lat", Double.parseDouble(lines.get(lineIdx + 1)));
                  results.put("raster_lr_lon", Double.parseDouble(lines.get(lineIdx + 2)));
                  results.put("raster_lr_lat", Double.parseDouble(lines.get(lineIdx + 3)));
                  results.put("depth", Integer.parseInt(lines.get(lineIdx + 4)));
                  results.put("query_success", Boolean.parseBoolean(lines.get(lineIdx + 5)));
                  lineIdx += 6;
                  String[] dimensions = lines.get(lineIdx).split(" ");
                  int rows = Integer.parseInt(dimensions[0]);
                  int cols = Integer.parseInt(dimensions[1]);
                  lineIdx += 1;
                  String[][] grid = new String[rows][cols];
                  for (int r = 0; r < rows; r++) {
                      for (int c = 0; c < cols; c++) {
                          grid[r][c] = lines.get(lineIdx);
                          lineIdx++;
                      }
                  }
                  results.put("render_grid", grid);
                  expected.add(results);
              }
              return expected;
          }

          private void checkParamsMap(String err, Map<String, Object> expected,
                                                  Map<String, Object> actual) {
              for (String key : expected.keySet()) {
                  assertTrue(err + "Your results map is missing "
                             + key, actual.containsKey(key));
                  Object o1 = expected.get(key);
                  Object o2 = actual.get(key);

                  if (o1 instanceof Double) {
                      String errMsg = genDiffErrMsg(err, expected, actual);
                      assertTrue(errMsg, Math.abs((Double) o1 - (Double) o2) < DOUBLE_THRESHOLD);
                  } else if (o1 instanceof String[][]) {
                      String errMsg = genDiffErrMsg(err, expected, actual);
                      assertArrayEquals(errMsg, (String[][]) o1, (String[][]) o2);
                  } else {
                      String errMsg = genDiffErrMsg(err, expected, actual);
                      assertEquals(errMsg, o1, o2);
                  }
              }
          }

          /** Generates an actual/expected message from a base message, an actual map,
           ,*  and an expected map.
           ,*/
          private String genDiffErrMsg(String basemsg, Map<String, Object> expected,
                                       Map<String, Object> actual) {
              return basemsg + "Expected: " + mapToString(expected) + ", but got\n"
                             + "Actual  : " + mapToString(actual);
          }

          /** Converts a Rasterer input or output map to its string representation. */
          private String mapToString(Map<String, ?> m) {
              StringJoiner sj = new StringJoiner(", ", "{", "}");

              List<String> keys = new ArrayList<>();
              keys.addAll(m.keySet());
              Collections.sort(keys);

              for (String k : keys) {

                  StringBuilder sb = new StringBuilder();
                  sb.append(k);
                  sb.append("=");
                  Object v = m.get(k);

                  if (v instanceof String[][]) {
                      sb.append(Arrays.deepToString((String[][]) v));
                  } else if (v instanceof Double) {
                      sb.append(df2.format(v));
                  } else {
                      sb.append(v.toString());
                  }
                  String thisEntry = sb.toString();

                  sj.add(thisEntry);
              }

              return sj.toString();
          }

      }
    #+end_src 
*** ~TestRouter.java~ 
    #+begin_src java :classname 
      public class TestRouter {
          private static final String PARAMS_FILE = "../../library-sp19/data/proj2c_test_inputs/path_params.txt";
          private static final String RESULTS_FILE = "../../library-sp19/data/proj2c_test_inputs/path_results.txt";
          private static final int NUM_TESTS = 8;
          private static final String OSM_DB_PATH = "../../library-sp19/data/proj2c_xml/berkeley-2019.osm.xml";
          private static AugmentedStreetMapGraph graph;
          private static boolean initialized = false;

          @Before
          public void setUp() throws Exception {
              if (initialized) {
                  return;
              }
              graph = new AugmentedStreetMapGraph(OSM_DB_PATH);
              initialized = true;

          }

          @Test
          public void testShortestPath() throws Exception {
              List<Map<String, Double>> testParams = paramsFromFile();
              List<List<Long>> expectedResults = resultsFromFile();

              for (int i = 0; i < NUM_TESTS; i++) {
                  System.out.println(String.format("Running test: %d", i));
                  Map<String, Double> params = testParams.get(i);
                  List<Long> actual = Router.shortestPath(graph,
                          params.get("start_lon"), params.get("start_lat"),
                          params.get("end_lon"), params.get("end_lat"));
                  List<Long> expected = expectedResults.get(i);
                  assertEquals("Your results did not match the expected results", expected, actual);
              }
          }

          private List<Map<String, Double>> paramsFromFile() throws Exception {
              List<String> lines = Files.readAllLines(Paths.get(PARAMS_FILE), Charset.defaultCharset());
              List<Map<String, Double>> testParams = new ArrayList<>();
              int lineIdx = 2; // ignore comment lines
              for (int i = 0; i < NUM_TESTS; i++) {
                  Map<String, Double> params = new HashMap<>();
                  params.put("start_lon", Double.parseDouble(lines.get(lineIdx)));
                  params.put("start_lat", Double.parseDouble(lines.get(lineIdx + 1)));
                  params.put("end_lon", Double.parseDouble(lines.get(lineIdx + 2)));
                  params.put("end_lat", Double.parseDouble(lines.get(lineIdx + 3)));
                  testParams.add(params);
                  lineIdx += 4;
              }
              return testParams;
          }

          private List<List<Long>> resultsFromFile() throws Exception {
              List<String> lines = Files.readAllLines(Paths.get(RESULTS_FILE), Charset.defaultCharset());
              List<List<Long>> expected = new ArrayList<>();
              int lineIdx = 2; // ignore comment lines
              for (int i = 0; i < NUM_TESTS; i++) {
                  int numVertices = Integer.parseInt(lines.get(lineIdx));
                  lineIdx++;
                  List<Long> path = new ArrayList<>();
                  for (int j = 0; j < numVertices; j++) {
                      path.add(Long.parseLong(lines.get(lineIdx)));
                      lineIdx++;
                  }
                  expected.add(path);
              }
              return expected;
          }
      }
    #+end_src 

*** ~TestRouterTiny.java~ 
    #+begin_src java :classname 
      public class TestRouterTiny {
          private static final String OSM_DB_PATH_TINY = "../../library-sp19/data/proj2c_xml/tiny-clean.osm.xml";
          private static AugmentedStreetMapGraph graphTiny;
          private static boolean initialized = false;

          @Before
          public void setUp() throws Exception {
              if (initialized) {
                  return;
              }
              graphTiny = new AugmentedStreetMapGraph(OSM_DB_PATH_TINY);
              initialized = true;
          }

          @Test
          public void test22to66() {
              List<Long> actual = Router.shortestPath(graphTiny, 0.2, 38.2, 0.6, 38.6);
              List<Long> expected = new ArrayList<>();
              expected.add(22L);
              expected.add(46L);
              expected.add(66L);
              assertEquals("Best path from 22 to 66 is incorrect.", expected, actual);
          }

          @Test
          public void test22to11() {
              List<Long> actual = Router.shortestPath(graphTiny, 0.2, 38.2, 0.1, 38.1);
              List<Long> expected = new ArrayList<>();
              expected.add(22L);
              expected.add(11L);
              assertEquals(expected, actual);
          }

          @Test
          public void test41to46() {
              List<Long> actual = Router.shortestPath(graphTiny, 0.4, 38.1, 0.4, 38.6);
              List<Long> expected = new ArrayList<>();
              expected.add(41L);
              expected.add(63L);
              expected.add(66L);
              expected.add(46L);
              assertEquals(expected, actual);
          }

          @Test
          public void test66to55() {
              List<Long> actual = Router.shortestPath(graphTiny, 0.6, 38.6, 0.5, 38.5);
              List<Long> expected = new ArrayList<>();
              expected.add(66L);
              expected.add(63L);
              expected.add(55L);
              assertEquals(expected, actual);
          }
      }
    #+end_src 
*** Question:                                                     :QUESTIONS:
    - [ ] 以上 tests 理解？
      
