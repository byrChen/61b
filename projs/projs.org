#+TAGS: UNRESOLVED(u) QUESTIONS(q) EXTRA(e) REQUIRED(r) TOBEORG(t)

* Proj 0 NBody
** Writing the Body Class
*** calcDistance
    #+begin_src java :classname 
      public double calcDistance(Body b ) {
          double d = Math.sqrt(Math.pow(xxPos - b.xxPos, 2) + Math.pow(yyPos - b.yyPos, 2));
          return d;
      }
    #+end_src 
    - ~Math.sqrt(a)~ and ~Math.pow(b, n)~ 
*** calcNetForceExertedByX and calcNetForceExertedByY
    #+begin_src java :classname 
      public double calcNetForceExertedByX(Body[] b) {
          double NetForceByX = 0.0;
          for (Body body : b) {
              if (!this.equals(body)) {
                  NetForceByX += this.calcForceExertedByX(body);
              }
          }
          return NetForceByX;
      }
    #+end_src 
    - ~calcForceExertedByX(Body[] b)~
    - ~for (Body body : b) {}~
    - ~if (!this.equals(body))~ 
** (Optional) Testing Your Body Class
  #+begin_src java :classname 
    public class TestBody {

        public static void main(String[] args) {
            checkBody();
        }

        private static void checkEquals(double expected, double actual, String label, double eps){
            if (Double.isNaN(actual) || Double.isInfinite(actual)) {
                System.out.println("FAIL: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            } else if (expected == actual) {
                System.out.println("PASS: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            } else {
                System.out.println("FAIL: " + label
                                   + ": Expected " + expected + " and you gave " + actual);
            }
        }

        private static void checkBody(){
            Body b1 = new Body(1.0, 1.0, 3.0, 4.0, 5.0, "jupiter.gif");
            Body b2 = new Body(2.0, 1.0, 3.0, 4.0, 4e11, "jupiter.gif");
            checkEquals(133.4, b1.calcForceExertedBy(b2), "Pairwise Force", 0.01);
        }
    }
  #+end_src 
  - ~private static void~
  - ~Double.isNaN~ and ~Double.isInfinite~ first to guarantee ~==~ working
  - ~": Expected " + expected~ returns ~String~, ~int~ can be converted to ~String~
  - ~eps~ for ~==~ 
** Getting Started with the Simulator (NBody.java)
*** readBodies
    #+begin_src java :classname 
      public static Body[] readBodies(String filePath) {
          In in = new In(filePath);
          int N = in.readInt();
          double radius = in.readDouble();
          Body[] b = new Body[N];
          for (int i = 0; i < N; i++) {
              double xxPos = in.readDouble();
              double yyPos = in.readDouble();
              double xxVel = in.readDouble();
              double yyVel = in.readDouble();
              double mass = in.readDouble();
              String imgFileName = "./images/" + in.readString();
              b[i] = new Body(xxPos, yyPos, xxVel, yyVel, mass, imgFileName);
          }
          return b;
      }
    #+end_src 
    - ~public static Body[] readBodies~
    - ~Body[] b = new Body[5]~
    - ~b[i] = new Body(xxPos, yyPos, xxVel, yyVel, mass, imgFileName)~ 
** Drawing the Initial Universe State (main)
   #+begin_src java :classname 
     public static void main(String[] args) {
         double T = Double.parseDouble(args[0]);
         double dt = Double.parseDouble(args[1]);
         String filename = args[2];
         double radius = readRadius(filename);
         Body[] bodies = readBodies(filename);
         String backgroud = "./images/starfield.jpg";
         StdDraw.setScale(-radius, radius);
         StdDraw.enableDoubleBuffering();
         int N = 25;
         Double[] xForces = new Double[N];
         Double[] yForces = new Double[N];
         for (double i = 0; i < T; i = i + dt) {
             StdDraw.clear();
             for (int j = 0; j < N; j++) {
                 xForces[j] = bodies[j].calcNetForceExertedByX(bodies);
                 yForces[j] = bodies[j].calcNetForceExertedByY(bodies);
             }
             for (int j = 0; j < N; j++) {
                 bodies[j].update(dt, xForces[j], yForces[j]);
             }
             StdDraw.picture(0, 0, backgroud);
             for (Body b : bodies) {
                 b.draw();
             }
             StdDraw.show();
             StdDraw.pause(20);
         }
     }

     StdOut.printf("%d\n", bodies.length);
     StdOut.printf("%.2e\n", radius);
     for (int i = 0; i < bodies.length; i++) {
         StdOut.printf("%11.4e %11.4e %11.4e %11.4e %11.4e %12s\n",
                       bodies[i].xxPos, bodies[i].yyPos, bodies[i].xxVel,
                       bodies[i].yyVel, bodies[i].mass, bodies[i].imgFileName);
     }
   #+end_src 
   - ~Double.parseDouble(String)~ 
   - ~Class[] var = new Class[N]~
   - ~StdDraw~ and ~StdOut~
   - ~StdOut.printf()~
*** Question:                                                     :QUESTIONS:
    1. ~StdOut~ 和 ~System.out~ 异同？对比c++里的 ~cout~ 和 ~stdout~ 
   
** Extra for Experts                                                  :EXTRA:
*** Adding Audio                                                :UNRESOLVED:
*** Gold Points                                                 :UNRESOLVED:
* Proj 1A Data Structures                                           :TOBEORG:
** LinkedListDeque 
   #+begin_src java :classname 
     import java.io.NotActiveException;

     public class LinkedListDeque<T> {

         private Node<T> sentinel;
         private int size;

         private class Node<T> {
             private Node<T> prev;
             private Node<T> next;
             private T item;

             public Node(T iteM, Node preV, Node nexT) {
                 item = iteM;
                 prev = preV;
                 next = nexT;
             }
         }

         public LinkedListDeque() {
             sentinel = new Node(0, null, null);
             size = 0;
         }

         public  LinkedListDeque(LinkedListDeque other) {
             sentinel = new Node(0, null, null);
             size = 0;
             Node<T> p = other.sentinel.next;
     //        LinkedListDeque<T> popyLLD = new LinkedListDeque<>();
             for (int i = 0; i < other.size; i++) {
                 this.addLast(p.item);
                 p = p.next;
             }
         }

         public T getRecursive(int index) {
             LinkedListDeque<T> copyLLD = new LinkedListDeque<>(this);
             Node<T> p = copyLLD.sentinel;
             if (p == null || index >= size) {
                 return null;
             }
             if (index == 0) {
                 return p.next.item;
             }
             copyLLD.removeFirst();
             return copyLLD.getRecursive(index - 1);
         }

         public void addFirst(T item) {
             Node<T> node = new Node<>(item, null, null);
             if (isEmpty()) {
                 size = size + 1;
                 sentinel.next = node;
                 node.prev = sentinel;
                 sentinel.prev = node;
                 node.next = sentinel;
                 return;
             }
             size = size + 1;
             node.next = sentinel.next;
             sentinel.next.prev = node;
             node.prev = sentinel;
             sentinel.next = node;
         }

         public void addLast(T item) {
             Node<T> node = new Node<>(item, null, null);
             if (isEmpty()) {
                 sentinel.next = node;
                 node.prev = sentinel;
                 sentinel.prev = node;
                 node.next = sentinel;
                 size = size + 1;
                 return;
             }
             node.prev = sentinel.prev;
             sentinel.prev.next = node;
             node.next = sentinel;
             sentinel.prev = node;
             size = size + 1;
         }

         public boolean isEmpty() {
             return size == 0;
         }

         public int size() {
             return size;
         }

         public void printDeque() {
             Node p = sentinel;
             for (int i = 0; i < size; i++) {
                 System.out.print(p.next.item + " ");
                 p = p.next;
             }

             System.out.println();
         }

         public T removeFirst() {
             if (isEmpty()) {
                 return null;
             }
             Node<T> first = sentinel.next;
             sentinel.next = first.next;
             first.next.prev = sentinel;
             size = size - 1;
             return first.item;
         }

         public T removeLast() {
             if (isEmpty()) {
                 return null;
             }
             Node<T> last = sentinel.prev;
             sentinel.prev = last.prev;
             last.prev.next = sentinel;
             size = size - 1;
             return last.item;
         }

         public T get(int index) {
             if (isEmpty() || index < 0) {
                 return null;
             }
             Node<T> p = sentinel;
             for (int i = 0; i < index + 1; i++) {
                 p = p.next;
             }
             return p.item;
         }
     }
   #+end_src 
** LLDTest
   #+begin_src java :classname 
     import org.junit.Test;
     import static org.junit.Assert.*;

     public class LLDTest {

         @Test
         public void getTest() {
             LinkedListDeque<Integer> llD = new LinkedListDeque<>();
             llD.addFirst(0);
             llD.addLast(1);
             assertEquals(1, (long) llD.removeLast());
             assertEquals(0, (long) llD.removeLast());
             llD.addLast(5);
             assertEquals(5, (long) llD.get(0));
         }

         @Test
         public void getRecursiveTest() {
             LinkedListDeque<Integer> llD = new LinkedListDeque<>();
             assertNull(llD.getRecursive(0));
             assertNull(llD.getRecursive(1));
             llD.addLast(0);
             assertEquals(0, (long) llD.getRecursive(0));
             llD.removeLast();
             assertNull(llD.getRecursive(0));
             llD.addFirst(1);
             assertEquals(1, (long) llD.getRecursive(0));
             llD.removeFirst();
             assertNull(llD.getRecursive(0));
         }
     }
   #+end_src 
** ArrayDeque
   #+begin_src java :classname 
     import java.util.TreeMap;

     public class ArrayDeque<T> {

         private T[] items;
         private int size;
         private int nextFirst;
         private int nextLast;
         private double ratio;

         public ArrayDeque() {
             size = 0;
             items = (T[]) new Object[8];
             nextFirst = 7;
             nextLast = 0;
             ratio = 0.25;
         }

         public ArrayDeque(ArrayDeque other) {
             items = (T[]) new Object[other.items.length];
             System.arraycopy(other.items, 0, items, 0, other.items.length);
             size = other.size;
             nextFirst = other.nextFirst;
             nextLast = other.nextLast;
             ratio = 0.25;
         }

         public void addFirst(T item) {
             items[nextFirst] = item;
             nextFirst = minusOne(nextFirst);
             size += 1;

             if (isFull()) {
                 this.resize(size * 2);
             }
         }

         public void addLast(T item) {
             items[nextLast] = item;
             nextLast = plusOne(nextLast);
             size += 1;

             if (isFull()) {
                 this.resize(size * 2);
             }
         }

         public int size() {
             return size;
         }

         public void printDeque() {
             for (int i = 0; i < size; i++) {
                 System.out.print(get(i) + " ");
             }
             System.out.println();
         }

         public T removeFirst() {
             if (isEmpty()) {
                 return null;
             }
             int index = plusOne(nextFirst);
             T x = items[index];
             items[index] = null;
             nextFirst = index;
             size -= 1;
             if (isWaste()) {
                 resize(items.length / 2);
             }
             return x;
         }

         public T removeLast() {
             if (isEmpty()) {
                 return null;
             }
             int index = minusOne(nextLast);
             T x = items[index];
             items[index] = null;
             nextLast = index;
             size -= 1;
             if (isWaste()) {
                 resize(items.length / 2);
             }
             return x;
         }

         public T get(int index) {
             if (index < 0 || index >= size) {
                 return  null;
             }
             return items[plusOne(index + nextFirst)];
         }

         private void resize(int capacity) {

             T[] newItems = (T []) new Object[capacity];
             int firstSize = items.length - nextFirst - 1;
             int start = plusOne(nextFirst);
             int secondSize = nextLast;

             if (isFull()) {
                 if (nextFirst == nextLast - 1) {
                     System.arraycopy(items, start, newItems, 0, firstSize);
                     System.arraycopy(items, 0, newItems, firstSize, secondSize);
                 } else {
                     System.arraycopy(items, start, newItems, 0, size);
                 }
             }

             if (isWaste()) {
                 if (nextLast > nextFirst) {
                     System.arraycopy(items, start, newItems, 0, size);
                 } else {
                     System.arraycopy(items, start, newItems, 0, firstSize);
                     System.arraycopy(items, 0, newItems, firstSize, secondSize);
                 }
             }

             nextFirst = capacity - 1;
             nextLast = size;
             items = newItems;
         }

         public Object[] items() {
             return items;
         }

         public int nextFirst() {
             return nextFirst;
         }

         public int nextLast() {
             return nextLast;
         }

         public int itemsLength() {
             return items.length;
         }

         private int minusOne(int index) {
             return (index + items.length - 1) % items.length;
         }

         private int plusOne(int index) {
             return (index + 1) % items.length;
         }

         public boolean isEmpty() {
             return size == 0;
         }

         private boolean isFull() {
             return size == items.length;
         }

         private boolean isWaste() {
             return items.length >= 16 && (float) size / items.length < ratio;
         }
     }
   #+end_src 
** ADTest
   #+begin_src java :classname 
     import org.junit.Test;
     import static org.junit.Assert.*;

     public class ADTest {
         @Test
         public void constructorTest() {
             ArrayDeque<String> aD = new ArrayDeque<>();
             assertEquals(8,  aD.itemsLength());
             assertEquals(7, aD.nextFirst());
             assertEquals(0, aD.nextLast());
             ArrayDeque<String> newaD = new ArrayDeque<>(aD);
             assertEquals(aD.itemsLength(), newaD.itemsLength());
             assertEquals(aD.nextFirst(), newaD.nextFirst());
             assertEquals(aD.nextLast(), newaD.nextLast());
             assertArrayEquals(aD.items(), newaD.items());
             assertNotEquals(aD, newaD);
         }
         @Test
         public void addTest() {
             ArrayDeque<Integer> aD = new ArrayDeque<>();
             assertNull(aD.get(0));
             aD.addFirst(1);
             aD.addFirst(0);
             aD.addLast(2);
             Integer[] expect = {2, null, null, null, null, null, 0, 1};
             assertArrayEquals(expect, aD.items());
             assertEquals(5, aD.nextFirst());
             assertEquals(1, aD.nextLast());
             assertEquals(3, aD.size());
         }
         @Test
         public void removeTest() {
             ArrayDeque<Integer> aD = new ArrayDeque<>();
             assertNull(aD.removeFirst());
             assertNull(aD.removeLast());
             for (int i = 0; i < 7; i++) {
                 aD.addLast(i);
             }
             assertEquals(0, (long) aD.removeFirst());
             assertEquals(6, (long) aD.removeLast());
             Integer[] expect = {null, 1, 2, 3, 4, 5, null, null};
             assertArrayEquals(expect, aD.items());
             assertEquals(0, aD.nextFirst());
             assertEquals(6, aD.nextLast());
             assertEquals(5, aD.size());
         }
         @Test
         public void resizeTestF() {

             /* always addLast to full */
             ArrayDeque<Integer> aD1 = new ArrayDeque<>();
             for (int i = 0; i < 8; i++) {
                 aD1.addLast(i);
             }
             Integer[] expectF = {0, 1, 2, 3, 4, 5, 6, 7, null, null,
                     null, null, null, null, null, null};
             assertArrayEquals(expectF, aD1.items());
             aD1.addLast(8);
             expectF[8] = 8;
             assertArrayEquals(expectF, aD1.items());
             assertEquals(15, aD1.nextFirst());
             assertEquals(9, aD1.nextLast());
             assertEquals(9, aD1.size());

             /* always addFirst to full */
             ArrayDeque<Integer> aD2 = new ArrayDeque<>();
             for (int i = 7; i >= 0; i--) {
                 aD2.addFirst(i);
             }
             aD2.addLast(8);
             assertArrayEquals(aD1.items(), aD2.items());
             assertEquals(aD1.nextFirst(), aD2.nextFirst());
             assertEquals(aD1.nextLast(), aD2.nextLast());
             assertEquals(aD1.size(), aD2.size());

             /* addLast and addFirst (nextFirst = nextLast - 1) to full */
             ArrayDeque<Integer> aD3 = new ArrayDeque<>();
             for (int i = 3; i >= 0; i--) {
                 aD3.addFirst(i);
             }
             for (int i = 4; i < 8; i++) {
                 aD3.addLast(i);
             }
             aD3.addLast(8);
             assertArrayEquals(aD1.items(), aD3.items());
             assertEquals(aD1.nextFirst(), aD3.nextFirst());
             assertEquals(aD1.nextLast(), aD3.nextLast());
             assertEquals(aD1.size(), aD3.size());
         }

         @Test
         public void resizeTestW() {

             Integer[] expectF = {0, 1, 2, 3, 4, 5, 6, 7, 8, null,
                     null, null, null, null, null, null};
             ArrayDeque<Integer> aD3 = new ArrayDeque<>();
             for (int i = 0; i < 9; i++) {
                 aD3.addLast(i);
             }

             /* nextFirst = 15 to waste, copy left */
             Integer[] expectW = {0, 1, 2, null, null, null, null, null};
             ArrayDeque<Integer> aD4 = new ArrayDeque<>(aD3);
             for (int i = 0; i < 6; i++) {
                 aD4.removeLast();
             }
             assertArrayEquals(expectW, aD4.items());
             assertEquals(3, aD4.size());
             assertEquals(3, aD4.nextLast());
             assertEquals(7, aD4.nextFirst());

             /* nextLast = 0 to waste, copy right */
             ArrayDeque<Integer> aD5 = new ArrayDeque<>(aD3);
             for (int i = 0; i < 3; i++) {
                 aD5.addFirst(2 - i);
                 expectF[15 - i] = 2 - i;
             }
             assertArrayEquals(expectF, aD5.items());
             for (int i = 0; i < 9; i++) {
                 aD5.removeLast();
             }
             assertArrayEquals(expectW, aD5.items());
             assertEquals(3, aD5.size());
             assertEquals(3, aD5.nextLast());
             assertEquals(7, aD5.nextFirst());

             /* nextLast != 0 and nextFirst !=0
             and nextFirst > nextLast, copy two sides */
             ArrayDeque<Integer> aD6 = new ArrayDeque<>(aD3);
             for (int i = 0; i < 2; i++) {
                 aD6.addFirst(1 - i);
                 expectF[15 - i] = 1 - i;
             }
             expectF[13] = null;
             assertArrayEquals(expectF, aD6.items());
             for (int i = 0; i < 8; i++) {
                 aD6.removeLast();
             }
             expectW[2] = 0;
             assertArrayEquals(expectW, aD6.items());
             assertEquals(3, aD6.size());
             assertEquals(3, aD6.nextLast());
             assertEquals(7, aD6.nextFirst());

             /* nextLast != 0 and nextFirst !=0
             and nextFirst < nextLast, copy middle */
             ArrayDeque<Integer> aD7 = new ArrayDeque<>(aD3);
             for (int i = 0; i < 6; i++) {
                 aD7.removeFirst();
             }
             expectW[0] = 6;
             expectW[1] = 7;
             expectW[2] = 8;
             assertArrayEquals(expectW, aD7.items());
             assertEquals(3, aD7.size());
             assertEquals(3, aD7.nextLast());
             assertEquals(7, aD7.nextFirst());
         }
     }
   #+end_src 
* Project 1B Applying and Testing Data Structures version 1.0       :TOBEORG:
** Deque Interface 
   #+begin_src java :classname 
     interface Deque<T> {

         void addFirst(T item);

         void addLast(T item);

         default boolean isEmpty() {
             return size() == 0;
         }

         int size();

         void printDeque();

         T removeFirst();

         T removeLast();

         T get(int index);
     }
   #+end_src 
** wordToDeque
   #+begin_src java :classname 
     public class Palindrome {

         public Deque<Character> wordToDeque(String word) {

             Deque<Character> deQue = new LinkedListDeque<>();
             for (int i = word.length() - 1; i >= 0; i--) {
                 deQue.addFirst(word.charAt(i));
             }
             return deQue;
         }

         ...
     }
   #+end_src 
** isPalindrome
*** isPalindrome Testing
    #+begin_src java :classname 
      import org.junit.Test;
      import static org.junit.Assert.*;

      public class TestPalindrome {
          // You must use this palindrome, and not instantiate
          // new Palindromes, or the autograder might be upset.
          static Palindrome palindrome = new Palindrome();

          @Test
          public void testWordToDeque() {
              Deque d = palindrome.wordToDeque("persiflage");
              String actual = "";
              for (int i = 0; i < "persiflage".length(); i++) {
                  actual += d.removeFirst();
              }
              assertEquals("persiflage", actual);
          }
          @Test
          public void testisPalindrome() {
              assertTrue(palindrome.isPalindrome("a"));
              assertTrue(palindrome.isPalindrome(""));
              assertTrue(palindrome.isPalindrome("aka"));
              assertFalse(palindrome.isPalindrome("akd"));
          }
      }
    #+end_src 
*** isPalindrome
    #+begin_src java :classname 
      public boolean isPalindrome(String word) {
          if (word.length() == 1 || word.length() == 0) {
              return true;
          }

          for (int i = 0; i < (word.length() / 2); i++) {
              if (word.charAt(i) != word.charAt(word.length() - i - 1)) {
                  return false;
              }
          }

          return true;

          // use wordToDeque
          //        Deque<Character> d = wordToDeque(word);
          //        String reverse = "";
          //        for (int i = 0; i < word.length(); i++) {
          //            reverse += d.removeLast();
          //        }
          //        return reverse.equals(word);
      }
    #+end_src 
** Generalized Palindrome and OffByOne
*** OffByOne
    #+begin_src java :classname 
      /** This interface defines a method for determining equality of characters. */
      public interface CharacterComparator {
          /** Returns true if characters are equal by the rules of the implementing class. */
          boolean equalChars(char x, char y);
      }
    #+end_src 
    #+begin_src java :classname 
      public class OffByOne implements CharacterComparator {
          @Override
          public boolean equalChars(char x, char y) {
              int diff = (x - y < 0) ? (y - x) : (x - y);
              return diff == 1;
          }
      }
    #+end_src 
*** Generalized Palindrome
    #+begin_src java :classname 
      public boolean isPalindrome(String s, CharacterComparator cc) {

          if (s.length() == 0 || s.length() == 1) {
              return true;
          }

          for (int i = 0; i < s.length() / 2; i++) {
              if (!cc.equalChars(s.charAt(i), s.charAt(s.length() - i - 1))) {
                  return false;
              }
          }

          return true;
      }
    #+end_src 
** OffByN
   #+begin_src java :classname 
     public class OffByN implements CharacterComparator {

         private int expect;
         public OffByN(int N) {
             expect = N;
         }
         @Override
         public boolean equalChars(char x, char y) {
             int diff = (x - y) < 0 ? (y - x) : (x - y);
             return diff == expect;
         }
     }
   #+end_src 
* Project 1 Gold
  #+begin_src java :classname 
    import static org.junit.Assert.*;
    import org.junit.Test;

    public class TestArrayDequeGold {

        private StudentArrayDeque<Integer> stu = new StudentArrayDeque<>();
        private ArrayDequeSolution<Integer> sol = new ArrayDequeSolution<>();
        private String msg = "\n";
        private int size = 0;

        @Test
        public void testDeque() {
            // test addFirst
            for (int i = 0; i < 100; i++) {
                int flag = StdRandom.uniform(4);
                int random = StdRandom.uniform(10);
                switch (flag) {
                    case 0:
                        size += 1;
                        sol.addFirst(random);
                        stu.addFirst(random);
                        msg = msg + "addFirst(" + random +")\n";
    //                    assertEquals(msg, sol.get(0), stu.get(0));
                        break;
                    case 1:
                        size += 1;
                        sol.addLast(random);
                        stu.addLast(random);
                        msg = msg + "addLast(" + random +")\n";
    //                    assertEquals(msg, (Integer) random, stu.get(size - 1));
    //                    assertEquals(msg, (Integer) random, sol.get(size - 1));
    //                    assertEquals(msg, sol.get(size - 1), stu.get(size - 1));
                        break;
                    case 2:
                        if (size == 0) {
                            break;
                        }
                        size -= 1;
                        msg = msg + "removeFirst()\n";
                        assertEquals(msg, sol.removeFirst(), stu.removeFirst());
                        break;
                    case 3:
                        if (size == 0) {
                            break;
                        }
                        size -= 1;
                        msg = msg + "removeLast()\n";
                        assertEquals(msg, sol.removeLast(), stu.removeLast());
                        break;
                }
            }
        }
    }
  #+end_src 
  - Only use ~addFirst~, ~addLast~, ~removeFirst~ and ~removeLast~, as actually there is a bug in ~addLast~ or ~get~
  - ~private String msg~ and ~private int size~ to trace
  - ~StdRandom.uniform(n)~ and ~StdRandom.uniform(a, b)~
  - ~switch~ and ~case~
  - ~assertEquals(String msg, expect, actual)~ 

